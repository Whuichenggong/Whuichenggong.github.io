<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>森林</title>
  
  
  <link href="https://whuichenggong.github.io/atom.xml" rel="self"/>
  
  <link href="https://whuichenggong.github.io/"/>
  <updated>2025-01-02T11:42:08.516Z</updated>
  <id>https://whuichenggong.github.io/</id>
  
  <author>
    <name>赵忠赫</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>go中的context</title>
    <link href="https://whuichenggong.github.io/2025/01/02/%E8%B0%83%E7%94%A8/"/>
    <id>https://whuichenggong.github.io/2025/01/02/%E8%B0%83%E7%94%A8/</id>
    <published>2025-01-02T09:34:59.595Z</published>
    <updated>2025-01-02T11:42:08.516Z</updated>
    
    <content type="html"><![CDATA[<p>首先理解同步调用与异步调用：</p><p><strong>同步调用</strong>和<strong>异步调用</strong>是两种常见的函数调用方式，尤其在多线程、并发编程中，这两种方式对程序的执行流程和效率有着直接影响。</p><h3 id="1-同步调用（Synchronous-Call）"><a href="#1-同步调用（Synchronous-Call）" class="headerlink" title="1. 同步调用（Synchronous Call）"></a>1. <strong>同步调用（Synchronous Call）</strong></h3><p>同步调用是指函数调用时，调用者会等待被调用的函数执行完毕并返回结果之后，才能继续执行后续操作。在同步调用过程中，函数的调用者会<strong>阻塞</strong>，直到函数执行完成。</p><p><strong>特点</strong>：</p><ul><li><strong>阻塞</strong>：调用者会等待被调用的函数执行完成，才会继续执行后续代码。</li><li><strong>执行顺序</strong>：代码按顺序执行，当前任务完成后，才能继续下一个任务。</li></ul><p><strong>举个例子</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟一个同步调用的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longTask</span><span class="params">()</span></span> &#123;</span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Long task finished&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Start task&quot;</span>)</span><br><span class="line">    longTask()  <span class="comment">// 同步调用，调用者会等待该函数执行完</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;End task&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Start task</span><br><span class="line">Long task finished</span><br><span class="line">End task</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>longTask()</code> 函数执行时，程序会等待它执行完毕，然后才继续执行后面的 <code>fmt.Println(&quot;End task&quot;)</code>。</p><h3 id="2-异步调用（Asynchronous-Call）"><a href="#2-异步调用（Asynchronous-Call）" class="headerlink" title="2. 异步调用（Asynchronous Call）"></a>2. <strong>异步调用（Asynchronous Call）</strong></h3><p>异步调用是指调用者在调用函数时，不会等待函数执行完成，而是直接继续执行后续代码。异步调用通常会通过某种机制（比如回调函数、线程、goroutine等）来处理函数执行完成后的结果。</p><p><strong>特点</strong>：</p><ul><li><strong>非阻塞</strong>：调用者不会等待被调用的函数执行完成，而是继续执行后续操作。</li><li><strong>执行顺序</strong>：调用者继续执行，而被调用的函数可能在后台执行，执行顺序不确定。</li></ul><p><strong>举个例子（使用 Go 的 goroutine）</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟一个异步调用的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longTask</span><span class="params">()</span></span> &#123;</span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Long task finished&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Start task&quot;</span>)</span><br><span class="line">    <span class="keyword">go</span> longTask()  <span class="comment">// 异步调用，goroutine 不会阻塞主线程</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;End task&quot;</span>)</span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)  <span class="comment">// 等待 goroutine 执行完毕</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Start task</span><br><span class="line">End task</span><br><span class="line">Long task finished</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>longTask()</code> 被异步调用（通过 <code>go</code> 关键字），主线程并不会等待 <code>longTask()</code> 执行完毕，而是继续执行 <code>fmt.Println(&quot;End task&quot;)</code>。由于 <code>longTask()</code> 是在一个新的 goroutine 中执行的，所以它会在主线程打印完 <code>&quot;End task&quot;</code> 后才完成。</p><h3 id="同步调用与异步调用的区别："><a href="#同步调用与异步调用的区别：" class="headerlink" title="同步调用与异步调用的区别："></a><strong>同步调用与异步调用的区别</strong>：</h3><table><thead><tr><th><strong>特性</strong></th><th><strong>同步调用</strong></th><th><strong>异步调用</strong></th></tr></thead><tbody><tr><td><strong>执行方式</strong></td><td>当前任务需要等待被调用函数执行完毕后才能继续</td><td>当前任务不会等待，被调用函数在后台执行</td></tr><tr><td><strong>阻塞与非阻塞</strong></td><td>阻塞：调用者会等待被调用函数完成</td><td>非阻塞：调用者不会等待被调用函数完成，继续执行</td></tr><tr><td><strong>执行顺序</strong></td><td>按顺序执行，当前任务完成后，继续下一个任务</td><td>执行顺序不确定，被调用函数可能稍后执行</td></tr><tr><td><strong>适用场景</strong></td><td>适用于需要等待函数执行完成后才能继续的情况</td><td>适用于可以并行处理，调用者不需要等待结果的情况</td></tr><tr><td><strong>效率</strong></td><td>效率较低，尤其在调用高延时操作时，调用者会被阻塞</td><td>效率较高，可以并行执行多个任务，不阻塞调用者</td></tr></tbody></table><h3 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a><strong>优缺点</strong>：</h3><ul><li><p><strong>同步调用</strong>：</p><ul><li><strong>优点</strong>：简单，易于理解和调试，程序的执行顺序清晰。</li><li><strong>缺点</strong>：当操作耗时较长时，调用者需要等待，造成性能瓶颈。例如，I&#x2F;O 密集型操作（如数据库查询、网络请求等）可能导致程序停滞。</li></ul></li><li><p><strong>异步调用</strong>：</p><ul><li><strong>优点</strong>：提高并发性能，特别适合处理 I&#x2F;O 密集型操作。调用者不需要等待操作完成，可以同时执行多个任务。</li><li><strong>缺点</strong>：需要更多的设计和管理，比如回调函数、并发控制等；调试和错误处理可能比较复杂。</li></ul></li></ul><h3 id="何时选择同步和异步？"><a href="#何时选择同步和异步？" class="headerlink" title="何时选择同步和异步？"></a><strong>何时选择同步和异步？</strong></h3><ul><li><strong>同步调用</strong>：适用于需要按顺序执行任务且任务之间有依赖关系的场景。例如，计算任务需要按顺序完成，或者需要等待数据库查询结果再执行下一步操作。</li><li><strong>异步调用</strong>：适用于任务之间没有直接依赖关系，可以并行执行的场景。例如，网络请求、文件处理、并发计算等。</li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结</strong>：</h3><ul><li><strong>同步调用</strong>是阻塞的，调用者需要等待被调用函数执行完成后才能继续执行后续代码。</li><li><strong>异步调用</strong>是非阻塞的，调用者不会等待被调用函数执行完成，而是继续执行后续操作，通常通过回调或并发机制处理结果。</li></ul><h2 id="并发相关能力："><a href="#并发相关能力：" class="headerlink" title="并发相关能力："></a>并发相关能力：</h2><p>创建了一个异步的协程或者线程，如果你不知道它什么时候终止，最好不要创建它！ 做到心中有数，理解并发！什么时候该用</p><p>线程： 是cpu需要执行的任务</p><p>并发执行，看似在一起做实行，如果是一个cpu核心那么：实则是一个人在两个任务之间快速的切换！（本质还是一个人做两件事，只不过两件事都分别分配一点时间）</p><p>两个核心执行两个线程 就相当于并行执行两个任务，时间将会被大大缩短</p><p>但是实际情况还是会非常复杂：</p><p>锁机制：</p><p>即使有两个cpu可以工作，但是他们需要持有锁的那个才可以工作！这也就导致了实际的工作还是并发执行！</p><p>高性能程序尽量避免使用锁</p><p>context之间形成多叉树的结构！</p><p>父ctx派生 多个子ctx</p><p>感知生命周期  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先理解同步调用与异步调用：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步调用&lt;/strong&gt;和&lt;strong&gt;异步调用&lt;/strong&gt;是两种常见的函数调用方式，尤其在多线程、并发编程中，这两种方式对程序的执行流程和效率有着直接影响。&lt;/p&gt;
&lt;h3 id=&quot;1-同步调用（Syn</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>软技能</title>
    <link href="https://whuichenggong.github.io/2025/01/02/%E8%BD%AF%E6%8A%80%E8%83%BD/"/>
    <id>https://whuichenggong.github.io/2025/01/02/%E8%BD%AF%E6%8A%80%E8%83%BD/</id>
    <published>2025-01-02T03:55:16.442Z</published>
    <updated>2025-01-02T04:34:21.613Z</updated>
    
    <content type="html"><![CDATA[<p>书中的前言： 引用的几句名言！</p><p>“现在的困难可能会成为未来的趋势”</p><p>“站在对方的角度，在说服对方的时候，为他准备好解决问题的方案”</p><p>“不浪费任何一次危机，任何危机都是组织结构重新组合的重大契机”</p><p>“作为听者，你能理解表达能力较弱的一方的言说，作为言说者，你能让理解力较弱的一方明白你的意思”</p><hr><p>组合型思维： 我这里强，需要你那里强，互相配合，达到双赢，</p><p>多想：</p><p>你能为别人做什么，你能为圈子带来什么。为什么小的时候看什么都新奇，到那时长大后变得更加麻木了呢？对周围事物，没有了其他想法<br>是不是思维被固定住了呢？ 保持孩童般的惊奇！</p><p>主动创造不平凡：</p><p>有些人就是不甘于平凡！才会造就出一些令世人震惊的事物。</p><p>做事情的两种方法：</p><ol><li>做减法：<br>拿出一段时间，排除各种琐事的干扰，降低认知负荷，集中能量，完全自主就干这一件事</li><li>做加法<br>主动给事情增加难度，你觉得没意思，可以去悬崖边看书哈哈哈，真的可以，但是要注意安全呢</li></ol><p>但是，世界上有很多事情根本不需要去做，还有些事情是不能去做的！，被别人认可的事情就是一定是好的吗？可能你在你只是在一些无意义的事做了循环<br>无用功</p><p>所以，如何判断哪些事需要做，哪些是不能做！这也是一个人的能力</p><p>有效的反馈系统： 一件事该不该做，通常是需要总结之前做事的结果，做一件事后产生的预期结果之后<br>分析做成的原因， 运气？or 实力？自己心里要清楚<br>没有达到预期的事情，花时间想问题出在了哪里？调整自己的行为</p><p>培养同理心：培养理解他人的能力，站在对方的角度思考问题，</p><p>”辛辛苦苦发明一样东西，却发现世界并不需要他“：  创新和实际需求之间的鸿沟</p><p>保持敬畏心：</p><p>（愿意去学习、去探索，而不是自以为是或过于自信。承认自然界的复杂性和不确定性，推动自己不断探索。）愿意通过反思和努力去改进</p><p>技能是无限的，我们的时间和精力是有限的，造成结果就是，我们对一切事物只能做到一知半解，很多技能也掌握的二把刀水平，对于自己力所不能及的事情，不要去做<br>力所能及的事情，做起来也要留三分（可以在完成的基础上保持精力和资源的余地，为未来的工作或挑战做好准备。）</p><p>剥离情感（但不等同于没有同理心）：</p><p>很多事，自己的情感卷进去就不好了，同理心要求我们摒弃以自我为中心的想法，剥离情感是让我们不要被情感牵着鼻子走，保持客观公正的判断力！</p><p>改变模式而不是放弃机遇：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;书中的前言： 引用的几句名言！&lt;/p&gt;
&lt;p&gt;“现在的困难可能会成为未来的趋势”&lt;/p&gt;
&lt;p&gt;“站在对方的角度，在说服对方的时候，为他准备好解决问题的方案”&lt;/p&gt;
&lt;p&gt;“不浪费任何一次危机，任何危机都是组织结构重新组合的重大契机”&lt;/p&gt;
&lt;p&gt;“作为听者，你能理解表</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>新年新气象</title>
    <link href="https://whuichenggong.github.io/2025/01/01/%E6%96%B0%E7%9A%84%E4%B8%80%E5%B9%B4/"/>
    <id>https://whuichenggong.github.io/2025/01/01/%E6%96%B0%E7%9A%84%E4%B8%80%E5%B9%B4/</id>
    <published>2025-01-01T02:28:33.843Z</published>
    <updated>2025-01-01T02:30:22.416Z</updated>
    
    <content type="html"><![CDATA[<p>新的一年开始了，我希望我能在新的一年里，不断的审视自己，关注自己的一言一行，一举一动，如果有哪些坏习惯，要去更改！</p><p>希望自己变得越来越好吧！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;新的一年开始了，我希望我能在新的一年里，不断的审视自己，关注自己的一言一行，一举一动，如果有哪些坏习惯，要去更改！&lt;/p&gt;
&lt;p&gt;希望自己变得越来越好吧！&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://whuichenggong.github.io/2024/12/28/github%E4%B8%BB%E9%A1%B5/"/>
    <id>https://whuichenggong.github.io/2024/12/28/github%E4%B8%BB%E9%A1%B5/</id>
    <published>2024-12-28T13:03:47.055Z</published>
    <updated>2024-12-28T13:03:47.055Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>你的灯还亮着吗</title>
    <link href="https://whuichenggong.github.io/2024/12/28/%E7%9C%8B%E4%BA%86%E4%B8%80%E6%9C%AC%E4%B9%A6/"/>
    <id>https://whuichenggong.github.io/2024/12/28/%E7%9C%8B%E4%BA%86%E4%B8%80%E6%9C%AC%E4%B9%A6/</id>
    <published>2024-12-28T10:40:19.406Z</published>
    <updated>2024-12-29T06:29:09.636Z</updated>
    
    <content type="html"><![CDATA[<p>今天一下午的时间看了这本书，对我的感触很大，很有助于思考，对于一个问题的思考，一种问题不同的问法，产生不同的问题</p><p>文字游戏：一句话不同的停顿产生不同的问题</p><p>有些事情是不是简单的问题复杂化（这应该是普遍现象） 复杂的问题简单化（很少）</p><p>你是不是真的想要解决这问题？</p><p>追溯本源，从一个婴儿视角重新审视这个问题！</p><p>一生二，二生三，三生万物： 你对一个问题的解决（是否是真的解决？）一个问题的解决必然产生另一个问题的产生！</p><p>看看你是否能从一个问题的解决，来想到它产生了3个其他的问题？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天一下午的时间看了这本书，对我的感触很大，很有助于思考，对于一个问题的思考，一种问题不同的问法，产生不同的问题&lt;/p&gt;
&lt;p&gt;文字游戏：一句话不同的停顿产生不同的问题&lt;/p&gt;
&lt;p&gt;有些事情是不是简单的问题复杂化（这应该是普遍现象） 复杂的问题简单化（很少）&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="书籍" scheme="https://whuichenggong.github.io/categories/%E4%B9%A6%E7%B1%8D/"/>
    
    
    <category term="书籍" scheme="https://whuichenggong.github.io/tags/%E4%B9%A6%E7%B1%8D/"/>
    
    <category term="思考" scheme="https://whuichenggong.github.io/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>考试周</title>
    <link href="https://whuichenggong.github.io/2024/12/25/2024.12.25/"/>
    <id>https://whuichenggong.github.io/2024/12/25/2024.12.25/</id>
    <published>2024-12-25T09:39:46.979Z</published>
    <updated>2024-12-25T09:41:14.102Z</updated>
    
    <content type="html"><![CDATA[<p>最近考试好多啊，几乎没有了自己的时间，还要考驾照，在学校，一定要在最受规定的条件下，才能有自己的学习时间啊</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近考试好多啊，几乎没有了自己的时间，还要考驾照，在学校，一定要在最受规定的条件下，才能有自己的学习时间啊&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>新的笔记软件</title>
    <link href="https://whuichenggong.github.io/2024/12/23/%E8%BD%AC%E6%8D%A2%E4%B8%80%E4%B8%8B/"/>
    <id>https://whuichenggong.github.io/2024/12/23/%E8%BD%AC%E6%8D%A2%E4%B8%80%E4%B8%8B/</id>
    <published>2024-12-23T13:13:12.099Z</published>
    <updated>2024-12-23T13:14:15.920Z</updated>
    
    <content type="html"><![CDATA[<p>Obsidian 要成为我的笔记软件了！ 真的太强大了！ 我想用一种新的形式去更加有效的记录我的笔记！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Obsidian 要成为我的笔记软件了！ 真的太强大了！ 我想用一种新的形式去更加有效的记录我的笔记！&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>一位老哥的分享给了我一些启发</title>
    <link href="https://whuichenggong.github.io/2024/12/18/live3/"/>
    <id>https://whuichenggong.github.io/2024/12/18/live3/</id>
    <published>2024-12-18T12:43:19.542Z</published>
    <updated>2024-12-18T12:57:34.101Z</updated>
    
    <content type="html"><![CDATA[<p>学习方法：老哥的思维方式也给了我一些启发</p><p>以下是老哥的分享：</p><p>当知识点量大起来时, 我觉得”写作”的意义应该在于辅助思考</p><p>因为短时间内可能我们能记得很好, 但是对于长时间的庞大知识体系的学习, 就容易忘记一些分支内容 </p><p>所以第一步我做的是把长长的博客尽量拆解为小的讨论主题</p><p>作为”词条”存在</p><p>比如我写了个k8s主题的词条 写道”容器”这个词会自动链接到我之前写过的容器相关的内容  里面的内容是否符合当下我需要的定义  如果是, 那么可以知识复用  如果不是, 那么我需不需要创建新的词条来讨论这个主题<br>然后关联知识形成网络</p><p>比如一个使用mysql + reids搭建的系统, 即用到了mysql, 又用到了redis, 同时它本身还是个系统设计就会难以归类 </p><p>但是 一个文章可以同时带有mysql, redis, 系统设计三种tag  让知识形成网络！</p><p>先把书的标题提取出来 建立一个词条  然后去网上查, 这个东西包含哪些东西 然后去网上查, 这个东西包含哪些东西 等熟悉了基于零散信息的网络后  再去快速浏览权威书籍 迭代网络  </p><hr><p>听了老哥的分享！ 我觉得自己再生活中真的缺乏太多的思考了！什么事知道他困难，不想办法，应该去思考一些东西才能让东西变得更活！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习方法：老哥的思维方式也给了我一些启发&lt;/p&gt;
&lt;p&gt;以下是老哥的分享：&lt;/p&gt;
&lt;p&gt;当知识点量大起来时, 我觉得”写作”的意义应该在于辅助思考&lt;/p&gt;
&lt;p&gt;因为短时间内可能我们能记得很好, 但是对于长时间的庞大知识体系的学习, 就容易忘记一些分支内容 &lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>学习数据库</title>
    <link href="https://whuichenggong.github.io/2024/12/16/Database/"/>
    <id>https://whuichenggong.github.io/2024/12/16/Database/</id>
    <published>2024-12-16T01:12:34.566Z</published>
    <updated>2024-12-20T11:33:22.632Z</updated>
    
    <content type="html"><![CDATA[<hr><p>参考书籍： 数据库设计</p><hr><p>我先从事务入手：</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p><strong>概念</strong> ： 与单个用户或者程序执行，完成读取或者更新数据库内容的一个或一串操作</p><p>应用程序的一次执行就是一个事务或者多个事务</p><p>示例：</p><p>简单事务： 更新x员工的工资（涉及：数据库的读和写，和非数据库操作）</p><p>复杂事务：删除x的员工记录，并把x员工的事务交付给其他人去做。 （过程中若并非所有的操作都被执行，那么数据库的引用完整性将遭到破坏）（数据库也处于不一致状态）</p><p>尽管一致性暂时遭到破坏，但是数据库总是可以从一种一致状态转换到另一种一致的状态</p><h3 id="数据库最终的结果"><a href="#数据库最终的结果" class="headerlink" title="数据库最终的结果"></a>数据库最终的结果</h3><ol><li>COMMIT：执行成功，事务最终被提交 （数据库也达到了一种新的状态）</li><li>ABORTED：事务没有执行成功 （事务被撤销）则数据库必须要还原事务开始之前的一致状态</li><li>已经提交的事务不能被撤销，只能通过（补偿事务）进行覆盖 消除事务产生的影响</li><li>DBMS将在程序正确结束后自动执行COMMIT操作，若不能成功执行则 ROBACK</li><li>PARTIALLY COMITTED：若在最后一条语句被执行时产生了 破坏了可串行化或违反了完整约束 因此事务必须被撤销 或者系统出现故障，事务更新的事务没有被安全的写到二级存储设备上（部分提交） 以上两种情况最终都会进入</li><li>FAILED（失败状态） 事务无法被提交，或者事务处于ACTIVE状态就被撤销 则 处于FAILED状态</li></ol><h3 id="事务性质"><a href="#事务性质" class="headerlink" title="事务性质"></a>事务性质</h3><p>ACID</p><ol><li>原子性：</li><li>一致性：</li><li>隔离性：</li><li>持久性：</li></ol><p>事务的隔离级别<br>事务隔离级别控制了事务之间的可见性和并发行为。常见的隔离级别包括：</p><ul><li>读未提交（Read Uncommitted）：在这个隔离级别下，一个事务可以读取其他事务尚未提交的数据。这可能导致脏读（读取了未提交的数据）、不可重复读（同一查询在事务执行期间返回不同结果）和幻读（事务在同一查询中看到不同的数据行）等问题。读未提交的隔离级别最不严格，可能会引发数据不一致问题</li><li>读已提交（Read Committed）：在这个隔离级别下，一个事务只能读取已经提交的数据，避免了脏读问题。但是，不可重复读和幻读问题仍然可能出现。因为其他事务可能在事务进行期间提交新的数据，导致不同时间点的查询结果不一致。</li><li>可重复读（Repeatable Read）：可重复读隔离级别确保在同一事务内，同一个查询的结果保持一致。这意味着一个事务中的查询不会受到其他事务的修改影响。这可以防止脏读和不可重复读问题，但幻读问题仍然可能出现，因为其他事务可能插入新数据，导致新数据行的出现。</li><li>串行化（Serializable）：串行化是最严格的隔离级别，它确保每个事务都在独立的时间段内执行，防止了并发问题。事务按照顺序一个接一个地执行，这可以解决脏读、不可重复读和幻读问题。然而，串行化可能会对性能产生较大的影响，因为事务需要依次执行。</li></ul><p>事务的隔离级别可以解决脏读、幻读、不可重复读的问题。</p><ol><li>脏读： 脏读指的是在一个事务中读取了另一个事务未提交的数据。假设事务 A 修改了某一行数据，但还没有提交。同时，事务 B 尝试读取了事务 A 修改的数据。如果事务 A 最终回滚了，那么事务 B 读取的数据就是不存在的，这就是脏读。脏读会导致不准确的数据展示，因为<strong>读取的数据可能是临时的未经验证的。</strong>、</li><li>不可重复读：不可重复读是指在同一个事务内，多次读取同一数据时，得到不同的结果。这可能是因为在事务执行期间，其他事务修改了数据。例如，事务 A 在读取某一行数据后，事务 B 修改了这行数据，并提交了。现在事务 A 再次读取相同的数据，注重数据：<strong>发现数据已经不同了</strong>，造成了不一致的现象。</li><li>幻读： 幻读是指在同一个事务内，多次查询同一范围的数据时，得到不同的结果。这与不可重复读类似，但幻读关注的是数据的数量变化。例如，事务 A 在查询某个范围内的所有数据时，事务 B 插入了新数据，并提交了。现在事务 A 再次查询同一范围的数据，注重：<strong>发现数据行的数量增加了</strong>，这就是幻读。</li></ol><hr><p>22.2 并发控制 </p><p>讲解了数据库中的一些问题 幻读等</p><p>[点击这里查看PDF文件] (<a href="https://github.com/Whuichenggong/Knowledge-network/blob/main/docs/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BD%91%E7%BB%9C.pdf">https://github.com/Whuichenggong/Knowledge-network/blob/main/docs/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BD%91%E7%BB%9C.pdf</a>)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;参考书籍： 数据库设计&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我先从事务入手：&lt;/p&gt;
&lt;h2 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; title=&quot;事务&quot;&gt;&lt;/a&gt;事务&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;概念&lt;/strong&gt; ： 与单个</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于我学习的一些资源和方法</title>
    <link href="https://whuichenggong.github.io/2024/12/15/resource/"/>
    <id>https://whuichenggong.github.io/2024/12/15/resource/</id>
    <published>2024-12-15T07:45:03.995Z</published>
    <updated>2024-12-15T07:45:24.392Z</updated>
    
    <content type="html"><![CDATA[<p>兄弟，我理解你的心态，觉得实践的收获更直观，看书反而有点慢。但实际上，看书和实践结合，效果会倍增。下面我不仅推荐优质资源，还会分享高效阅读的方法，帮你更好地平衡学习时间。</p><hr><h3 id="学习资料推荐"><a href="#学习资料推荐" class="headerlink" title="学习资料推荐"></a><strong>学习资料推荐</strong></h3><h4 id="1-数据库相关"><a href="#1-数据库相关" class="headerlink" title="1. 数据库相关"></a><strong>1. 数据库相关</strong></h4><ul><li><strong>书籍</strong>：《高性能 MySQL》<ul><li>重点阅读：索引优化、事务机制、查询优化。</li><li><strong>免费在线教程</strong>：<ul><li><a href="https://www.w3schools.com/sql/">SQL 教程（w3schools）</a></li><li><a href="https://dev.mysql.com/doc/">MySQL 官方文档</a></li></ul></li></ul></li></ul><h4 id="2-计算机网络"><a href="#2-计算机网络" class="headerlink" title="2. 计算机网络"></a><strong>2. 计算机网络</strong></h4><ul><li><strong>书籍</strong>：《计算机网络：自顶向下方法》或《图解HTTP》<ul><li>重点章节：HTTP、TCP&#x2F;IP、DNS、HTTPS。</li><li><strong>免费资源</strong>：<ul><li><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1030595307488672">HTTP 协议详解</a></li><li><a href="https://www.wireshark.org/">Wireshark 网络分析教程</a></li></ul></li></ul></li></ul><h4 id="3-操作系统"><a href="#3-操作系统" class="headerlink" title="3. 操作系统"></a><strong>3. 操作系统</strong></h4><ul><li><strong>书籍</strong>：《现代操作系统》<ul><li>重点章节：进程、线程、同步、内存管理。</li><li><strong>免费资源</strong>：<ul><li><a href="https://pages.cs.wisc.edu/~remzi/OSTEP/">Operating Systems: Three Easy Pieces</a></li><li><a href="https://www.linuxfoundation.org/">Linux 操作系统入门</a></li></ul></li></ul></li></ul><h4 id="4-系统设计"><a href="#4-系统设计" class="headerlink" title="4. 系统设计"></a><strong>4. 系统设计</strong></h4><ul><li><strong>书籍</strong>：《系统设计入门》（Grokking the System Design Interview）<ul><li>重点学习：缓存、负载均衡、限流。</li><li><strong>博客</strong>：<ul><li><a href="https://www.educative.io/courses/grokking-the-system-design-interview">系统设计基础</a></li></ul></li></ul></li></ul><h4 id="5-Redis"><a href="#5-Redis" class="headerlink" title="5. Redis"></a><strong>5. Redis</strong></h4><ul><li><strong>书籍</strong>：《Redis 实战》<ul><li>重点章节：缓存机制、分布式锁。</li><li><strong>免费资源</strong>：<ul><li><a href="https://redis.io/docs/">Redis 官方文档</a></li></ul></li></ul></li></ul><h4 id="6-算法与数据结构"><a href="#6-算法与数据结构" class="headerlink" title="6. 算法与数据结构"></a><strong>6. 算法与数据结构</strong></h4><ul><li><strong>书籍</strong>：《算法（第4版）》或《编程珠玑》<ul><li>重点章节：常用数据结构（栈、队列、二叉树）、动态规划。</li><li><strong>网站</strong>：<ul><li><a href="https://leetcode.com/">LeetCode 官方</a></li><li><a href="https://visualgo.net/">VisuAlgo（算法可视化）</a></li></ul></li></ul></li></ul><hr><h3 id="高效看书方法"><a href="#高效看书方法" class="headerlink" title="高效看书方法"></a><strong>高效看书方法</strong></h3><h4 id="1-目的导向阅读"><a href="#1-目的导向阅读" class="headerlink" title="1. 目的导向阅读"></a><strong>1. 目的导向阅读</strong></h4><ul><li><strong>明确目标</strong>：每次看书前，明确你要解决的问题。比如：<ul><li>“我需要理解事务是怎么实现的” → 阅读事务相关章节，跳过其他部分。</li><li>“我需要掌握 TCP 的连接过程” → 只看 TCP 的工作原理。</li></ul></li></ul><h4 id="2-略读和精读结合"><a href="#2-略读和精读结合" class="headerlink" title="2. 略读和精读结合"></a><strong>2. 略读和精读结合</strong></h4><ul><li><strong>略读</strong>：先快速翻阅目录和每章的开头，总结书的主要内容。</li><li><strong>精读</strong>：挑选与项目或刷题直接相关的部分深入看，配合做笔记和练习。</li></ul><h4 id="3-配合实践"><a href="#3-配合实践" class="headerlink" title="3. 配合实践"></a><strong>3. 配合实践</strong></h4><ul><li><strong>边学边做</strong>：看完书中某个知识点，立即在项目或代码中实现。<ul><li>例子：学完 Redis 的分布式锁，马上在银行项目中添加。</li></ul></li><li><strong>用书作为工具</strong>：书可以成为你的“随手参考”，遇到不懂的概念再翻阅相关章节，而不必一次性啃完。</li></ul><h4 id="4-输出内容"><a href="#4-输出内容" class="headerlink" title="4. 输出内容"></a><strong>4. 输出内容</strong></h4><ul><li><strong>写笔记</strong>：总结书中学到的知识，用自己的语言重新描述。</li><li><strong>录制分享</strong>：试着用 3 分钟向别人讲解你刚学的内容，加深记忆。</li></ul><h4 id="5-番茄工作法"><a href="#5-番茄工作法" class="headerlink" title="5. 番茄工作法"></a><strong>5. 番茄工作法</strong></h4><ul><li>每次阅读 25 分钟后，花 5 分钟总结这段时间的收获，然后休息片刻。效率会提升很多。</li></ul><hr><h3 id="实践与看书的时间分配"><a href="#实践与看书的时间分配" class="headerlink" title="实践与看书的时间分配"></a><strong>实践与看书的时间分配</strong></h3><ol><li><strong>每天早上&#x2F;晚上固定 1 小时阅读</strong>。<ul><li>比如：早上看《高性能 MySQL》，晚上看《计算机网络》。</li></ul></li><li><strong>实践时遇到问题，马上查书解决</strong>。<ul><li>例子：如果 Redis 配置缓存遇到问题，就查《Redis 实战》。</li></ul></li><li><strong>每周末专门安排 2 小时总结书中知识点，结合项目整理成笔记</strong>。</li></ol><hr><p>这样安排既能保持实践的节奏，又能让你从书中挖掘深层的原理。如果还有具体内容不理解，可以随时问我，我也可以帮你分解章节内容！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;兄弟，我理解你的心态，觉得实践的收获更直观，看书反而有点慢。但实际上，看书和实践结合，效果会倍增。下面我不仅推荐优质资源，还会分享高效阅读的方法，帮你更好地平衡学习时间。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;学习资料推荐&quot;&gt;&lt;a href=&quot;#学习资料推荐&quot; class=&quot;h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>聊聊最近</title>
    <link href="https://whuichenggong.github.io/2024/12/12/current/"/>
    <id>https://whuichenggong.github.io/2024/12/12/current/</id>
    <published>2024-12-12T12:57:12.010Z</published>
    <updated>2024-12-23T13:14:15.914Z</updated>
    
    <content type="html"><![CDATA[<p>最近的日子在想着达到就业的水平，不断地提升额，嗯然后今天手机掉水里了，烘干24小时，看看能不能复活吧，突然觉得之前手机不是那么重要，回想起它占用<br>我的时间，好像都不是什么重要的事情，近期来，感觉是为了让自己舒服一点，白天学完，晚上回去就刷手机而且就是 12点 1点，恶性循环，本想着晚上回去看会<br>书，自己却暗示自己，学一天了，玩吧哈哈哈。好像都没做，但是确实没有那么重要，吃饭可以让同学帮我付，哈哈，还是得学习呢，反省一下，是不是你想要的太多了<br>而导致你很累，那种精神上的压迫自己，反思~</p><p>今天12.12日试着实现将单片机的数据传输到数据库中交互<br>先简单的使用按钮的高低电平0 1 实现交互试试看</p><p>后端服务代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/jackc/pgx/v4&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ButtonPress <span class="keyword">struct</span> &#123;</span><br><span class="line">DeviceID  <span class="type">string</span> <span class="string">`json:&quot;device_id&quot;`</span></span><br><span class="line">Button    <span class="type">int</span>    <span class="string">`json:&quot;button&quot;`</span></span><br><span class="line">Timestamp <span class="type">string</span> <span class="string">`json:&quot;timestamp&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">dbHost     = <span class="string">&quot;localhost&quot;</span></span><br><span class="line">dbPort     = <span class="number">5432</span></span><br><span class="line">dbUser     = <span class="string">&quot;root&quot;</span></span><br><span class="line">dbPassword = <span class="string">&quot;secret&quot;</span></span><br><span class="line">dbName     = <span class="string">&quot;data&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Set up the database connection</span></span><br><span class="line">connStr := fmt.Sprintf(<span class="string">&quot;postgresql://%s:%s@%s:%d/%s&quot;</span>, dbUser, dbPassword, dbHost, dbPort, dbName)</span><br><span class="line">conn, err := pgx.Connect(context.Background(), connStr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;Unable to connect to the database: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close(context.Background())</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set up the HTTP server</span></span><br><span class="line">http.HandleFunc(<span class="string">&quot;/receive&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r.Method != http.MethodPost &#123;</span><br><span class="line">http.Error(w, <span class="string">&quot;Only POST requests are supported&quot;</span>, http.StatusMethodNotAllowed)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data ButtonPress</span><br><span class="line"><span class="keyword">if</span> err := json.NewDecoder(r.Body).Decode(&amp;data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">http.Error(w, <span class="string">&quot;Invalid JSON format&quot;</span>, http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">&quot;Received data: %+v&quot;</span>, data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> data.Button == <span class="number">1</span> &#123;</span><br><span class="line"><span class="comment">// Store the data in the database</span></span><br><span class="line">query := <span class="string">&quot;INSERT INTO button_presses (device_id, button, timestamp) VALUES ($1, $2, $3)&quot;</span></span><br><span class="line">_, err := conn.Exec(context.Background(), query, data.DeviceID, data.Button, data.Timestamp)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">http.Error(w, <span class="string">&quot;Failed to store data in the database&quot;</span>, http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">log.Println(<span class="string">&quot;Data successfully stored in the database&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">w.WriteHeader(http.StatusOK)</span><br><span class="line">w.Write([]<span class="type">byte</span>(<span class="string">&quot;Data received and processed&quot;</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">log.Println(<span class="string">&quot;Starting server on 192.168.111.1:8080&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err := http.ListenAndServe(<span class="string">&quot;192.168.111.1:8080&quot;</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;Server failed: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是简单的实现</p><p>单片机端代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266HTTPClient.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* ssid = <span class="string">&quot;Your_SSID&quot;</span>;          <span class="comment">// Wi-Fi 名称</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* password = <span class="string">&quot;Your_PASSWORD&quot;</span>;  <span class="comment">// Wi-Fi 密码</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* serverUrl = <span class="string">&quot;http://8.222.186.212:8080/send&quot;</span>;  <span class="comment">// 后端服务器地址</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">115200</span>); <span class="comment">// 初始化串口</span></span><br><span class="line">  WiFi.begin(ssid, password);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 连接到 Wi-Fi</span></span><br><span class="line">  Serial.print(<span class="string">&quot;Connecting to Wi-Fi&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> (WiFi.status() != WL_CONNECTED) &#123;</span><br><span class="line">    delay(<span class="number">1000</span>);</span><br><span class="line">    Serial.print(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Serial.println(<span class="string">&quot;\nConnected to Wi-Fi&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (WiFi.status() == WL_CONNECTED) &#123;</span><br><span class="line">    HTTPClient http;</span><br><span class="line">    http.begin(serverUrl);   <span class="comment">// 设置服务器 URL</span></span><br><span class="line">    http.addHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>); <span class="comment">// 设置请求头</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例 JSON 数据</span></span><br><span class="line">    String jsonData = <span class="string">&quot;&#123;\&quot;sensor\&quot;: \&quot;temperature\&quot;, \&quot;value\&quot;: 25.5&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// POST 请求</span></span><br><span class="line">    <span class="type">int</span> httpResponseCode = http.POST(jsonData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查响应状态</span></span><br><span class="line">    <span class="keyword">if</span> (httpResponseCode &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      String response = http.getString();</span><br><span class="line">      Serial.println(<span class="string">&quot;Response: &quot;</span> + response);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Serial.println(<span class="string">&quot;Error on sending POST: &quot;</span> + String(httpResponseCode));</span><br><span class="line">    &#125;</span><br><span class="line">    http.end(); <span class="comment">// 关闭连接</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.println(<span class="string">&quot;Wi-Fi not connected&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  delay(<span class="number">5000</span>); <span class="comment">// 每 5 秒发送一次数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>HTTP就是那么的神奇</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近的日子在想着达到就业的水平，不断地提升额，嗯然后今天手机掉水里了，烘干24小时，看看能不能复活吧，突然觉得之前手机不是那么重要，回想起它占用&lt;br&gt;我的时间，好像都不是什么重要的事情，近期来，感觉是为了让自己舒服一点，白天学完，晚上回去就刷手机而且就是 12点 1点，恶</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>分布式系统学习</title>
    <link href="https://whuichenggong.github.io/2024/12/09/Distributed/"/>
    <id>https://whuichenggong.github.io/2024/12/09/Distributed/</id>
    <published>2024-12-09T12:53:55.062Z</published>
    <updated>2024-12-09T13:14:34.908Z</updated>
    
    <content type="html"><![CDATA[<p><code>go build -buildmode=plugin ../mrapps/wc.go</code><br>这个指令是什么意思 :</p><p>这个命令的作用是编译 ..&#x2F;mrapps&#x2F;wc.go 文件，并将其生成一个 Go 插件文件。生成的插件文件通常是一个 .so（共享库文件）文件，它可以在运行时被其他 Go 程序通过 plugin 包加载和调用。</p><p>例如：</p><p>你可以在主程序中使用 plugin 包动态加载 wc.so 插件，并调用插件中的函数。</p><p><code>go run mrsequential.go wc.so pg*.txt：</code></p><p>go run：用于编译并运行 Go 程序。它会在内存中临时编译指定的 Go 文件，并立即执行。</p><p>mrsequential.go：这是要执行的 Go 源文件，Go 编译器会先编译这个文件并运行它。这个文件应该包含 main 函数，通常是程序的入口点。</p><p>wc.so：这是一个 Go 插件文件（共享库）。它通常是通过 go build -buildmode&#x3D;plugin 命令生成的。该文件包含 Go 代码，可能定义了一个插件接口，在运行时可以被主程序（mrsequential.go）动态加载和调用。wc.so 可能提供某些功能，mrsequential.go 将加载并使用这些功能。</p><p>pg*.txt：这是一个通配符表达式，表示所有以 pg 开头，后面跟任意字符，且以 .txt 结尾的文件。例如，pg1.txt, pg42.txt, pgfile.txt 都会被匹配并作为参数传递给程序。</p><p><code>more mr-out-0</code> 将会输出很多文本 这是因为：</p><p>mrsequential.go 将其输出保留在文件 mr-out-0 中。输入来自名为 pg-xxx.txt 的文本文件</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;go build -buildmode=plugin ../mrapps/wc.go&lt;/code&gt;&lt;br&gt;这个指令是什么意思 :&lt;/p&gt;
&lt;p&gt;这个命令的作用是编译 ..&amp;#x2F;mrapps&amp;#x2F;wc.go 文件，并将其生成一个 Go 插件文件。生成的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数据库学习</title>
    <link href="https://whuichenggong.github.io/2024/12/08/postgres/"/>
    <id>https://whuichenggong.github.io/2024/12/08/postgres/</id>
    <published>2024-12-08T10:47:54.793Z</published>
    <updated>2024-12-08T10:52:44.696Z</updated>
    
    <content type="html"><![CDATA[<p>学习文档：</p><p><a href="https://www.rockdata.net/zh-cn/tutorial/toc/">https://www.rockdata.net/zh-cn/tutorial/toc/</a></p><p>WHERE 语句如何使用</p><p><a href="https://www.rockdata.net/zh-cn/tutorial/dml-where/%E3%80%81">https://www.rockdata.net/zh-cn/tutorial/dml-where/、</a></p><p>总结来说： 放入condition，返回结果只会返回符合condition条件的， 搭配 AND OR IN LIKE等使用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.rockdata.net/zh-cn/tutorial/toc/&quot;&gt;https://www.rockdata.net/zh-cn/tutorial/toc/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;WHERE 语句如何使用&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>为什么别人写项目知道用什么？</title>
    <link href="https://whuichenggong.github.io/2024/12/07/confusion/"/>
    <id>https://whuichenggong.github.io/2024/12/07/confusion/</id>
    <published>2024-12-07T09:19:23.441Z</published>
    <updated>2024-12-07T09:20:17.605Z</updated>
    
    <content type="html"><![CDATA[<p>同样来自GPT的回答：</p><p>你的疑惑非常好！许多人在学习编程时都会有类似的感受，尤其是在学习阶段，看到博主轻松选择某些包或者工具来解决问题时，会觉得他们似乎“无所不知”。事实上，这背后是<strong>经验</strong>和<strong>积累</strong>的结果。以下几点可以帮助你理解和逐步建立这种能力：</p><hr><h3 id="1-经验的积累"><a href="#1-经验的积累" class="headerlink" title="1. 经验的积累"></a><strong>1. 经验的积累</strong></h3><ul><li><strong>博主的背景</strong>：他们可能已经解决过类似问题，因此知道哪些包是高效的选择。这是经验的体现。</li><li><strong>类比</strong>：就像一位厨师在做菜时，很容易知道用什么调料，而新手可能需要查配方。</li></ul><h4 id="你可以这样做："><a href="#你可以这样做：" class="headerlink" title="你可以这样做："></a><strong>你可以这样做：</strong></h4><ul><li><strong>多看、多学</strong>：通过模仿优秀项目和学习文档，积累对常用库和框架的了解。</li><li><strong>练习总结</strong>：每次解决问题后，记录用到的包和方法，慢慢形成自己的“工具箱”。</li></ul><hr><h3 id="2-文档与生态"><a href="#2-文档与生态" class="headerlink" title="2. 文档与生态"></a><strong>2. 文档与生态</strong></h3><ul><li><p><strong>语言和框架的生态</strong>：每种语言或框架都有一些社区公认的、<strong>常用的库</strong>。</p><ul><li>比如，Go 语言处理配置时，大家常用 <code>viper</code> 或 <code>yaml</code>。</li><li>HTTP 请求：<code>net/http</code>（原生）或社区的 <code>gin</code>（框架）。</li></ul></li><li><p><strong>社区推荐</strong>：很多库被推荐使用，是因为它们：</p><ol><li><strong>功能齐全</strong>。</li><li><strong>易于使用</strong>。</li><li><strong>社区活跃</strong>，有长期维护。</li></ol></li></ul><h4 id="你可以这样做：-1"><a href="#你可以这样做：-1" class="headerlink" title="你可以这样做："></a><strong>你可以这样做：</strong></h4><ul><li><strong>了解生态</strong>：多逛 GitHub、Go 的标准库文档以及社区资源（比如 Go 的官方博客）。</li><li><strong>参考优秀代码</strong>：通过学习开源项目，你可以快速了解哪些包解决了哪些问题。</li></ul><hr><h3 id="3-搜索能力"><a href="#3-搜索能力" class="headerlink" title="3. 搜索能力"></a><strong>3. 搜索能力</strong></h3><ul><li><p>很多开发者的知识并不是“记住的”，而是“查到的”。他们遇到问题时，会：</p><ol><li><strong>搜索问题</strong>：查找类似场景的解决方案。</li><li><strong>评估方案</strong>：根据实际需求选择合适的库或框架。</li></ol></li><li><p>搜索时的技巧：</p><ul><li>用精准关键词，比如“Go JWT authentication package”。</li><li>看社区推荐，比如 Stack Overflow、Reddit、GitHub 等。</li></ul></li></ul><h4 id="你可以这样做：-2"><a href="#你可以这样做：-2" class="headerlink" title="你可以这样做："></a><strong>你可以这样做：</strong></h4><ul><li>当不知道用哪个包时，搜索类似场景的关键词，看看其他开发者用了什么库。</li><li>慢慢熟悉常用的社区推荐来源，比如：<ul><li><a href="https://awesome-go.com/">Awesome Go</a>：列出了 Go 的优秀库。</li><li><a href="https://pkg.go.dev/">Go Packages</a>：Go 的官方包文档和搜索平台。</li></ul></li></ul><hr><h3 id="4-理解需求，选择工具"><a href="#4-理解需求，选择工具" class="headerlink" title="4. 理解需求，选择工具"></a><strong>4. 理解需求，选择工具</strong></h3><ul><li>博主并不是“盲选”包，而是基于需求选工具。<ul><li>例如：需要读取配置文件，就会选择支持多种格式的 <code>viper</code>。</li><li>需要快速搭建 Web 服务框架，就会用 <code>gin</code> 或 <code>echo</code>。</li></ul></li></ul><h4 id="你可以这样做：-3"><a href="#你可以这样做：-3" class="headerlink" title="你可以这样做："></a><strong>你可以这样做：</strong></h4><ul><li>学会分析问题：问自己——“这个问题需要解决什么？”“有没有原生支持？”</li><li>学会看库文档：<ul><li>比如，在 GitHub 项目中，看 ReadMe 和示例代码，理解库的功能。</li></ul></li></ul><hr><h3 id="5-你的问题如何转换为实践"><a href="#5-你的问题如何转换为实践" class="headerlink" title="5. 你的问题如何转换为实践"></a><strong>5. 你的问题如何转换为实践</strong></h3><ol><li><strong>明确目标</strong>：先理解你要解决的问题，比如“实现一个 JWT 登录功能”。</li><li><strong>学习思路</strong>：看看博主怎么解决的，模仿过程并分析他们选择的工具是否合理。</li><li><strong>尝试自己实现</strong>：不要依赖博主的方案，尝试用其他库或者原生代码实现。</li></ol><hr><h3 id="总结：知识的形成是一个积累过程"><a href="#总结：知识的形成是一个积累过程" class="headerlink" title="总结：知识的形成是一个积累过程"></a><strong>总结：知识的形成是一个积累过程</strong></h3><p>博主看似“知道一切”，实际上是基于：</p><ol><li><strong>经验积累</strong>：长期的项目经验让他们知道常用包。</li><li><strong>良好工具链</strong>：对语言生态了解，知道优秀的社区推荐。</li><li><strong>高效搜索</strong>：遇到新问题时，他们可以快速找到解决方案。</li></ol><p><strong>行动建议</strong>：</p><ul><li>多积累项目经验，模仿优秀代码，逐渐形成自己的“工具箱”。</li><li>学会分解问题和尝试不同工具，在实践中找到更适合的解决方案。<br>坚持下去，你也会越来越“有经验”！ 😊</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;同样来自GPT的回答：&lt;/p&gt;
&lt;p&gt;你的疑惑非常好！许多人在学习编程时都会有类似的感受，尤其是在学习阶段，看到博主轻松选择某些包或者工具来解决问题时，会觉得他们似乎“无所不知”。事实上，这背后是&lt;strong&gt;经验&lt;/strong&gt;和&lt;strong&gt;积累&lt;/strong&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>理解鉴权，权限等名词的区别</title>
    <link href="https://whuichenggong.github.io/2024/12/07/authority/"/>
    <id>https://whuichenggong.github.io/2024/12/07/authority/</id>
    <published>2024-12-07T09:13:14.230Z</published>
    <updated>2024-12-07T09:15:05.767Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GPT很好的给出了答案"><a href="#GPT很好的给出了答案" class="headerlink" title="GPT很好的给出了答案"></a>GPT很好的给出了答案</h2><p>问：</p><p>用户通过了身份验证，但是不具有访问资源所需的权限。 这句话我应该怎么理解，我还有的疑惑是Cookie，Token，鉴权，权限等这几个名词都是什么意思，我现在对他们的理解有点模糊</p><p>答：</p><p>这些概念是 Web 安全和权限管理的核心部分。让我们分两步：<strong>先理解句子的含义</strong>，再深入解析相关概念（Cookie、Token、鉴权、权限等）。</p><hr><h3 id="1-句子的含义"><a href="#1-句子的含义" class="headerlink" title="1. 句子的含义"></a><strong>1. 句子的含义</strong></h3><blockquote><p><strong>“用户通过了身份验证，但是不具有访问资源所需的权限。”</strong></p></blockquote><p>这句话分为两个阶段：</p><ol><li><p><strong>身份验证</strong>（Authentication）：系统确认了用户的身份（比如你用正确的用户名和密码登录）。</p><ul><li><strong>说明</strong>：你确实是你声称的那个人。</li><li><strong>类比</strong>：这就像进入公司时，你刷卡证明你是公司的员工。</li></ul></li><li><p><strong>权限检查</strong>（Authorization）：系统检查用户是否有权访问某些特定资源。</p><ul><li><strong>说明</strong>：通过身份验证并不代表你可以访问所有东西。例如：<ul><li>普通用户可能无法访问管理员界面。</li><li>销售部门员工可能无法查看财务报表。</li></ul></li><li><strong>类比</strong>：在公司内部，即使你刷卡进门，也可能需要额外权限才能进入某些区域（比如机房）。</li></ul></li></ol><p><strong>总结</strong>：身份验证是“你是谁”，权限检查是“你是否被允许做某件事”。通过身份验证 ≠ 获得所有权限。</p><hr><h3 id="2-概念解析"><a href="#2-概念解析" class="headerlink" title="2. 概念解析"></a><strong>2. 概念解析</strong></h3><h4 id="1-Cookie"><a href="#1-Cookie" class="headerlink" title="(1) Cookie"></a><strong>(1) Cookie</strong></h4><ul><li><strong>定义</strong>：一种小型数据，存储在用户浏览器中，由服务器生成，用来记录用户的会话状态或其他信息。</li><li><strong>用途</strong>：<ol><li><strong>会话管理</strong>：比如记录你是否已登录。</li><li><strong>个性化</strong>：比如保存语言设置。</li><li><strong>追踪</strong>：用于广告和分析。</li></ol></li></ul><p><strong>类比</strong>：Cookie 就像一个身份证明牌，浏览器每次请求时带上它，服务器根据这个证明牌识别你的身份。</p><hr><h4 id="2-Token"><a href="#2-Token" class="headerlink" title="(2) Token"></a><strong>(2) Token</strong></h4><ul><li><strong>定义</strong>：类似于数字化的通行证，通常由服务器生成并发放给用户，用户每次请求时带上 Token，证明自己已通过身份验证。</li><li><strong>常见类型</strong>：<ul><li>**JWT (JSON Web Token)**：一种格式化的 Token，常用于现代 Web 应用。</li></ul></li></ul><p><strong>区别于 Cookie</strong>：</p><ul><li>Cookie 是浏览器特有的存储机制，而 Token 是一个通用的凭证。</li><li>Cookie 通常自动附加在请求中，Token 需要开发者手动附加（如放在请求头中）。</li></ul><p><strong>类比</strong>：Token 就像一个“通行证”，你需要用它向服务器证明你有访问权限。</p><hr><h4 id="3-鉴权"><a href="#3-鉴权" class="headerlink" title="(3) 鉴权"></a><strong>(3) 鉴权</strong></h4><ul><li><strong>定义</strong>：确定用户是否具有访问资源或执行操作的权限。</li><li><strong>过程</strong>：<ul><li>用户发起请求时，系统会验证用户提供的凭证（比如 Token 或 Cookie）。</li><li>系统根据用户的角色、组或策略，判断是否允许操作。</li></ul></li></ul><p><strong>类比</strong>：鉴权就像安保检查，你拿着门卡，安保会检查你的权限，决定你是否可以进入某些区域。</p><hr><h4 id="4-权限"><a href="#4-权限" class="headerlink" title="(4) 权限"></a><strong>(4) 权限</strong></h4><ul><li><strong>定义</strong>：指用户被允许执行的操作范围或访问的资源类型。</li><li><strong>示例</strong>：<ul><li>读权限：允许查看文件内容。</li><li>写权限：允许修改文件内容。</li><li>管理权限：允许管理其他用户。</li></ul></li></ul><p><strong>类比</strong>：权限就像不同的钥匙，钥匙决定了你能打开哪些门。</p><hr><h3 id="3-总结关系和区别"><a href="#3-总结关系和区别" class="headerlink" title="3. 总结关系和区别"></a><strong>3. 总结关系和区别</strong></h3><ul><li><strong>Cookie</strong>：存储用户会话信息，让服务器识别用户是谁。</li><li><strong>Token</strong>：携带用户身份信息，用于证明用户已通过身份验证。</li><li><strong>鉴权</strong>：判断用户是否有权访问特定资源。</li><li><strong>权限</strong>：用户可以做的事情或访问的资源范围。</li></ul><hr><h3 id="4-一个完整的例子"><a href="#4-一个完整的例子" class="headerlink" title="4. 一个完整的例子"></a><strong>4. 一个完整的例子</strong></h3><ol><li><p>用户访问网站，输入用户名和密码（<strong>身份验证</strong>）。</p><ul><li>服务器验证用户名和密码正确，生成一个 Token 返回给用户。</li><li>Token 或者对应的 Session ID 会存储在用户的 Cookie 中。</li></ul></li><li><p>用户请求资源时，浏览器自动带上 Cookie（或你自己带上 Token）。</p><ul><li>服务器接收到请求后，验证 Token 或 Cookie 的合法性。</li></ul></li><li><p>服务器检查权限（<strong>鉴权</strong>）。</p><ul><li>如果你有权限，资源返回给你。</li><li>如果你没有权限，服务器返回 “403 Forbidden”。</li></ul></li></ol><p>你可以将这些过程看成一道流水线：<strong>身份验证 -&gt; 带凭证发请求 -&gt; 权限检查 -&gt; 返回结果</strong>。</p><p>就是我是 赵忠鹤 检查 赵忠鹤是不是有权限访问这个内容，大体就是这个意思</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;GPT很好的给出了答案&quot;&gt;&lt;a href=&quot;#GPT很好的给出了答案&quot; class=&quot;headerlink&quot; title=&quot;GPT很好的给出了答案&quot;&gt;&lt;/a&gt;GPT很好的给出了答案&lt;/h2&gt;&lt;p&gt;问：&lt;/p&gt;
&lt;p&gt;用户通过了身份验证，但是不具有访问资源所需的权限</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>json的序列化与反序列化</title>
    <link href="https://whuichenggong.github.io/2024/12/06/serialize/"/>
    <id>https://whuichenggong.github.io/2024/12/06/serialize/</id>
    <published>2024-12-06T09:21:57.665Z</published>
    <updated>2024-12-06T09:52:48.370Z</updated>
    
    <content type="html"><![CDATA[<p>序列化：将 Go 中的结构体、切片、map 等数据结构转换为 JSON 格式的字符串。</p><p>作用：方便数据在网络传输、文件保存等情境中使用。</p><p>反序列化：将 JSON 格式的字符串转换为 Go 的数据结构。</p><p>作用：方便从 JSON 中提取数据并在程序中使用。</p><p>JSON<br>{<br>“”： “”，<br>“”： “”，<br>“”： “”<br>}</p><p>Go中 使用 Marshal Unmarshal 进行序列化和反序列化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">    Age  <span class="type">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := Person&#123;Name: <span class="string">&quot;Alice&quot;</span>, Age: <span class="number">25</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化为 JSON</span></span><br><span class="line">    jsonData, err := json.Marshal(p)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Error:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="type">string</span>(jsonData)) <span class="comment">// 输出: &#123;&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:25&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">    Age  <span class="type">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    jsonData := <span class="string">`&#123;&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:25&#125;`</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> p Person</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化为结构体</span></span><br><span class="line">    err := json.Unmarshal([]<span class="type">byte</span>(jsonData), &amp;p)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Error:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(p.Name, p.Age) <span class="comment">// 输出: Alice 25</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>类比一下进程间管道通信：<br>在父子进程使用管道进行通信时，数据通常以字节流的形式传输。<br>要传递复杂数据结构，需要将数据转换为字节流（序列化），并在另一端解析回来（反序列化）。</p><p>GO中实现 字符进程通信</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">    Content <span class="type">string</span> <span class="string">`json:&quot;content&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r, w, err := os.Pipe() <span class="comment">// 创建管道</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Error creating pipe:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> os.Getenv(<span class="string">&quot;IS_CHILD&quot;</span>) == <span class="string">&quot;1&quot;</span> &#123;</span><br><span class="line">        <span class="comment">// 子进程逻辑</span></span><br><span class="line">        r.Close() <span class="comment">// 关闭写端</span></span><br><span class="line">        <span class="keyword">var</span> msg Message</span><br><span class="line">        decoder := json.NewDecoder(r)</span><br><span class="line">        <span class="keyword">if</span> err := decoder.Decode(&amp;msg); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;Error decoding:&quot;</span>, err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Child received:&quot;</span>, msg.Content)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程逻辑</span></span><br><span class="line">        w.Close() <span class="comment">// 关闭读端</span></span><br><span class="line">        cmd := os.Exec(os.Args[<span class="number">0</span>], os.Args, os.Environ())</span><br><span class="line">        cmd.Env = <span class="built_in">append</span>(os.Environ(), <span class="string">&quot;IS_CHILD=1&quot;</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            encoder := json.NewEncoder(w)</span><br><span class="line">            encoder.Encode(Message&#123;Content: <span class="string">&quot;Hello, Child!&quot;</span>&#125;)</span><br><span class="line">        &#125;()</span><br><span class="line">        cmd.Wait()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;序列化：将 Go 中的结构体、切片、map 等数据结构转换为 JSON 格式的字符串。&lt;/p&gt;
&lt;p&gt;作用：方便数据在网络传输、文件保存等情境中使用。&lt;/p&gt;
&lt;p&gt;反序列化：将 JSON 格式的字符串转换为 Go 的数据结构。&lt;/p&gt;
&lt;p&gt;作用：方便从 JSON 中提取</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Go语法学习</title>
    <link href="https://whuichenggong.github.io/2024/12/02/Go_Program/"/>
    <id>https://whuichenggong.github.io/2024/12/02/Go_Program/</id>
    <published>2024-12-02T06:10:19.416Z</published>
    <updated>2024-12-16T02:39:31.613Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">whatAmI := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> t := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;I&#x27;m a bool&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;I&#x27;m an int&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Don&#x27;t know type %T\n&quot;</span>, t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">whatAmI(<span class="literal">true</span>)</span><br><span class="line">whatAmI(<span class="number">1</span>)</span><br><span class="line">whatAmI(<span class="string">&quot;hey&quot;</span>)</span><br></pre></td></tr></table></figure><p>这是一个函数whatAmI，它接受一个interface{}类型的参数。interface{}是 Go 语言中的一种空接口，可以存储任何类型的值。<br>这个switch语句实际上是一个类型switch，它检查接口变量i的具体类型，而不是它的值。根据i的类型，switch将执行不同的case分支。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If you specify the index with `:`, the elements in</span></span><br><span class="line"><span class="comment">// between will be zeroed.</span></span><br><span class="line">b = [...]<span class="type">int</span>&#123;<span class="number">100</span>, <span class="number">3</span>: <span class="number">400</span>, <span class="number">500</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;idx:&quot;</span>, b)</span><br></pre></td></tr></table></figure><p>3: 400 指定了下标为 3 的位置的值是 400。<br>这意味着索引 1 和 2 的值将被初始化为 0（因为:操作符指定了一个新的下标，并初始化之前未指定的下标对应的元素为 0）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="type">string</span></span><br><span class="line">fmt.Println(<span class="string">&quot;uninit:&quot;</span>, s, s == <span class="literal">nil</span>, <span class="built_in">len</span>(s) == <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>uninit: [] true true</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">twoD := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">innerLen := i + <span class="number">1</span></span><br><span class="line">twoD[i] = <span class="built_in">make</span>([]<span class="type">int</span>, innerLen)</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; innerLen; j++ &#123;</span><br><span class="line">twoD[i][j] = i + j</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;2d: &quot;</span>, twoD)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2d:  [[0] [1 2] [2 3 4]]</p><p>12.3日</p><p>map操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   m[<span class="string">&quot;k1&quot;</span>] = <span class="number">7</span></span><br><span class="line">m[<span class="string">&quot;k2&quot;</span>] = <span class="number">13</span></span><br><span class="line">fmt.Println(<span class="string">&quot;map:&quot;</span>, m)</span><br><span class="line">fmt.Println(<span class="string">&quot;len:&quot;</span>, <span class="built_in">len</span>(m))</span><br><span class="line"><span class="comment">//clear(m)</span></span><br><span class="line">val, prs := m[<span class="string">&quot;k2&quot;</span>] <span class="comment">//k2的值， 一个是判断k2是否存在于m中的bool值</span></span><br><span class="line">fmt.Println(<span class="string">&quot;val：&quot;</span>, val, <span class="string">&quot;prs:&quot;</span>, prs)</span><br><span class="line">n := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;foo&quot;</span>: <span class="number">1</span>, <span class="string">&quot;bar&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;&quot;</span>, n)</span><br><span class="line"><span class="keyword">if</span> maps.Equal(n, n2) &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;n == n2&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用变长参数函数（variadic function），即可以接收任意数量参数的函数。<br>这里的 … 标记表示 nums 参数是可变长的，可以接收零个或多个 int 类型的参数</p><p>nums 被当作切片使用，可以进行切片相关的操作，例如使用 len(nums) 获取长度，或者用 range 遍历切片元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(nums ...<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Print(nums, <span class="string">&quot; &quot;</span>)</span><br><span class="line">total := <span class="number">0</span></span><br><span class="line"><span class="comment">// Within the function, the type of `nums` is</span></span><br><span class="line"><span class="comment">// equivalent to `[]int`. We can call `len(nums)`,</span></span><br><span class="line"><span class="comment">// iterate over it with `range`, etc.</span></span><br><span class="line"><span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">total += num</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(total)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Variadic functions can be called in the usual way</span></span><br><span class="line"><span class="comment">// with individual arguments.</span></span><br><span class="line">sum(<span class="number">1</span>)</span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// If you already have multiple args in a slice,</span></span><br><span class="line"><span class="comment">// apply them to a variadic function using</span></span><br><span class="line"><span class="comment">// `func(slice...)` like this.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种调用nums的方法使用 nums 切片，通过 sum(nums...) 的方式将切片中的每个元素作为单独的参数传递给 sum 函数。</span></span><br><span class="line">nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">sum(nums...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误示范</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allArticles</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">articles := Articles&#123;</span><br><span class="line">Title:   <span class="string">&quot;Test Title&quot;</span>,</span><br><span class="line">Desc:    <span class="string">&quot;Test Descrption&quot;</span>,</span><br><span class="line">Content: <span class="string">&quot;hello world&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;endpoint hit: allArticles&quot;</span>)</span><br><span class="line">json.NewEncoder(w).Encode(articles)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里的问题是 Articles 类型实际上是一个切片（[]Article），而你试图将一个单独的 Article 结构体实例赋值给 articles 变量。根据 Go 语言的语法，Articles 类型需要的是一个 Article 类型的切片。</p><p>要解决这个问题，你需要将 Article 实例放入一个切片中。可以将你的代码修改为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">articles := Articles&#123;</span><br><span class="line">&#123;</span><br><span class="line">Title:   <span class="string">&quot;Test Title&quot;</span>,</span><br><span class="line">Desc:    <span class="string">&quot;Test Descrption&quot;</span>,</span><br><span class="line">Content: <span class="string">&quot;hello world&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">CopyInsert</span><br><span class="line">这里的修改是把 Article 结构体实例用 &#123;&#125; 包围起来，表示这是一个切片中的一个元素。</span><br><span class="line"></span><br><span class="line">最终的 allArticles 函数应如下所示：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二种方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Article的实例</span></span><br><span class="line">    newArticle := Article&#123;</span><br><span class="line">        Title:   <span class="string">&quot;Test Title&quot;</span>,</span><br><span class="line">        Desc:    <span class="string">&quot;Test Description&quot;</span>,</span><br><span class="line">        Content: <span class="string">&quot;hello world&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建Articles切片并添加上面的实例</span></span><br><span class="line">    articles := Articles&#123;newArticle&#125;</span><br></pre></td></tr></table></figure><hr><p>go fmt </p><p>包的导入者将使用名称来引用其内容，因此包中的导出名称可以使用该事实来避免重复。 （不要使用 import . 表示法，它可以简化必须在正在测试的包外部运行的测试，但应该避免。）<br>例如，bufio 包中的缓冲读取器类型称为 Reader，而不是 BufReader，因为用户将其视为 bufio.Reader，这是一个清晰、简洁的名称。此外，由于导入的实体始终使用其包名称进行寻址，<br>因此 bufio.Reader 不会与 io.Reader 冲突。类似地，<br>创建ring.Ring新实例的函数（Go中构造函数的定义）通常被称为NewRing，但由于Ring是包导出的唯一类型，并且由于包被称为ring，所以它是称为“New”，包的客户端将其视为“ring.New”。使用包结构来帮助您选择好的名称。</p><p>另一个简短的例子是once.Do; Once.Do(setup) 读起来很好，<br>并且不会通过编写 Once.DoOrWaitUntilDone(setup) 来改进。长名称不会自动使内容更具可读性。有用的文档注释通常比超长的名称更有价值。</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intSeq</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    i := <span class="number">0</span> <span class="comment">// i 是一个局部变量，用于 intSeq 函数。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="comment">// 返回一个匿名函数，这个函数可以访问 intSeq 函数的局部变量 i。</span></span><br><span class="line">        i++    <span class="comment">// 每次调用这个匿名函数时，i 的值都会增加。</span></span><br><span class="line">        <span class="keyword">return</span> i <span class="comment">// 返回增加后的 i 的值。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回结果 ：<br>1<br>2<br>3<br>1</p><p>这是因为闭包允许匿名函数捕获并记住 i 变量的状态。<br>这就是闭包的 “魔力” 所在，即使外部函数已经返回，内部函数仍然能够访问和修改外部函数的变量。</p><p>stack :&#x3D; []rune{} 与 make :&#x3D; []string{} 的区别：<br>stack :&#x3D; []rune{}：这段代码创建了一个 rune 类型的切片（空切片）。rune 是 Go 中专门用来表示单个字符的类型，适用于你处理字符（尤其是 Unicode 字符）时，能够确保每个元素是一个完整的 Unicode 字符。</p><p>make :&#x3D; []string{}：这段代码创建了一个 string 类型的切片。每个元素是一个字符串，字符串通常用于表示一系列字符构成的文本数据。</p><hr><p>在 Go 程序中，通过 <code>os.Args</code> 可以访问命令行参数，而 <code>go run main.go file1.txt file2.txt</code> 的执行过程如下：</p><hr><p>为什么·go语言 &gt; go run main.go file1.txt file2.txt 在这里执行之后可以读取到文件1 2</p><h3 id="1-命令行参数的解析"><a href="#1-命令行参数的解析" class="headerlink" title="1. 命令行参数的解析"></a><strong>1. 命令行参数的解析</strong></h3><ul><li><p><strong>命令：</strong> <code>go run main.go file1.txt file2.txt</code></p><ul><li><code>go run</code> 会编译并执行 <code>main.go</code>。</li><li>命令行中，<code>main.go</code> 后面的 <code>file1.txt</code> 和 <code>file2.txt</code> 被传递给程序作为命令行参数。</li></ul></li><li><p>在程序中，<code>os.Args</code> 是一个字符串切片（<code>[]string</code>），包含了命令行中的参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">os.Args[<span class="number">0</span>] <span class="comment">// 包含程序的名字，如 &quot;main.go&quot;</span></span><br><span class="line">os.Args[<span class="number">1</span>] <span class="comment">// 第一个参数 &quot;file1.txt&quot;</span></span><br><span class="line">os.Args[<span class="number">2</span>] <span class="comment">// 第二个参数 &quot;file2.txt&quot;</span></span><br></pre></td></tr></table></figure><p><strong>例子：</strong><br>假如命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run main.go file1.txt file2.txt</span><br></pre></td></tr></table></figure><p>则：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(os.Args) </span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[main file1.txt file2.txt]</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="2-打开文件进行读取"><a href="#2-打开文件进行读取" class="headerlink" title="2. 打开文件进行读取"></a><strong>2. 打开文件进行读取</strong></h3><p>你的代码解析命令行参数后，会尝试打开这些文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">files := os.Args[<span class="number">1</span>:] <span class="comment">// 获取命令行参数列表（除程序本身外的部分）</span></span><br></pre></td></tr></table></figure><ul><li><code>files</code> 现在是一个切片：<code>[&quot;file1.txt&quot;, &quot;file2.txt&quot;]</code>。</li></ul><p>然后通过循环处理每个文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, arg := <span class="keyword">range</span> files &#123;</span><br><span class="line">    f, err := os.Open(arg) <span class="comment">// 打开文件</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Fprintf(os.Stderr, <span class="string">&quot;dup2: %v\n&quot;</span>, err) <span class="comment">// 错误处理</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> f.Close() <span class="comment">// 确保文件被正确关闭</span></span><br><span class="line">    countLines(f, counts)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中：</p><ol><li><p>**<code>os.Open(arg)</code>**：</p><ul><li>打开文件（如 <code>file1.txt</code>），返回一个文件指针 <code>*os.File</code>。</li><li>如果文件打开失败（文件不存在或权限问题），返回错误并跳过。</li></ul></li><li><p>**<code>countLines(f, counts)</code>**：</p><ul><li>将文件指针传递给 <code>countLines</code>，扫描文件的内容并统计每行的出现次数。</li></ul></li></ol><hr><h3 id="3-执行结果的输出"><a href="#3-执行结果的输出" class="headerlink" title="3. 执行结果的输出"></a><strong>3. 执行结果的输出</strong></h3><p>统计完成后，程序会输出所有出现次数大于 1 的行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> line, n := <span class="keyword">range</span> counts &#123;</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">1</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d\t%s\n&quot;</span>, n, line)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这会将文件中所有重复的行及其出现次数打印到控制台。</p><hr><h3 id="4-为什么能够读取多个文件"><a href="#4-为什么能够读取多个文件" class="headerlink" title="4. 为什么能够读取多个文件"></a><strong>4. 为什么能够读取多个文件</strong></h3><p>这是因为你的代码通过 <code>for _, arg := files</code> 遍历了 <code>os.Args[1:]</code> 中的所有文件，并依次处理它们。程序对每个文件重复以下流程：</p><ol><li>打开文件。</li><li>按行扫描内容，统计出现次数。</li><li>将结果合并到 <code>counts</code> 映射中。</li></ol><p>这样，即使你提供多个文件，程序依然可以逐个读取并处理它们。</p><hr><h3 id="运行流程示例"><a href="#运行流程示例" class="headerlink" title="运行流程示例"></a><strong>运行流程示例</strong></h3><p>假设有以下文件内容：</p><h4 id="file1-txt"><a href="#file1-txt" class="headerlink" title="file1.txt:"></a><code>file1.txt</code>:</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">world</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><h4 id="file2-txt"><a href="#file2-txt" class="headerlink" title="file2.txt:"></a><code>file2.txt</code>:</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">world</span><br><span class="line">hello</span><br><span class="line">go</span><br></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run main.go file1.txt file2.txt</span><br></pre></td></tr></table></figure><p>程序会：</p><ol><li>读取 <code>file1.txt</code>：<ul><li>统计结果：<code>&#123;&quot;hello&quot;: 2, &quot;world&quot;: 1&#125;</code>。</li></ul></li><li>读取 <code>file2.txt</code>，继续更新 <code>counts</code>：<ul><li>最终统计结果：<code>&#123;&quot;hello&quot;: 3, &quot;world&quot;: 2, &quot;go&quot;: 1&#125;</code>。</li></ul></li><li>打印重复行：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3   hello</span><br><span class="line">2   world</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>你可以读取多个文件是因为程序通过 <code>os.Args</code> 获取了命令行中的文件名列表，并通过循环逐个打开和读取文件的内容。这种设计使得你的程序能够动态处理任意数量的文件，而无需修改代码。</p><hr><h3 id="12-14-日-更考完4级"><a href="#12-14-日-更考完4级" class="headerlink" title="12.14 日 更考完4级"></a>12.14 日 更考完4级</h3><h4 id="一-Errors"><a href="#一-Errors" class="headerlink" title="一.Errors"></a>一.Errors</h4><ol><li>“errors” 包  使用给定的错误消息构造一个基本错误值。</li></ol><p>errors.New(“can’t work with 42”)</p><p>nil 表示没有错误</p><ol start="2"><li>哨兵错误是一个预先声明的变量，用于表示特定的错误情况。</li></ol><p>var ErrOutOfTea &#x3D; fmt.Errorf(“no more tea available”)<br>var ErrPower &#x3D; fmt.Errorf(“can’t boil water”)</p><ol start="3"><li>更高级别的错误来包装错误以添加上下文</li></ol><p>最简单的方法是使用 fmt.Errorf 中的 %w 动词。包装错误创建一个逻辑链（A 包装 B，B 包装 C 等），可以使用 error.Is 和 error.As 等函数进行查询。</p><p>return fmt.Errorf(“making tea: %w”, ErrPower)</p><ol start="4"><li>if 行中使用内联错误检查</li></ol><p>if r, e :&#x3D; f(i); e !&#x3D; nil {<br>fmt.Println(“f failed:”, e)<br>} else {<br>fmt.Println(“f worked:”, r)<br>}</p><ol start="5"><li>error.Is 检查给定错误（或其链中的任何错误）是否与特定错误值匹配。</li></ol><p>if errors.Is(err, ErrOutOfTea) {<br>fmt.Println(“We should buy new tea!”)<br>} else if errors.Is(err, ErrPower) {<br>fmt.Println(“Now it is dark.”)<br>} else {<br>fmt.Printf(“unknown error: %s\n”, err)<br>}</p><p>将err和我们自定义的哨兵错误或者特定错误做对比</p><p>二.自定义错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> argError <span class="keyword">struct</span> &#123;</span><br><span class="line">    arg     <span class="type">int</span></span><br><span class="line">    message <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *argError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%d - %s&quot;</span>, e.arg, e.message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Error 方法并没有直接调用，但 &amp;argError{arg, “can’t work with it”} 被返回为 error 类型时，Error 方法已经在幕后实现了对错误消息的封装。</p><p>error.As 是errors.Is 的更高级版本。它检查给定错误（或其链中的任何错误）是否与特定错误类型匹配，并转换为该类型的值，返回 true。如果没有匹配，则返回 false。</p><h4 id="Goroutines"><a href="#Goroutines" class="headerlink" title="Goroutines"></a>Goroutines</h4><p>轻量级的执行线程</p><p>go f(s)。这个新的 goroutine 将与调用的 goroutine 同时执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(from <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        fmt.Println(from, <span class="string">&quot;:&quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> f(<span class="string">&quot;goroutine&quot;</span>)</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>启动一个 goroutine 来进行匿名函数调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(msg <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">        fmt.Println(msg)</span><br><span class="line">    &#125;(<span class="string">&quot;going&quot;</span>)</span><br></pre></td></tr></table></figure><p>goroutine 是由 Go 运行时同时运行的。</p><h4 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h4><p>通道是连接并发 goroutine 的管道。您可以将值从一个 Goroutine 发送到通道，并将这些值接收到另一个 Goroutine。</p><p>messages :&#x3D; make(chan string)</p><p>通道 &lt;- 语法将值发送到通道</p><p>go func() { messages &lt;- “ping” }()</p><p>msg :&#x3D; &lt;-messages</p><p>&lt;-channel 语法从通道接收值。在这里，我们将收到上面发送的“ping”消息并将其打印出来。</p><p>发送和接收会阻塞，直到发送者和接收者都准备好为止。此属性允许我们在程序结束时等待“ping”消息，而无需使用任何其他同步。</p><p>通道缓冲：</p><p>messages :&#x3D; make(chan string, 2) 字符串通道，最多缓冲 2 个值 因此我们可以将这些值发送到通道中，而无需相应的并发接收。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> messages := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">messages &lt;- <span class="string">&quot;buffered&quot;</span></span><br><span class="line">messages &lt;- <span class="string">&quot;channel&quot;</span></span><br><span class="line"></span><br><span class="line"> fmt.Println(&lt;-messages)</span><br><span class="line"> fmt.Println(&lt;-messages)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="断言和switch用法"><a href="#断言和switch用法" class="headerlink" title="断言和switch用法:"></a>断言和switch用法:</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">t = functionOfSomeType()</span><br><span class="line"><span class="keyword">switch</span> t := t.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;unexpected type %T\n&quot;</span>, t)     <span class="comment">// %T prints whatever type t has</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;boolean %t\n&quot;</span>, t)             <span class="comment">// t has type bool</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;integer %d\n&quot;</span>, t)             <span class="comment">// t has type int</span></span><br><span class="line"><span class="keyword">case</span> *<span class="type">bool</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;pointer to boolean %t\n&quot;</span>, *t) <span class="comment">// t has type *bool</span></span><br><span class="line"><span class="keyword">case</span> *<span class="type">int</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;pointer to integer %d\n&quot;</span>, *t) <span class="comment">// t has type *int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型断言用于从接口类型值中提取其底层的具体类型。如果断言成功，程序可以安全地将该接口值转换为目标类型并使用。</p><p>value, ok :&#x3D; x.(T)</p><p>x 是一个接口类型的变量。<br>T 是目标类型（可以是具体类型或其他接口类型）。<br>如果 x 的动态类型是 T：<br>value 是 x 转换为 T 后的值。<br>ok 为 true。<br>如果 x 的动态类型不是 T：<br>value 是 T 的零值。<br>ok 为 false，表示断言失败。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; = <span class="number">42</span> <span class="comment">// 空接口存储了一个 int 值</span></span><br><span class="line"></span><br><span class="line">value, ok := x.(<span class="type">int</span>) <span class="comment">// 断言 x 是 int 类型</span></span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;x is an int, value: %d\n&quot;</span>, value)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;x is not an int&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空interface<br>空interface(interface{})不包含任何的method，正因为如此，所有的类型都实现了空interface。空interface对于描述起不到任何的作用(因为它不包含任何的method），但是空interface在我们需要存储任意类型的数值的时候相当有用，因为它可以存储任意类型的数值。它有点类似于C语言的void*类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义a为空接口</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span> = <span class="number">5</span></span><br><span class="line">s := <span class="string">&quot;Hello world&quot;</span></span><br><span class="line"><span class="comment">// a可以存储任意类型的数值</span></span><br><span class="line">a = i</span><br><span class="line">a = s</span><br></pre></td></tr></table></figure><p>一个函数把interface{}作为参数，那么他可以接受任意类型的值作为参数，如果一个函数返回interface{},那么也就可以返回任意类型的值。是不是很有用啊！</p><p>Go并发</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>小计划</title>
    <link href="https://whuichenggong.github.io/2024/12/02/study_plan/"/>
    <id>https://whuichenggong.github.io/2024/12/02/study_plan/</id>
    <published>2024-12-02T02:47:34.759Z</published>
    <updated>2024-12-19T14:02:27.389Z</updated>
    
    <content type="html"><![CDATA[<p>兄弟，你的想法很清晰，我非常理解你想深入学习、夯实基础，而不是走捷径的决心。我们可以针对你的目标和现状制定一个更加实践导向的计划，同时保持学习过程有趣且充实。以下是我的建议和方案：</p><hr><h3 id="总体目标"><a href="#总体目标" class="headerlink" title="总体目标"></a><strong>总体目标</strong></h3><ol><li><strong>短期（2025年3月前）</strong>：增强银行项目的实用性和技术深度，掌握后端开发的核心技能，为实习做好准备。</li><li><strong>中长期（未来两年）</strong>：夯实计算机基础，深入理解系统设计、分布式系统及核心算法，逐步具备独立设计和开发复杂项目的能力。</li></ol><hr><h3 id="学习模块规划"><a href="#学习模块规划" class="headerlink" title="学习模块规划"></a><strong>学习模块规划</strong></h3><h4 id="1-项目深度增强（每周一个主题，贯穿整个学习计划）"><a href="#1-项目深度增强（每周一个主题，贯穿整个学习计划）" class="headerlink" title="1. 项目深度增强（每周一个主题，贯穿整个学习计划）"></a><strong>1. 项目深度增强（每周一个主题，贯穿整个学习计划）</strong></h4><p>目标：将现有银行项目提升到更贴近实际业务需求的水平，增加亮点功能。</p><ul><li><p><strong>Week 1: 数据一致性与事务</strong></p><ul><li>学习事务隔离级别（ACID），在项目中实现更加复杂的转账操作（如跨账户冻结和解冻）。</li><li>使用 SQLC 或 GORM，优化数据库操作。</li></ul></li><li><p><strong>Week 2: 引入 Redis</strong></p><ul><li>学习 Redis 基础知识，理解其在缓存和分布式锁中的应用。</li><li>在项目中实现：<ul><li>用户信息缓存，优化频繁查询。</li><li>基于 Redis 的幂等性控制（防止转账操作重复）。</li></ul></li></ul></li><li><p><strong>Week 3: RESTful API 和 JWT 身份验证</strong></p><ul><li>深化对 RESTful API 的理解，优化项目 API 设计。</li><li>引入 JWT 实现用户登录认证和权限管理。</li></ul></li><li><p><strong>Week 4: 日志和监控</strong></p><ul><li>集成日志框架（如 Logrus&#x2F;Zap），记录系统操作。</li><li>学习 Prometheus 基础知识，为项目添加简单监控。</li></ul></li><li><p><strong>Week 5: Docker 和部署优化</strong></p><ul><li>使用 Docker Compose 部署完整项目，模拟生产环境。</li><li>学习 Nginx 基础知识，优化项目访问流程。</li></ul></li><li><p><strong>Week 6: 微服务化</strong></p><ul><li>学习 Go 微服务框架（如 Gin、gRPC）。</li><li>将项目拆分成两个服务（如用户服务和交易服务），理解微服务架构基础。</li></ul></li></ul><hr><h4 id="2-算法与数据结构（每天一题，逐渐深入）"><a href="#2-算法与数据结构（每天一题，逐渐深入）" class="headerlink" title="2. 算法与数据结构（每天一题，逐渐深入）"></a><strong>2. 算法与数据结构（每天一题，逐渐深入）</strong></h4><p>目标：构建扎实的算法基础，为今后面试和实际开发做准备。</p><ul><li><strong>题目选择顺序</strong>：简单 -&gt; 中等 -&gt; 困难，优先 BFS&#x2F;DFS、二分查找、动态规划等重要领域。</li><li><strong>周主题</strong>：<ul><li>Week 1-2: 栈、队列、链表</li><li>Week 3-4: 二叉树与递归</li><li>Week 5-6: 动态规划与分治算法</li><li>Week 7+: 高频面试题复盘（重点记录和总结常见套路）。</li></ul></li></ul><hr><h4 id="3-计算机基础与原理（每周一本书-主题）"><a href="#3-计算机基础与原理（每周一本书-主题）" class="headerlink" title="3. 计算机基础与原理（每周一本书&#x2F;主题）"></a><strong>3. 计算机基础与原理（每周一本书&#x2F;主题）</strong></h4><p>目标：夯实后端开发的计算机科学基础。</p><ul><li><p><strong>Week 1: 计算机网络</strong></p><ul><li>阅读《计算机网络：自顶向下方法》或《图解HTTP》。</li><li>重点学习 HTTP、HTTPS、TCP&#x2F;IP 的工作原理，并理解抓包工具（如 Wireshark）的使用。</li></ul></li><li><p><strong>Week 2: 操作系统</strong></p><ul><li>阅读《现代操作系统》。</li><li>理解线程、进程、同步机制，以及如何在 Go 中实现简单的并发处理。</li></ul></li><li><p><strong>Week 3-4: 数据库系统</strong></p><ul><li>阅读《数据库系统概念》。</li><li>理解索引、事务原理、查询优化等内容。</li></ul></li><li><p><strong>Week 5: 系统设计</strong></p><ul><li>阅读《系统设计入门》或相关博客。</li><li>学习常见系统设计模式（如限流、负载均衡）和架构决策。</li></ul></li></ul><hr><h3 id="具体每日安排（样例）"><a href="#具体每日安排（样例）" class="headerlink" title="具体每日安排（样例）"></a><strong>具体每日安排（样例）</strong></h3><ul><li><p><strong>上午</strong>：</p><ul><li>刷一道 LeetCode 算法题，阅读相关解析，整理题解。</li><li>学习书籍相关章节，完成1-2页的读书笔记。</li></ul></li><li><p><strong>下午</strong>：</p><ul><li>按周主题在银行项目中完成对应功能开发。</li><li>查看官方文档、博客或视频教程，记录学习中的关键点。</li></ul></li><li><p><strong>晚上</strong>：</p><ul><li>复习当天内容，整理代码和笔记。</li><li>自测项目功能，尝试优化代码。</li></ul></li></ul><hr><h3 id="可实践性建议"><a href="#可实践性建议" class="headerlink" title="可实践性建议"></a><strong>可实践性建议</strong></h3><ol><li><strong>建立个人技术博客</strong>：把每天的学习记录写成博客或日志，比如讲解项目中 Redis 的用法或总结某道算法题的思路。</li><li><strong>参与开源项目</strong>：找一个简单的 Go 开源项目，阅读代码，尝试修复 bug 或贡献文档。</li><li><strong>模拟面试</strong>：每两周自测一次，将银行项目作为核心，讲解架构设计和亮点功能。</li></ol><hr><h3 id="最终成果展示"><a href="#最终成果展示" class="headerlink" title="最终成果展示"></a><strong>最终成果展示</strong></h3><ul><li>一个高度完善的银行项目：<ul><li>支持分布式事务、JWT 身份验证、Redis 缓存与微服务架构。</li><li>提供完善的 Docker 部署文档。</li></ul></li><li>一个 LeetCode 高质量题解库（至少 50 道题）。</li><li>一份扎实的基础知识笔记，涵盖网络、操作系统和数据库。</li></ul><p>引入项目技术栈（2周）：在新项目中加入 SQLC 工具、中间件，理解每个技术的接入过程。</p><p>实现进阶功能（3周）：根据银行项目的转账逻辑，尝试自己独立实现一次。</p><p>重点学习 HTTP 和 RESTful API。 深入理解数据库  深入理解数据库 熟悉中间件的实现逻辑</p><p>Web开发</p><ol><li>Go by example</li><li>三本书</li><li>两个项目 Memos Apache Answer</li><li>算法</li><li>gin-gonic.com</li></ol><p>微服务进阶</p><p>  gRPC</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;兄弟，你的想法很清晰，我非常理解你想深入学习、夯实基础，而不是走捷径的决心。我们可以针对你的目标和现状制定一个更加实践导向的计划，同时保持学习过程有趣且充实。以下是我的建议和方案：&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;总体目标&quot;&gt;&lt;a href=&quot;#总体目标&quot; class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>11.26日字节直播总结</title>
    <link href="https://whuichenggong.github.io/2024/11/26/Dance_live2/"/>
    <id>https://whuichenggong.github.io/2024/11/26/Dance_live2/</id>
    <published>2024-11-26T12:20:49.917Z</published>
    <updated>2024-11-26T12:25:46.917Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字节结营直播答疑"><a href="#字节结营直播答疑" class="headerlink" title="字节结营直播答疑"></a>字节结营直播答疑</h1><p>revue 项目</p><p><img src="/about_Dance/1.png" alt="image-20241126190953519"></p><p><img src="/about_Dance/2.png" alt="image-20241126191031196"></p><p>性能优化     ci&#x2F;cd流程 （ star法则来描述一件事情)</p><p>准备找实习 写好简历</p><p><img src="/about_Dance/3.png" alt="image-20241126191500892"></p><p>zt：</p><p>服务端： 计算机基础知识（字节：计算机网络 tcp&#x2F;ip  腾讯：操作系统 阿里： 组成原理）</p><p>技术： （数据结构 高阶算法 链表 堆栈 树（面试重点））</p><p>leetcode 100 150 200</p><p>项目： 烂大街的（入门） 改进一些项目（做优化 项目存在的意义 解决了什么问题？ 带来了什么？ 项目亮点在哪里）</p><p>实习经历：（做了什么需求 需求是（谁给的 自己还是别人？）通过实现了什么？ 解决了什么？ 团队收益还是小组收益？）</p><p>专业能力： 小厂一门语言 ＋数据库存储 会就ok  大数据 架构数据 微服务层面</p><p><img src="/about_Dance/4.png" alt="image-20241126192005590"></p><p>八股扎实稳固 算法 中等难度题很快弄出来</p><p>项目亮点：能让面试官和你聊下去 如何提升亮点和竞争力  开源社区！</p><p>抄项目 然后手写 尝试自己理解      前端（vue）（react）</p><p><img src="/about_Dance/5.png" alt="image-20241126192541252"></p><p>数据结构 计算机基础知识  面试官想看你的亮点（你牛逼在哪里？）</p><p>做过什么会什么？</p><p>服务端是一些思维 而不是纠结你是用什么语言</p><p>从0-1 有没有调研 各行各业的优秀作业</p><p>合作项目</p><p>责任意识</p><p>技术探索：遇到什么问题 怎么解决的？</p><p>业务理解能力 项目受众是谁 项目模块 最重要是哪个模块 怎么优化这个模块</p><p><img src="/about_Dance/6.png" alt="image-20241126193100190"></p><p><img src="/about_Dance/7.png" alt="image-20241126193341747"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">“开源社区新手入门该参与什么内容，有哪些社区比较活跃”</span><br><span class="line">可以看看类似于开源之夏这类的活动往年都是做什么的</span><br></pre></td></tr></table></figure><p>多逛github</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">“在github中新手怎么找项目”</span><br><span class="line">，你用vue就去看VUE文档仓库，看看有没有错别字，有的话修一下</span><br></pre></td></tr></table></figure><p>项目的含金量 和自己从0-1实现</p><p>组件多 中间件多 新奇的做法等 可以被称为含金量（）</p><p>核心能力 技术深度 在广度的前提下 一定要有一个深度</p><p>项目一样 面试官能问什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">老哥们 大二第一次找实习的话一般要什么程度我正在跟着别人做一个项目 但是不知道什么时候才够格去投简历”</span><br><span class="line">看看面经别人被问了什么你能不能回答</span><br></pre></td></tr></table></figure><p><img src="/about_Dance/8.png" alt="image-20241126193803102"></p><p>平地起项目 是有条件的： 大厂实习 项目经历&gt;&#x3D;3 等经历 否则不要平地起</p><p>对于项目的理解一定是从头到尾的 对项目改造 新增功能 优化 才能体现你的亮点</p><p>思考 ： 多人协作是否有沟通 是否涉及复杂逻辑</p><p>新颖的想法！ 创造力！</p><p>投简历的方式</p><p>如何面对八股 算法</p><p>找开源项目：熟悉流程 寻找错别字熟悉流程哈哈哈 看issue bug（解决issue）</p><p>知乎 蔚来 比亚迪 从小厂到大厂 循序渐进</p><p><img src="/about_Dance/9.png" alt="image-20241126195807918"></p><p>字节  99%go</p><p>语言是基础无所谓</p><p>培养独立解决问题的能力 做出一个合格的项目 （不断回顾自己的项目 查找不足）</p><p>后端开发实习生（简历）</p><p>数据库的课（掘金的）</p><p>《Redis深度历险：核心原理和应用实践》</p><p>服务端开源： 不建议新手就去找开源 学习成本很大 2~3段实习之后尝试开源</p><p><img src="/about_Dance/10.png" alt="image-20241126200922693"></p><p>知名项目源码： 前提一定要熟悉使用这个项目的源码 项目的使用环境 如何启动它</p><p>例如：熟练使用docker ， kubernets istio了，再去看源码 i   <strong>写出一个对源码理解的文章</strong></p><p>对于源码：一步一步慢慢来 该学的东西就学 不要纠结没用的例如学历 没法改变就不去改变</p><p>.md .sh 依赖那些中间件 中间件是否具备？ 如何去不使用中间件如何启动这个项目 分析目录结构（单体 还是微服务）包的作用 模块之间的耦合关系  利用isue 项目常见报错解决方式</p><p>组队开发的群聊看看能不能找到</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;字节结营直播答疑&quot;&gt;&lt;a href=&quot;#字节结营直播答疑&quot; class=&quot;headerlink&quot; title=&quot;字节结营直播答疑&quot;&gt;&lt;/a&gt;字节结营直播答疑&lt;/h1&gt;&lt;p&gt;revue 项目&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/about_Dance/1.png&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>UDP socket的ack机制和丢包重传</title>
    <link href="https://whuichenggong.github.io/2024/11/23/UDP_socket/"/>
    <id>https://whuichenggong.github.io/2024/11/23/UDP_socket/</id>
    <published>2024-11-23T09:15:42.999Z</published>
    <updated>2024-12-15T12:37:16.302Z</updated>
    
    <content type="html"><![CDATA[<p>参考连接： <a href="https://juejin.cn/post/7263378772040122429">https://juejin.cn/post/7263378772040122429</a></p><h1 id="Go语言实现UDP-socket的ack机制和丢包重传"><a href="#Go语言实现UDP-socket的ack机制和丢包重传" class="headerlink" title="Go语言实现UDP socket的ack机制和丢包重传"></a>Go语言实现UDP socket的ack机制和丢包重传</h1><p>UDP 在通讯之前不需要建立连接 可以直接发送数据包 是一种无连接协议（常用于音视频传输）</p><p>但是在有些场景 即需要UDP传输也需要向TCP一样（TCP的可靠传输）</p><p>解决丢包问题：</p><p>1.添加 seq&#x2F;ack机制 确保数据发送到对端</p><p>什么是 seq&#x2F;ack机制</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在TCP（传输控制协议）中，序号（Sequence Number，简称seq）和确认应答号（Acknowledgment Number，简称ack）是协议头部非常关键的字段，它们共同确保了TCP的可靠性和数据按顺序传输的特性。</span><br><span class="line"></span><br><span class="line">** Sequence Number **</span><br><span class="line">含义：序号是指一个TCP报文段中第一个字节的数据序列标识。它表示在一个TCP连接中，该报文段所携带的数据的开始位置。序号是用来保证数据传输的顺序性和完整性的。</span><br><span class="line"></span><br><span class="line">作用：在TCP连接建立时，双方各自随机选择一个初始序列号（ISN）。随后传输的每个报文段的序号将基于这个初始值递增，其增量为该报文段所携带的数据量（字节数）。通过这种方式，接收方可以根据序号重组乱序到达的数据片段，确保数据的正确顺序和完整性。如果接收到的报文段不连续，接收方可以通过TCP的重传机制请求发送方重新发送缺失的数据。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**Acknowledgment Number**</span><br><span class="line">含义：确认应答号是接收方期望从发送方接收到的下一个报文段的序号。它实质上是接收方告诉发送方：“我已经成功接收到了哪个序号之前的所有数据，请从这个序号开始发送后续的数据。”</span><br><span class="line"></span><br><span class="line">作用：确认应答号用于实现可靠性传输。当一个报文段被接收方正确接收时，接收方会发送一个ACK报文，其中包含的确认应答号是接收到的数据加上1（即接收方期望接收的下一个数据的序号）。通过检查这个确认应答号，发送方能够知道其发送的数据是否已被接收方正确接收，并据此决定是否需要重传某些数据段。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ack和seq 保证了：</p><ul><li>确保数据的顺序性：即使数据片段在网络中的传输过程中顺序被打乱，接收方也能根据序号正确地重组这些数据。</li><li>检测丢包：如果发送方发送的数据长时间未被确认（即没有收到对应的ACK报文），它会判断这些数据可能已丢失，并将其重新发送。</li><li>实现流量控制和拥塞控制：通过调整发送未被确认数据的量（即控制窗口大小），TCP可以根据网络条件动态调整数据发送的速率，避免网络拥塞。</li></ul><h4 id="Golang的socket编程："><a href="#Golang的socket编程：" class="headerlink" title="Golang的socket编程："></a>Golang的socket编程：</h4><p>Go语言通过标准库中的<code>net</code>包来实现UDP和TCP的socket编程。<code>net</code>包提供了用于创建和管理网络连接的函数，以及用于进行数据传输的相关类型和方法，不同于C++需要手动设置和管理socket API，不论实现UDP还是TCP都可以直接使用封装好的方法进行操作，大大简化了socket编程：</p><h5 id="使用net包实现UDP通信"><a href="#使用net包实现UDP通信" class="headerlink" title="使用net包实现UDP通信"></a>使用net包实现UDP通信</h5><h6 id="1-client-go"><a href="#1-client-go" class="headerlink" title="1.client.go"></a>1.client.go</h6><p>1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;bufio&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;net&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">// 创建UDP连接到服务器的地址和端口号</span><br><span class="line">c, err := net.DialUDP(&quot;udp&quot;, nil, &amp;net.UDPAddr&#123;</span><br><span class="line">IP:   net.IPv4(127, 0, 0, 1),</span><br><span class="line">Port: 8282,</span><br><span class="line">&#125;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(&quot;dial err: %v\n&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">defer c.Close() // 将 defer 放在 if 语句外面</span><br><span class="line"></span><br><span class="line">// 从标准输入读取用户输入的数据</span><br><span class="line">input := bufio.NewReader(os.Stdin)</span><br><span class="line">for &#123;</span><br><span class="line">// 读取用户输入知道遇见换行符</span><br><span class="line">s, err := input.ReadString(&#x27;\n&#x27;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Printf(&quot;read from stdin failed, err: %v\n&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将用户输入的数据转换为字节数组并通过UDP连接发送给服务器</span><br><span class="line">_, err = c.Write([]byte(s))</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Printf(&quot;send to server failed, err: %v\n&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 接收来自服务器的数据</span><br><span class="line">var buf [1024]byte</span><br><span class="line">n, addr, err := c.ReadFromUDP(buf[:])</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Printf(&quot;recv from udp failed, err: %v\n&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 打印来自服务器的数据</span><br><span class="line">fmt.Printf(&quot;服务器 %v, 响应数据: %v\n&quot;, addr, string(buf[:n]))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="2-server-go"><a href="#2-server-go" class="headerlink" title="2.server.go"></a>2.server.go</h6><p>首先创建UDP监听器监听指定IP和端口，等待连接客户端，连接后会读取客户端发来的数据并打印收到的数据，并将接收的响应信息返回发送给客户端，使用死循环使其能够持续获取客户端数据，同样实现了UDP的数据接收和发送，实现了简单的UDP服务器；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;net&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// udp server</span><br><span class="line">func main() &#123;</span><br><span class="line">// 创建一个UDP监听器，监听本地IP地址的端口</span><br><span class="line">listen, err := net.ListenUDP(&quot;udp&quot;, &amp;net.UDPAddr&#123;</span><br><span class="line">IP:   net.IPv4(127, 0, 0, 1),</span><br><span class="line">Port: 8282,</span><br><span class="line">&#125;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Printf(&quot;listen failed,err:%v\n&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">defer listen.Close()</span><br><span class="line"></span><br><span class="line">for &#123;</span><br><span class="line">var buf [1024]byte</span><br><span class="line">// 从UDP连接中读取数据到buf中，n为读取到的字节数，addr为数据发送者的地址</span><br><span class="line">n, addr, err := listen.ReadFromUDP(buf[:])</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Printf(&quot;read from udp failed,err:%v\n&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 打印接收到的数据</span><br><span class="line">fmt.Println(&quot;接收到的数据：&quot;, string(buf[:n]))</span><br><span class="line"></span><br><span class="line">// 将接收到的数据原样发送回给数据发送者</span><br><span class="line">_, err = listen.WriteToUDP(buf[:n], addr)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Printf(&quot;write to %v failed,err:%v\n&quot;, addr, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>效果：（好有趣）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; go run client.go</span><br><span class="line">hello</span><br><span class="line">服务器 127.0.0.1:8282, 响应数据: hello</span><br><span class="line"></span><br><span class="line">world</span><br><span class="line">服务器 127.0.0.1:8282, 响应数据: world</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> go run server.go</span><br><span class="line">接收到的数据： hello</span><br><span class="line"></span><br><span class="line">接收到的数据： world</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="基于seq-apk"><a href="#基于seq-apk" class="headerlink" title="基于seq&#x2F;apk"></a>基于seq&#x2F;apk</h5><p>client</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">Seq <span class="type">int</span></span><br><span class="line">Msg <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c, err := net.DialUDP(<span class="string">&quot;udp&quot;</span>, <span class="literal">nil</span>, &amp;net.UDPAddr&#123;</span><br><span class="line">IP:   net.IPv4(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">Port: <span class="number">8282</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;dail err:%v\n&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> c.Close()</span><br><span class="line"></span><br><span class="line">input := []<span class="type">string</span>&#123;<span class="string">&quot;Message1&quot;</span>, <span class="string">&quot;Message2&quot;</span>, <span class="string">&quot;Message3&quot;</span>, <span class="string">&quot;Message4&quot;</span>, <span class="string">&quot;Message5&quot;</span>&#125;</span><br><span class="line">seq := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, msg := <span class="keyword">range</span> input &#123;</span><br><span class="line">seq++</span><br><span class="line">message := Message&#123;Seq: seq, Msg: msg&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Sending seq=%d: %s\n&quot;</span>, message.Seq, message.Msg)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送带有序列号的数据包</span></span><br><span class="line">_, err = c.Write(encodeMessage(message))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;send to server failed,err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等待ACK，设置超时时间</span></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">c.SetReadDeadline(time.Now().Add(<span class="number">5</span> * time.Second))</span><br><span class="line">n, _, err := c.ReadFromUDP(buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;ACK not received. Timeout or Error.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ack := decodeMessage(buf[:n])</span><br><span class="line"><span class="keyword">if</span> ack.Seq == seq+<span class="number">1</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;ACK = %d\n&quot;</span>, ack.Seq)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Invalid ACK received. Retry.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">encodeMessage</span><span class="params">(msg Message)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line"><span class="comment">// 将序列号和消息文本编码成字节数据</span></span><br><span class="line"><span class="keyword">return</span> []<span class="type">byte</span>(fmt.Sprintf(<span class="string">&quot;%d;%s&quot;</span>, msg.Seq, msg.Msg))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decodeMessage</span><span class="params">(data []<span class="type">byte</span>)</span></span> Message &#123;</span><br><span class="line"><span class="comment">// 解码收到的数据，提取序列号和消息文本</span></span><br><span class="line">parts := strings.Split(<span class="type">string</span>(data), <span class="string">&quot;;&quot;</span>)</span><br><span class="line">seq, _ := strconv.Atoi(parts[<span class="number">0</span>])</span><br><span class="line">msg := parts[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">return</span> Message&#123;Seq: seq, Msg: msg&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>server</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Message2 <span class="keyword">struct</span> &#123;</span><br><span class="line">Seq <span class="type">int</span></span><br><span class="line">Msg <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">listen, err := net.ListenUDP(<span class="string">&quot;udp&quot;</span>, &amp;net.UDPAddr&#123;</span><br><span class="line">IP:   net.IPv4(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">Port: <span class="number">8282</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;listen failed,err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> listen.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">var</span> buf [<span class="number">1024</span>]<span class="type">byte</span></span><br><span class="line">n, addr, err := listen.ReadFromUDP(buf[:])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;read from udp failed,err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理接收到的数据，提取序列号和消息文本</span></span><br><span class="line">message := decodeMessage1(buf[:n])</span><br><span class="line">fmt.Printf(<span class="string">&quot;Received seq=%d from %v: %s\n&quot;</span>, message.Seq, addr, message.Msg)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送ACK回复给客户端，ACK=Seq+1</span></span><br><span class="line">ack := Message2&#123;Seq: message.Seq + <span class="number">1</span>, Msg: <span class="string">&quot;ACK&quot;</span>&#125;</span><br><span class="line">_, err = listen.WriteToUDP(encodeMessage1(ack), addr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;write to %v failed,err:%v\n&quot;</span>, addr, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">encodeMessage1</span><span class="params">(msg Message2)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line"><span class="comment">// 将序列号和消息文本编码成字节数据</span></span><br><span class="line"><span class="keyword">return</span> []<span class="type">byte</span>(fmt.Sprintf(<span class="string">&quot;%d;%s&quot;</span>, msg.Seq, msg.Msg))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decodeMessage1</span><span class="params">(data []<span class="type">byte</span>)</span></span> Message2 &#123;</span><br><span class="line"><span class="comment">// 解码收到的数据，提取序列号和消息文本</span></span><br><span class="line">parts := strings.Split(<span class="type">string</span>(data), <span class="string">&quot;;&quot;</span>)</span><br><span class="line">seq, _ := strconv.Atoi(parts[<span class="number">0</span>])</span><br><span class="line">msg := parts[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">return</span> Message2&#123;Seq: seq, Msg: msg&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>问题核心：在同一文件夹内，Go 默认将所有文件视为同一包的一部分，可能导致重复定义或未定义的错误。<br>推荐解决方法：<br>分文件夹运行。<br>提取共享逻辑到单独的文件。<br>运行时显式指定所有 .go 文件。<br>额外改进：通过参数区分服务端和客户端运行模式，进一步优化程序结构。</p><p>，服务器监听的端口可能是某个固定端口（例如 12345），而客户端的UDP数据包来自 127.0.0.1:59653。这意味着：<br>UDP允许客户端选择任意可用的端口号作为源端口，并将数据包发送到服务器的监听端口。这也是为什么你看到不同的端口号。</p><hr><h5 id="4-实现超时重传"><a href="#4-实现超时重传" class="headerlink" title="4.实现超时重传"></a>4.实现超时重传</h5><p>最简单的方法就是当超时没有收到ack回复或者ack回复错误乱序时，阻塞后续发包，先进行重传，<br>把丢失的包重传后再继续发包，因此主要是在客户端更改一些发包的逻辑，服务端则没有变化；</p><p>client.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">Seq <span class="type">int</span></span><br><span class="line">Msg <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c, err := net.DialUDP(<span class="string">&quot;udp&quot;</span>, <span class="literal">nil</span>, &amp;net.UDPAddr&#123;</span><br><span class="line">IP:   net.IPv4(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">Port: <span class="number">8282</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;dial,err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> c.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例数据</span></span><br><span class="line">input := []<span class="type">string</span>&#123;<span class="string">&quot;Message 1&quot;</span>, <span class="string">&quot;Message 2&quot;</span>, <span class="string">&quot;Message 3&quot;</span>, <span class="string">&quot;Message 4&quot;</span>, <span class="string">&quot;Message 5&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> seq, msg := <span class="keyword">range</span> input &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">message := Message&#123;Seq: seq + <span class="number">1</span>, Msg: msg&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Sending seq=%d: %s\n&quot;</span>, message.Seq, message.Msg)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送带有序列号的数据包</span></span><br><span class="line">_, err := c.Write(encodeMessage(message))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;send to server failed,err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始等待ACK，设置超时时间</span></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">c.SetReadDeadline(time.Now().Add(<span class="number">5</span> * time.Second))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环等待ACK，直到收到正确的ACK或超时</span></span><br><span class="line">n, _, err := c.ReadFromUDP(buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 超时或发生错误，需要重传</span></span><br><span class="line">fmt.Println(<span class="string">&quot;ACK not received. Timeout or Error. Retrying...&quot;</span>)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//解码从服务器传来的ack</span></span><br><span class="line">ack := decodeMessage(buf[:n])</span><br><span class="line"><span class="keyword">if</span> ack.Seq == seq+<span class="number">2</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;ACK = %d\n&quot;</span>, ack.Seq)</span><br><span class="line"><span class="comment">// 收到正确的ACK，跳出内部循环，继续发送下一个消息</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 收到错误的ACK，继续等待，内部循环会重发相同的消息</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Invalid ACK received. Waiting for correct ACK...&quot;</span>)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">encodeMessage</span><span class="params">(msg Message)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line"><span class="comment">// 将序列号和消息文本编码成字节数据</span></span><br><span class="line"><span class="keyword">return</span> []<span class="type">byte</span>(fmt.Sprintf(<span class="string">&quot;%d;%s&quot;</span>, msg.Seq, msg.Msg))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decodeMessage</span><span class="params">(data []<span class="type">byte</span>)</span></span> Message &#123;</span><br><span class="line"><span class="comment">// 解码收到的数据，提取序列号和消息文本</span></span><br><span class="line">parts := strings.Split(<span class="type">string</span>(data), <span class="string">&quot;;&quot;</span>)</span><br><span class="line">seq, _ := strconv.Atoi(parts[<span class="number">0</span>])</span><br><span class="line">msg := parts[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">return</span> Message&#123;Seq: seq, Msg: msg&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>server.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math/rand&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">Seq <span class="type">int</span></span><br><span class="line">Msg <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">listen, err := net.ListenUDP(<span class="string">&quot;udp&quot;</span>, &amp;net.UDPAddr&#123;</span><br><span class="line">IP:   net.IPv4(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">Port: <span class="number">8282</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;listen failed,err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> listen.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">var</span> buf [<span class="number">1024</span>]<span class="type">byte</span></span><br><span class="line">n, addr, err := listen.ReadFromUDP(buf[:])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;read from udp failed,err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以20%的概率模拟丢包</span></span><br><span class="line"><span class="keyword">if</span> rand.Float32() &lt; <span class="number">0.2</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;From %v lost package\n&quot;</span>, addr)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理接收到的数据，解码字节流 提取序列号和消息文本</span></span><br><span class="line">message := decodeMessage(buf[:n])</span><br><span class="line">fmt.Printf(<span class="string">&quot;Received seq=%d from %v: %s\n&quot;</span>, message.Seq, addr, message.Msg)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送ACK回复给客户端，ACK=Seq+1</span></span><br><span class="line">ack := Message&#123;Seq: message.Seq + <span class="number">1</span>, Msg: <span class="string">&quot;ACK&quot;</span>&#125;</span><br><span class="line"><span class="comment">//写入ack向UDP连接中</span></span><br><span class="line">_, err = listen.WriteToUDP(encodeMessage(ack), addr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;write to %v failed,err:%v\n&quot;</span>, addr, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">encodeMessage</span><span class="params">(msg Message)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line"><span class="comment">// 将序列号和消息文本编码成字节数据</span></span><br><span class="line"><span class="keyword">return</span> []<span class="type">byte</span>(fmt.Sprintf(<span class="string">&quot;%d;%s&quot;</span>, msg.Seq, msg.Msg))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decodeMessage</span><span class="params">(data []<span class="type">byte</span>)</span></span> Message &#123;</span><br><span class="line"><span class="comment">// 解码收到的数据，提取序列号和消息文本</span></span><br><span class="line">parts := strings.Split(<span class="type">string</span>(data), <span class="string">&quot;;&quot;</span>)</span><br><span class="line">seq, _ := strconv.Atoi(parts[<span class="number">0</span>])</span><br><span class="line">msg := parts[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">return</span> Message&#123;Seq: seq, Msg: msg&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述方法实现的丢包重传虽然能够正常工作，但是发送端使用双层循环嵌套，并且每次丢包都阻塞了后续发包，这样会导致重传的效率很低，只适用于小宽带低延时的情况，而且超时重传容易产生误判，主要有以下两种情况：</p><p>对方收到了数据包，但是ack发送途中丢失，其实就是我服务器模拟丢包的情况，服务器可能收到了数据，但是因为某种原因ack没能正确发送；<br>ack在回传的途中，但是时间已经超过了发送端的ack等待时间即超过了一次RTO，这样也会导致接收端收到数据却仍然重传的问题。</p><p>学习 滑动窗口 拥塞控制 优化一些东西 深入理解seq&#x2F;ack的原理和超时重传的逻辑 Go语言进行socket编程的方法 UDP和TCP的一些知识</p><p>借鉴文章：<a href="https://blog.csdn.net/weixin_41500064/article/details/135119715">https://blog.csdn.net/weixin_41500064/article/details/135119715</a></p><h5 id="流量控制："><a href="#流量控制：" class="headerlink" title="流量控制："></a>流量控制：</h5><p>作用：为了解决发送方和接收方速度不同而导致的数据丢失问题,当发送方发送的太快,接收方来不及接受就会导致数据丢失；</p><p>方式：由接收端采用滑动窗口的形式，告知发送方允许&#x2F;停止发包解决TCP丢包问题。</p><h5 id="拥塞控制："><a href="#拥塞控制：" class="headerlink" title="拥塞控制："></a>拥塞控制：</h5><p>作用：为了解决过多的数据注入到网络导致网络崩溃和超负荷问题；</p><p>方式：由发送方采用拥塞窗口的形式去判断网络状态，从而采取不同算法执行TCP动态发包解决网络整体质量问题。</p><p>典型的场景如以太网场景中10G设备向1G设备发TCP包：<br>10G网卡 10Gbps 持续发送TCP包 交换机 以 1Gbps每秒接收TCP包<br>TCP 提供一种机制可以让发送端根据接收端的实际接收能力控制发送的数据量。这就是所谓的流控制。<br>接收端主机向发送端主机通知自已可以接收数据的大小；<br>是发送端会发送不超过这个限度的数据，该大小限度就被称作窗口大小。窗口大小的值由接收端主机决定，而在TCP 首部中，专门有一个字段用来通知窗口大小：<br>接收主机将自己可以接收的缓冲区大小放入这个字段中通知给发送端，这个字段的值越大，说明网络的吞吐量越高。<br>发送端主机会根据接收端主机的指示，对发送数据的量进行控制。这也就形成了一个完整的TCP流控制(流量控制)。<br>当Window&#x3D;0时，即告知发送方停止发送数据。</p><h5 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h5><p>发送方先探测网络拥塞程度，并不是一开始就发送大量的数据，发送方会根据拥塞程度增大拥塞窗口cwnd。<br>拥塞窗口cwnd值是几就能发送几个数据段</p><h5 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h5><p>继上图达到cwnd≥ssthresh后采用该算法用来控制拥塞窗口的增长速率。</p><p>计算方法：每经过一个传输轮次cwnd值加1，让cwnd值呈线性缓慢增大</p><h5 id="拥塞发生"><a href="#拥塞发生" class="headerlink" title="拥塞发生"></a>拥塞发生</h5><p>当网络发生拥塞丢包时（如图假定cwnd&#x3D;24），会有两种情况：</p><p>超时重传（1988年TCP Tahoe版本，已废弃不用）</p><p>更新后的 ssthresh 值变为 12(即为出现超时时的窗口数值 24 的一半)，拥窗口再重新设置为1<br>并执行慢开始算法。当cwnd &#x3D; ssthresh &#x3D; 12 时改为执行拥塞避免算法拥塞窗口按线性规律增长，<br>每经过一个往返时间增加一个MSS的大小。在TCP拥塞控制的文献中经常可看见“乘法减小”(Multiplicative Decrease)和“加法增大”(Additive Increase)这样的提法。<br>“乘法减小”是指不论在开始阶段还是拥塞避免阶段，只要出现超时(即很可能出现了网络拥塞)，就把慢开始门限值 ssthresh 减半，即设置为当前的拥塞窗口的一半(与此同时，执行慢开始算法)。<br>而“加法增大”是指执行拥塞避免算法后，使拥塞窗口缓慢增大，以防止网络过早出现拥塞。上面两种算法合起来常称为 AIMD算法(加法增大乘法减小)。</p><h5 id="快重传与快恢复"><a href="#快重传与快恢复" class="headerlink" title="快重传与快恢复"></a>快重传与快恢复</h5><p>超时重传算法直接把cwnd减小到1太过强烈，若还能收到连续3个ACK说明网络质量没那么差。同时采用快重传和快恢复算法，过程如下：</p><p>（1）当发送方连续收到3个重复确认时即执行“乘法减小”算法，把慢开始门限ssthresh 减半；</p><p>（2）由于发送方现在认为网络不那么差，于是把cwnd值设置为开始门限ssthresh 减半后的数值；</p><p>（3）开始执行拥塞避免算法 (“加法增大”)使拥塞窗口缓慢地线性增大。</p><hr><h4 id="12-25-日"><a href="#12-25-日" class="headerlink" title="12.25 日"></a>12.25 日</h4><p>根据计算机网络这本书，深入了解UDP套接字编程：</p><p>整体的一个过程： 进程间彼此通过向套接字发送报文来进行通信</p><p>一个主机-》多个进程 1个进程-》多个套接字</p><p>帮助记忆： 进程是一间房子 而 套接字是房子门 还需要一个 端口 来识别我具体要将信息发送到哪间房子，也就是具体的房间号（端口）</p><ol><li>客户从键盘键入数据，并向服务器发送数据（将数据编码成字节流），</li><li>服务器接收数据（接收字节流）-》并将其解码为原始客户端输入的数据 （并把小写转换为大写）</li><li>服务器将修改的数据（编码为字节流）发送回客户端</li><li>客户端接收数据后解码 并显示在屏幕上</li></ol><p>接收源地址（ip+端口号）和分组</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考连接： &lt;a href=&quot;https://juejin.cn/post/7263378772040122429&quot;&gt;https://juejin.cn/post/7263378772040122429&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Go语言实现UDP-socket的ac</summary>
      
    
    
    
    
  </entry>
  
</feed>
