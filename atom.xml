<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>森林</title>
  
  
  <link href="https://whuichenggong.github.io/atom.xml" rel="self"/>
  
  <link href="https://whuichenggong.github.io/"/>
  <updated>2024-12-28T13:03:47.055Z</updated>
  <id>https://whuichenggong.github.io/</id>
  
  <author>
    <name>赵忠赫</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://whuichenggong.github.io/2024/12/28/github%E4%B8%BB%E9%A1%B5/"/>
    <id>https://whuichenggong.github.io/2024/12/28/github%E4%B8%BB%E9%A1%B5/</id>
    <published>2024-12-28T13:03:47.055Z</published>
    <updated>2024-12-28T13:03:47.055Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>你的灯还亮着吗</title>
    <link href="https://whuichenggong.github.io/2024/12/28/%E7%9C%8B%E4%BA%86%E4%B8%80%E6%9C%AC%E4%B9%A6/"/>
    <id>https://whuichenggong.github.io/2024/12/28/%E7%9C%8B%E4%BA%86%E4%B8%80%E6%9C%AC%E4%B9%A6/</id>
    <published>2024-12-28T10:40:19.406Z</published>
    <updated>2024-12-29T06:29:09.636Z</updated>
    
    <content type="html"><![CDATA[<p>今天一下午的时间看了这本书，对我的感触很大，很有助于思考，对于一个问题的思考，一种问题不同的问法，产生不同的问题</p><p>文字游戏：一句话不同的停顿产生不同的问题</p><p>有些事情是不是简单的问题复杂化（这应该是普遍现象） 复杂的问题简单化（很少）</p><p>你是不是真的想要解决这问题？</p><p>追溯本源，从一个婴儿视角重新审视这个问题！</p><p>一生二，二生三，三生万物： 你对一个问题的解决（是否是真的解决？）一个问题的解决必然产生另一个问题的产生！</p><p>看看你是否能从一个问题的解决，来想到它产生了3个其他的问题？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天一下午的时间看了这本书，对我的感触很大，很有助于思考，对于一个问题的思考，一种问题不同的问法，产生不同的问题&lt;/p&gt;
&lt;p&gt;文字游戏：一句话不同的停顿产生不同的问题&lt;/p&gt;
&lt;p&gt;有些事情是不是简单的问题复杂化（这应该是普遍现象） 复杂的问题简单化（很少）&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="书籍" scheme="https://whuichenggong.github.io/categories/%E4%B9%A6%E7%B1%8D/"/>
    
    
    <category term="书籍" scheme="https://whuichenggong.github.io/tags/%E4%B9%A6%E7%B1%8D/"/>
    
    <category term="思考" scheme="https://whuichenggong.github.io/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>考试周</title>
    <link href="https://whuichenggong.github.io/2024/12/25/2024.12.25/"/>
    <id>https://whuichenggong.github.io/2024/12/25/2024.12.25/</id>
    <published>2024-12-25T09:39:46.979Z</published>
    <updated>2024-12-25T09:41:14.102Z</updated>
    
    <content type="html"><![CDATA[<p>最近考试好多啊，几乎没有了自己的时间，还要考驾照，在学校，一定要在最受规定的条件下，才能有自己的学习时间啊</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近考试好多啊，几乎没有了自己的时间，还要考驾照，在学校，一定要在最受规定的条件下，才能有自己的学习时间啊&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>新的笔记软件</title>
    <link href="https://whuichenggong.github.io/2024/12/23/%E8%BD%AC%E6%8D%A2%E4%B8%80%E4%B8%8B/"/>
    <id>https://whuichenggong.github.io/2024/12/23/%E8%BD%AC%E6%8D%A2%E4%B8%80%E4%B8%8B/</id>
    <published>2024-12-23T13:13:12.099Z</published>
    <updated>2024-12-23T13:14:15.920Z</updated>
    
    <content type="html"><![CDATA[<p>Obsidian 要成为我的笔记软件了！ 真的太强大了！ 我想用一种新的形式去更加有效的记录我的笔记！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Obsidian 要成为我的笔记软件了！ 真的太强大了！ 我想用一种新的形式去更加有效的记录我的笔记！&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>一位老哥的分享给了我一些启发</title>
    <link href="https://whuichenggong.github.io/2024/12/18/live3/"/>
    <id>https://whuichenggong.github.io/2024/12/18/live3/</id>
    <published>2024-12-18T12:43:19.542Z</published>
    <updated>2024-12-18T12:57:34.101Z</updated>
    
    <content type="html"><![CDATA[<p>学习方法：老哥的思维方式也给了我一些启发</p><p>以下是老哥的分享：</p><p>当知识点量大起来时, 我觉得”写作”的意义应该在于辅助思考</p><p>因为短时间内可能我们能记得很好, 但是对于长时间的庞大知识体系的学习, 就容易忘记一些分支内容 </p><p>所以第一步我做的是把长长的博客尽量拆解为小的讨论主题</p><p>作为”词条”存在</p><p>比如我写了个k8s主题的词条 写道”容器”这个词会自动链接到我之前写过的容器相关的内容  里面的内容是否符合当下我需要的定义  如果是, 那么可以知识复用  如果不是, 那么我需不需要创建新的词条来讨论这个主题<br>然后关联知识形成网络</p><p>比如一个使用mysql + reids搭建的系统, 即用到了mysql, 又用到了redis, 同时它本身还是个系统设计就会难以归类 </p><p>但是 一个文章可以同时带有mysql, redis, 系统设计三种tag  让知识形成网络！</p><p>先把书的标题提取出来 建立一个词条  然后去网上查, 这个东西包含哪些东西 然后去网上查, 这个东西包含哪些东西 等熟悉了基于零散信息的网络后  再去快速浏览权威书籍 迭代网络  </p><hr><p>听了老哥的分享！ 我觉得自己再生活中真的缺乏太多的思考了！什么事知道他困难，不想办法，应该去思考一些东西才能让东西变得更活！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习方法：老哥的思维方式也给了我一些启发&lt;/p&gt;
&lt;p&gt;以下是老哥的分享：&lt;/p&gt;
&lt;p&gt;当知识点量大起来时, 我觉得”写作”的意义应该在于辅助思考&lt;/p&gt;
&lt;p&gt;因为短时间内可能我们能记得很好, 但是对于长时间的庞大知识体系的学习, 就容易忘记一些分支内容 &lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>学习数据库</title>
    <link href="https://whuichenggong.github.io/2024/12/16/Database/"/>
    <id>https://whuichenggong.github.io/2024/12/16/Database/</id>
    <published>2024-12-16T01:12:34.566Z</published>
    <updated>2024-12-20T11:33:22.632Z</updated>
    
    <content type="html"><![CDATA[<hr><p>参考书籍： 数据库设计</p><hr><p>我先从事务入手：</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p><strong>概念</strong> ： 与单个用户或者程序执行，完成读取或者更新数据库内容的一个或一串操作</p><p>应用程序的一次执行就是一个事务或者多个事务</p><p>示例：</p><p>简单事务： 更新x员工的工资（涉及：数据库的读和写，和非数据库操作）</p><p>复杂事务：删除x的员工记录，并把x员工的事务交付给其他人去做。 （过程中若并非所有的操作都被执行，那么数据库的引用完整性将遭到破坏）（数据库也处于不一致状态）</p><p>尽管一致性暂时遭到破坏，但是数据库总是可以从一种一致状态转换到另一种一致的状态</p><h3 id="数据库最终的结果"><a href="#数据库最终的结果" class="headerlink" title="数据库最终的结果"></a>数据库最终的结果</h3><ol><li>COMMIT：执行成功，事务最终被提交 （数据库也达到了一种新的状态）</li><li>ABORTED：事务没有执行成功 （事务被撤销）则数据库必须要还原事务开始之前的一致状态</li><li>已经提交的事务不能被撤销，只能通过（补偿事务）进行覆盖 消除事务产生的影响</li><li>DBMS将在程序正确结束后自动执行COMMIT操作，若不能成功执行则 ROBACK</li><li>PARTIALLY COMITTED：若在最后一条语句被执行时产生了 破坏了可串行化或违反了完整约束 因此事务必须被撤销 或者系统出现故障，事务更新的事务没有被安全的写到二级存储设备上（部分提交） 以上两种情况最终都会进入</li><li>FAILED（失败状态） 事务无法被提交，或者事务处于ACTIVE状态就被撤销 则 处于FAILED状态</li></ol><h3 id="事务性质"><a href="#事务性质" class="headerlink" title="事务性质"></a>事务性质</h3><p>ACID</p><ol><li>原子性：</li><li>一致性：</li><li>隔离性：</li><li>持久性：</li></ol><p>事务的隔离级别<br>事务隔离级别控制了事务之间的可见性和并发行为。常见的隔离级别包括：</p><ul><li>读未提交（Read Uncommitted）：在这个隔离级别下，一个事务可以读取其他事务尚未提交的数据。这可能导致脏读（读取了未提交的数据）、不可重复读（同一查询在事务执行期间返回不同结果）和幻读（事务在同一查询中看到不同的数据行）等问题。读未提交的隔离级别最不严格，可能会引发数据不一致问题</li><li>读已提交（Read Committed）：在这个隔离级别下，一个事务只能读取已经提交的数据，避免了脏读问题。但是，不可重复读和幻读问题仍然可能出现。因为其他事务可能在事务进行期间提交新的数据，导致不同时间点的查询结果不一致。</li><li>可重复读（Repeatable Read）：可重复读隔离级别确保在同一事务内，同一个查询的结果保持一致。这意味着一个事务中的查询不会受到其他事务的修改影响。这可以防止脏读和不可重复读问题，但幻读问题仍然可能出现，因为其他事务可能插入新数据，导致新数据行的出现。</li><li>串行化（Serializable）：串行化是最严格的隔离级别，它确保每个事务都在独立的时间段内执行，防止了并发问题。事务按照顺序一个接一个地执行，这可以解决脏读、不可重复读和幻读问题。然而，串行化可能会对性能产生较大的影响，因为事务需要依次执行。</li></ul><p>事务的隔离级别可以解决脏读、幻读、不可重复读的问题。</p><ol><li>脏读： 脏读指的是在一个事务中读取了另一个事务未提交的数据。假设事务 A 修改了某一行数据，但还没有提交。同时，事务 B 尝试读取了事务 A 修改的数据。如果事务 A 最终回滚了，那么事务 B 读取的数据就是不存在的，这就是脏读。脏读会导致不准确的数据展示，因为<strong>读取的数据可能是临时的未经验证的。</strong>、</li><li>不可重复读：不可重复读是指在同一个事务内，多次读取同一数据时，得到不同的结果。这可能是因为在事务执行期间，其他事务修改了数据。例如，事务 A 在读取某一行数据后，事务 B 修改了这行数据，并提交了。现在事务 A 再次读取相同的数据，注重数据：<strong>发现数据已经不同了</strong>，造成了不一致的现象。</li><li>幻读： 幻读是指在同一个事务内，多次查询同一范围的数据时，得到不同的结果。这与不可重复读类似，但幻读关注的是数据的数量变化。例如，事务 A 在查询某个范围内的所有数据时，事务 B 插入了新数据，并提交了。现在事务 A 再次查询同一范围的数据，注重：<strong>发现数据行的数量增加了</strong>，这就是幻读。</li></ol><hr><p>22.2 并发控制 </p><p>讲解了数据库中的一些问题 幻读等</p><p>[点击这里查看PDF文件] (<a href="https://github.com/Whuichenggong/Knowledge-network/blob/main/docs/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BD%91%E7%BB%9C.pdf">https://github.com/Whuichenggong/Knowledge-network/blob/main/docs/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BD%91%E7%BB%9C.pdf</a>)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;参考书籍： 数据库设计&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我先从事务入手：&lt;/p&gt;
&lt;h2 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; title=&quot;事务&quot;&gt;&lt;/a&gt;事务&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;概念&lt;/strong&gt; ： 与单个</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于我学习的一些资源和方法</title>
    <link href="https://whuichenggong.github.io/2024/12/15/resource/"/>
    <id>https://whuichenggong.github.io/2024/12/15/resource/</id>
    <published>2024-12-15T07:45:03.995Z</published>
    <updated>2024-12-15T07:45:24.392Z</updated>
    
    <content type="html"><![CDATA[<p>兄弟，我理解你的心态，觉得实践的收获更直观，看书反而有点慢。但实际上，看书和实践结合，效果会倍增。下面我不仅推荐优质资源，还会分享高效阅读的方法，帮你更好地平衡学习时间。</p><hr><h3 id="学习资料推荐"><a href="#学习资料推荐" class="headerlink" title="学习资料推荐"></a><strong>学习资料推荐</strong></h3><h4 id="1-数据库相关"><a href="#1-数据库相关" class="headerlink" title="1. 数据库相关"></a><strong>1. 数据库相关</strong></h4><ul><li><strong>书籍</strong>：《高性能 MySQL》<ul><li>重点阅读：索引优化、事务机制、查询优化。</li><li><strong>免费在线教程</strong>：<ul><li><a href="https://www.w3schools.com/sql/">SQL 教程（w3schools）</a></li><li><a href="https://dev.mysql.com/doc/">MySQL 官方文档</a></li></ul></li></ul></li></ul><h4 id="2-计算机网络"><a href="#2-计算机网络" class="headerlink" title="2. 计算机网络"></a><strong>2. 计算机网络</strong></h4><ul><li><strong>书籍</strong>：《计算机网络：自顶向下方法》或《图解HTTP》<ul><li>重点章节：HTTP、TCP&#x2F;IP、DNS、HTTPS。</li><li><strong>免费资源</strong>：<ul><li><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1030595307488672">HTTP 协议详解</a></li><li><a href="https://www.wireshark.org/">Wireshark 网络分析教程</a></li></ul></li></ul></li></ul><h4 id="3-操作系统"><a href="#3-操作系统" class="headerlink" title="3. 操作系统"></a><strong>3. 操作系统</strong></h4><ul><li><strong>书籍</strong>：《现代操作系统》<ul><li>重点章节：进程、线程、同步、内存管理。</li><li><strong>免费资源</strong>：<ul><li><a href="https://pages.cs.wisc.edu/~remzi/OSTEP/">Operating Systems: Three Easy Pieces</a></li><li><a href="https://www.linuxfoundation.org/">Linux 操作系统入门</a></li></ul></li></ul></li></ul><h4 id="4-系统设计"><a href="#4-系统设计" class="headerlink" title="4. 系统设计"></a><strong>4. 系统设计</strong></h4><ul><li><strong>书籍</strong>：《系统设计入门》（Grokking the System Design Interview）<ul><li>重点学习：缓存、负载均衡、限流。</li><li><strong>博客</strong>：<ul><li><a href="https://www.educative.io/courses/grokking-the-system-design-interview">系统设计基础</a></li></ul></li></ul></li></ul><h4 id="5-Redis"><a href="#5-Redis" class="headerlink" title="5. Redis"></a><strong>5. Redis</strong></h4><ul><li><strong>书籍</strong>：《Redis 实战》<ul><li>重点章节：缓存机制、分布式锁。</li><li><strong>免费资源</strong>：<ul><li><a href="https://redis.io/docs/">Redis 官方文档</a></li></ul></li></ul></li></ul><h4 id="6-算法与数据结构"><a href="#6-算法与数据结构" class="headerlink" title="6. 算法与数据结构"></a><strong>6. 算法与数据结构</strong></h4><ul><li><strong>书籍</strong>：《算法（第4版）》或《编程珠玑》<ul><li>重点章节：常用数据结构（栈、队列、二叉树）、动态规划。</li><li><strong>网站</strong>：<ul><li><a href="https://leetcode.com/">LeetCode 官方</a></li><li><a href="https://visualgo.net/">VisuAlgo（算法可视化）</a></li></ul></li></ul></li></ul><hr><h3 id="高效看书方法"><a href="#高效看书方法" class="headerlink" title="高效看书方法"></a><strong>高效看书方法</strong></h3><h4 id="1-目的导向阅读"><a href="#1-目的导向阅读" class="headerlink" title="1. 目的导向阅读"></a><strong>1. 目的导向阅读</strong></h4><ul><li><strong>明确目标</strong>：每次看书前，明确你要解决的问题。比如：<ul><li>“我需要理解事务是怎么实现的” → 阅读事务相关章节，跳过其他部分。</li><li>“我需要掌握 TCP 的连接过程” → 只看 TCP 的工作原理。</li></ul></li></ul><h4 id="2-略读和精读结合"><a href="#2-略读和精读结合" class="headerlink" title="2. 略读和精读结合"></a><strong>2. 略读和精读结合</strong></h4><ul><li><strong>略读</strong>：先快速翻阅目录和每章的开头，总结书的主要内容。</li><li><strong>精读</strong>：挑选与项目或刷题直接相关的部分深入看，配合做笔记和练习。</li></ul><h4 id="3-配合实践"><a href="#3-配合实践" class="headerlink" title="3. 配合实践"></a><strong>3. 配合实践</strong></h4><ul><li><strong>边学边做</strong>：看完书中某个知识点，立即在项目或代码中实现。<ul><li>例子：学完 Redis 的分布式锁，马上在银行项目中添加。</li></ul></li><li><strong>用书作为工具</strong>：书可以成为你的“随手参考”，遇到不懂的概念再翻阅相关章节，而不必一次性啃完。</li></ul><h4 id="4-输出内容"><a href="#4-输出内容" class="headerlink" title="4. 输出内容"></a><strong>4. 输出内容</strong></h4><ul><li><strong>写笔记</strong>：总结书中学到的知识，用自己的语言重新描述。</li><li><strong>录制分享</strong>：试着用 3 分钟向别人讲解你刚学的内容，加深记忆。</li></ul><h4 id="5-番茄工作法"><a href="#5-番茄工作法" class="headerlink" title="5. 番茄工作法"></a><strong>5. 番茄工作法</strong></h4><ul><li>每次阅读 25 分钟后，花 5 分钟总结这段时间的收获，然后休息片刻。效率会提升很多。</li></ul><hr><h3 id="实践与看书的时间分配"><a href="#实践与看书的时间分配" class="headerlink" title="实践与看书的时间分配"></a><strong>实践与看书的时间分配</strong></h3><ol><li><strong>每天早上&#x2F;晚上固定 1 小时阅读</strong>。<ul><li>比如：早上看《高性能 MySQL》，晚上看《计算机网络》。</li></ul></li><li><strong>实践时遇到问题，马上查书解决</strong>。<ul><li>例子：如果 Redis 配置缓存遇到问题，就查《Redis 实战》。</li></ul></li><li><strong>每周末专门安排 2 小时总结书中知识点，结合项目整理成笔记</strong>。</li></ol><hr><p>这样安排既能保持实践的节奏，又能让你从书中挖掘深层的原理。如果还有具体内容不理解，可以随时问我，我也可以帮你分解章节内容！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;兄弟，我理解你的心态，觉得实践的收获更直观，看书反而有点慢。但实际上，看书和实践结合，效果会倍增。下面我不仅推荐优质资源，还会分享高效阅读的方法，帮你更好地平衡学习时间。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;学习资料推荐&quot;&gt;&lt;a href=&quot;#学习资料推荐&quot; class=&quot;h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>聊聊最近</title>
    <link href="https://whuichenggong.github.io/2024/12/12/current/"/>
    <id>https://whuichenggong.github.io/2024/12/12/current/</id>
    <published>2024-12-12T12:57:12.010Z</published>
    <updated>2024-12-23T13:14:15.914Z</updated>
    
    <content type="html"><![CDATA[<p>最近的日子在想着达到就业的水平，不断地提升额，嗯然后今天手机掉水里了，烘干24小时，看看能不能复活吧，突然觉得之前手机不是那么重要，回想起它占用<br>我的时间，好像都不是什么重要的事情，近期来，感觉是为了让自己舒服一点，白天学完，晚上回去就刷手机而且就是 12点 1点，恶性循环，本想着晚上回去看会<br>书，自己却暗示自己，学一天了，玩吧哈哈哈。好像都没做，但是确实没有那么重要，吃饭可以让同学帮我付，哈哈，还是得学习呢，反省一下，是不是你想要的太多了<br>而导致你很累，那种精神上的压迫自己，反思~</p><p>今天12.12日试着实现将单片机的数据传输到数据库中交互<br>先简单的使用按钮的高低电平0 1 实现交互试试看</p><p>后端服务代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/jackc/pgx/v4&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ButtonPress <span class="keyword">struct</span> &#123;</span><br><span class="line">DeviceID  <span class="type">string</span> <span class="string">`json:&quot;device_id&quot;`</span></span><br><span class="line">Button    <span class="type">int</span>    <span class="string">`json:&quot;button&quot;`</span></span><br><span class="line">Timestamp <span class="type">string</span> <span class="string">`json:&quot;timestamp&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">dbHost     = <span class="string">&quot;localhost&quot;</span></span><br><span class="line">dbPort     = <span class="number">5432</span></span><br><span class="line">dbUser     = <span class="string">&quot;root&quot;</span></span><br><span class="line">dbPassword = <span class="string">&quot;secret&quot;</span></span><br><span class="line">dbName     = <span class="string">&quot;data&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Set up the database connection</span></span><br><span class="line">connStr := fmt.Sprintf(<span class="string">&quot;postgresql://%s:%s@%s:%d/%s&quot;</span>, dbUser, dbPassword, dbHost, dbPort, dbName)</span><br><span class="line">conn, err := pgx.Connect(context.Background(), connStr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;Unable to connect to the database: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close(context.Background())</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set up the HTTP server</span></span><br><span class="line">http.HandleFunc(<span class="string">&quot;/receive&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r.Method != http.MethodPost &#123;</span><br><span class="line">http.Error(w, <span class="string">&quot;Only POST requests are supported&quot;</span>, http.StatusMethodNotAllowed)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data ButtonPress</span><br><span class="line"><span class="keyword">if</span> err := json.NewDecoder(r.Body).Decode(&amp;data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">http.Error(w, <span class="string">&quot;Invalid JSON format&quot;</span>, http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">&quot;Received data: %+v&quot;</span>, data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> data.Button == <span class="number">1</span> &#123;</span><br><span class="line"><span class="comment">// Store the data in the database</span></span><br><span class="line">query := <span class="string">&quot;INSERT INTO button_presses (device_id, button, timestamp) VALUES ($1, $2, $3)&quot;</span></span><br><span class="line">_, err := conn.Exec(context.Background(), query, data.DeviceID, data.Button, data.Timestamp)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">http.Error(w, <span class="string">&quot;Failed to store data in the database&quot;</span>, http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">log.Println(<span class="string">&quot;Data successfully stored in the database&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">w.WriteHeader(http.StatusOK)</span><br><span class="line">w.Write([]<span class="type">byte</span>(<span class="string">&quot;Data received and processed&quot;</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">log.Println(<span class="string">&quot;Starting server on 192.168.111.1:8080&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err := http.ListenAndServe(<span class="string">&quot;192.168.111.1:8080&quot;</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;Server failed: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是简单的实现</p><p>单片机端代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266HTTPClient.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* ssid = <span class="string">&quot;Your_SSID&quot;</span>;          <span class="comment">// Wi-Fi 名称</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* password = <span class="string">&quot;Your_PASSWORD&quot;</span>;  <span class="comment">// Wi-Fi 密码</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* serverUrl = <span class="string">&quot;http://8.222.186.212:8080/send&quot;</span>;  <span class="comment">// 后端服务器地址</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">115200</span>); <span class="comment">// 初始化串口</span></span><br><span class="line">  WiFi.begin(ssid, password);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 连接到 Wi-Fi</span></span><br><span class="line">  Serial.print(<span class="string">&quot;Connecting to Wi-Fi&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> (WiFi.status() != WL_CONNECTED) &#123;</span><br><span class="line">    delay(<span class="number">1000</span>);</span><br><span class="line">    Serial.print(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Serial.println(<span class="string">&quot;\nConnected to Wi-Fi&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (WiFi.status() == WL_CONNECTED) &#123;</span><br><span class="line">    HTTPClient http;</span><br><span class="line">    http.begin(serverUrl);   <span class="comment">// 设置服务器 URL</span></span><br><span class="line">    http.addHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>); <span class="comment">// 设置请求头</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例 JSON 数据</span></span><br><span class="line">    String jsonData = <span class="string">&quot;&#123;\&quot;sensor\&quot;: \&quot;temperature\&quot;, \&quot;value\&quot;: 25.5&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// POST 请求</span></span><br><span class="line">    <span class="type">int</span> httpResponseCode = http.POST(jsonData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查响应状态</span></span><br><span class="line">    <span class="keyword">if</span> (httpResponseCode &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      String response = http.getString();</span><br><span class="line">      Serial.println(<span class="string">&quot;Response: &quot;</span> + response);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Serial.println(<span class="string">&quot;Error on sending POST: &quot;</span> + String(httpResponseCode));</span><br><span class="line">    &#125;</span><br><span class="line">    http.end(); <span class="comment">// 关闭连接</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.println(<span class="string">&quot;Wi-Fi not connected&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  delay(<span class="number">5000</span>); <span class="comment">// 每 5 秒发送一次数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>HTTP就是那么的神奇</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近的日子在想着达到就业的水平，不断地提升额，嗯然后今天手机掉水里了，烘干24小时，看看能不能复活吧，突然觉得之前手机不是那么重要，回想起它占用&lt;br&gt;我的时间，好像都不是什么重要的事情，近期来，感觉是为了让自己舒服一点，白天学完，晚上回去就刷手机而且就是 12点 1点，恶</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>分布式系统学习</title>
    <link href="https://whuichenggong.github.io/2024/12/09/Distributed/"/>
    <id>https://whuichenggong.github.io/2024/12/09/Distributed/</id>
    <published>2024-12-09T12:53:55.062Z</published>
    <updated>2024-12-09T13:14:34.908Z</updated>
    
    <content type="html"><![CDATA[<p><code>go build -buildmode=plugin ../mrapps/wc.go</code><br>这个指令是什么意思 :</p><p>这个命令的作用是编译 ..&#x2F;mrapps&#x2F;wc.go 文件，并将其生成一个 Go 插件文件。生成的插件文件通常是一个 .so（共享库文件）文件，它可以在运行时被其他 Go 程序通过 plugin 包加载和调用。</p><p>例如：</p><p>你可以在主程序中使用 plugin 包动态加载 wc.so 插件，并调用插件中的函数。</p><p><code>go run mrsequential.go wc.so pg*.txt：</code></p><p>go run：用于编译并运行 Go 程序。它会在内存中临时编译指定的 Go 文件，并立即执行。</p><p>mrsequential.go：这是要执行的 Go 源文件，Go 编译器会先编译这个文件并运行它。这个文件应该包含 main 函数，通常是程序的入口点。</p><p>wc.so：这是一个 Go 插件文件（共享库）。它通常是通过 go build -buildmode&#x3D;plugin 命令生成的。该文件包含 Go 代码，可能定义了一个插件接口，在运行时可以被主程序（mrsequential.go）动态加载和调用。wc.so 可能提供某些功能，mrsequential.go 将加载并使用这些功能。</p><p>pg*.txt：这是一个通配符表达式，表示所有以 pg 开头，后面跟任意字符，且以 .txt 结尾的文件。例如，pg1.txt, pg42.txt, pgfile.txt 都会被匹配并作为参数传递给程序。</p><p><code>more mr-out-0</code> 将会输出很多文本 这是因为：</p><p>mrsequential.go 将其输出保留在文件 mr-out-0 中。输入来自名为 pg-xxx.txt 的文本文件</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;go build -buildmode=plugin ../mrapps/wc.go&lt;/code&gt;&lt;br&gt;这个指令是什么意思 :&lt;/p&gt;
&lt;p&gt;这个命令的作用是编译 ..&amp;#x2F;mrapps&amp;#x2F;wc.go 文件，并将其生成一个 Go 插件文件。生成的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数据库学习</title>
    <link href="https://whuichenggong.github.io/2024/12/08/postgres/"/>
    <id>https://whuichenggong.github.io/2024/12/08/postgres/</id>
    <published>2024-12-08T10:47:54.793Z</published>
    <updated>2024-12-08T10:52:44.696Z</updated>
    
    <content type="html"><![CDATA[<p>学习文档：</p><p><a href="https://www.rockdata.net/zh-cn/tutorial/toc/">https://www.rockdata.net/zh-cn/tutorial/toc/</a></p><p>WHERE 语句如何使用</p><p><a href="https://www.rockdata.net/zh-cn/tutorial/dml-where/%E3%80%81">https://www.rockdata.net/zh-cn/tutorial/dml-where/、</a></p><p>总结来说： 放入condition，返回结果只会返回符合condition条件的， 搭配 AND OR IN LIKE等使用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.rockdata.net/zh-cn/tutorial/toc/&quot;&gt;https://www.rockdata.net/zh-cn/tutorial/toc/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;WHERE 语句如何使用&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>为什么别人写项目知道用什么？</title>
    <link href="https://whuichenggong.github.io/2024/12/07/confusion/"/>
    <id>https://whuichenggong.github.io/2024/12/07/confusion/</id>
    <published>2024-12-07T09:19:23.441Z</published>
    <updated>2024-12-07T09:20:17.605Z</updated>
    
    <content type="html"><![CDATA[<p>同样来自GPT的回答：</p><p>你的疑惑非常好！许多人在学习编程时都会有类似的感受，尤其是在学习阶段，看到博主轻松选择某些包或者工具来解决问题时，会觉得他们似乎“无所不知”。事实上，这背后是<strong>经验</strong>和<strong>积累</strong>的结果。以下几点可以帮助你理解和逐步建立这种能力：</p><hr><h3 id="1-经验的积累"><a href="#1-经验的积累" class="headerlink" title="1. 经验的积累"></a><strong>1. 经验的积累</strong></h3><ul><li><strong>博主的背景</strong>：他们可能已经解决过类似问题，因此知道哪些包是高效的选择。这是经验的体现。</li><li><strong>类比</strong>：就像一位厨师在做菜时，很容易知道用什么调料，而新手可能需要查配方。</li></ul><h4 id="你可以这样做："><a href="#你可以这样做：" class="headerlink" title="你可以这样做："></a><strong>你可以这样做：</strong></h4><ul><li><strong>多看、多学</strong>：通过模仿优秀项目和学习文档，积累对常用库和框架的了解。</li><li><strong>练习总结</strong>：每次解决问题后，记录用到的包和方法，慢慢形成自己的“工具箱”。</li></ul><hr><h3 id="2-文档与生态"><a href="#2-文档与生态" class="headerlink" title="2. 文档与生态"></a><strong>2. 文档与生态</strong></h3><ul><li><p><strong>语言和框架的生态</strong>：每种语言或框架都有一些社区公认的、<strong>常用的库</strong>。</p><ul><li>比如，Go 语言处理配置时，大家常用 <code>viper</code> 或 <code>yaml</code>。</li><li>HTTP 请求：<code>net/http</code>（原生）或社区的 <code>gin</code>（框架）。</li></ul></li><li><p><strong>社区推荐</strong>：很多库被推荐使用，是因为它们：</p><ol><li><strong>功能齐全</strong>。</li><li><strong>易于使用</strong>。</li><li><strong>社区活跃</strong>，有长期维护。</li></ol></li></ul><h4 id="你可以这样做：-1"><a href="#你可以这样做：-1" class="headerlink" title="你可以这样做："></a><strong>你可以这样做：</strong></h4><ul><li><strong>了解生态</strong>：多逛 GitHub、Go 的标准库文档以及社区资源（比如 Go 的官方博客）。</li><li><strong>参考优秀代码</strong>：通过学习开源项目，你可以快速了解哪些包解决了哪些问题。</li></ul><hr><h3 id="3-搜索能力"><a href="#3-搜索能力" class="headerlink" title="3. 搜索能力"></a><strong>3. 搜索能力</strong></h3><ul><li><p>很多开发者的知识并不是“记住的”，而是“查到的”。他们遇到问题时，会：</p><ol><li><strong>搜索问题</strong>：查找类似场景的解决方案。</li><li><strong>评估方案</strong>：根据实际需求选择合适的库或框架。</li></ol></li><li><p>搜索时的技巧：</p><ul><li>用精准关键词，比如“Go JWT authentication package”。</li><li>看社区推荐，比如 Stack Overflow、Reddit、GitHub 等。</li></ul></li></ul><h4 id="你可以这样做：-2"><a href="#你可以这样做：-2" class="headerlink" title="你可以这样做："></a><strong>你可以这样做：</strong></h4><ul><li>当不知道用哪个包时，搜索类似场景的关键词，看看其他开发者用了什么库。</li><li>慢慢熟悉常用的社区推荐来源，比如：<ul><li><a href="https://awesome-go.com/">Awesome Go</a>：列出了 Go 的优秀库。</li><li><a href="https://pkg.go.dev/">Go Packages</a>：Go 的官方包文档和搜索平台。</li></ul></li></ul><hr><h3 id="4-理解需求，选择工具"><a href="#4-理解需求，选择工具" class="headerlink" title="4. 理解需求，选择工具"></a><strong>4. 理解需求，选择工具</strong></h3><ul><li>博主并不是“盲选”包，而是基于需求选工具。<ul><li>例如：需要读取配置文件，就会选择支持多种格式的 <code>viper</code>。</li><li>需要快速搭建 Web 服务框架，就会用 <code>gin</code> 或 <code>echo</code>。</li></ul></li></ul><h4 id="你可以这样做：-3"><a href="#你可以这样做：-3" class="headerlink" title="你可以这样做："></a><strong>你可以这样做：</strong></h4><ul><li>学会分析问题：问自己——“这个问题需要解决什么？”“有没有原生支持？”</li><li>学会看库文档：<ul><li>比如，在 GitHub 项目中，看 ReadMe 和示例代码，理解库的功能。</li></ul></li></ul><hr><h3 id="5-你的问题如何转换为实践"><a href="#5-你的问题如何转换为实践" class="headerlink" title="5. 你的问题如何转换为实践"></a><strong>5. 你的问题如何转换为实践</strong></h3><ol><li><strong>明确目标</strong>：先理解你要解决的问题，比如“实现一个 JWT 登录功能”。</li><li><strong>学习思路</strong>：看看博主怎么解决的，模仿过程并分析他们选择的工具是否合理。</li><li><strong>尝试自己实现</strong>：不要依赖博主的方案，尝试用其他库或者原生代码实现。</li></ol><hr><h3 id="总结：知识的形成是一个积累过程"><a href="#总结：知识的形成是一个积累过程" class="headerlink" title="总结：知识的形成是一个积累过程"></a><strong>总结：知识的形成是一个积累过程</strong></h3><p>博主看似“知道一切”，实际上是基于：</p><ol><li><strong>经验积累</strong>：长期的项目经验让他们知道常用包。</li><li><strong>良好工具链</strong>：对语言生态了解，知道优秀的社区推荐。</li><li><strong>高效搜索</strong>：遇到新问题时，他们可以快速找到解决方案。</li></ol><p><strong>行动建议</strong>：</p><ul><li>多积累项目经验，模仿优秀代码，逐渐形成自己的“工具箱”。</li><li>学会分解问题和尝试不同工具，在实践中找到更适合的解决方案。<br>坚持下去，你也会越来越“有经验”！ 😊</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;同样来自GPT的回答：&lt;/p&gt;
&lt;p&gt;你的疑惑非常好！许多人在学习编程时都会有类似的感受，尤其是在学习阶段，看到博主轻松选择某些包或者工具来解决问题时，会觉得他们似乎“无所不知”。事实上，这背后是&lt;strong&gt;经验&lt;/strong&gt;和&lt;strong&gt;积累&lt;/strong&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>理解鉴权，权限等名词的区别</title>
    <link href="https://whuichenggong.github.io/2024/12/07/authority/"/>
    <id>https://whuichenggong.github.io/2024/12/07/authority/</id>
    <published>2024-12-07T09:13:14.230Z</published>
    <updated>2024-12-07T09:15:05.767Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GPT很好的给出了答案"><a href="#GPT很好的给出了答案" class="headerlink" title="GPT很好的给出了答案"></a>GPT很好的给出了答案</h2><p>问：</p><p>用户通过了身份验证，但是不具有访问资源所需的权限。 这句话我应该怎么理解，我还有的疑惑是Cookie，Token，鉴权，权限等这几个名词都是什么意思，我现在对他们的理解有点模糊</p><p>答：</p><p>这些概念是 Web 安全和权限管理的核心部分。让我们分两步：<strong>先理解句子的含义</strong>，再深入解析相关概念（Cookie、Token、鉴权、权限等）。</p><hr><h3 id="1-句子的含义"><a href="#1-句子的含义" class="headerlink" title="1. 句子的含义"></a><strong>1. 句子的含义</strong></h3><blockquote><p><strong>“用户通过了身份验证，但是不具有访问资源所需的权限。”</strong></p></blockquote><p>这句话分为两个阶段：</p><ol><li><p><strong>身份验证</strong>（Authentication）：系统确认了用户的身份（比如你用正确的用户名和密码登录）。</p><ul><li><strong>说明</strong>：你确实是你声称的那个人。</li><li><strong>类比</strong>：这就像进入公司时，你刷卡证明你是公司的员工。</li></ul></li><li><p><strong>权限检查</strong>（Authorization）：系统检查用户是否有权访问某些特定资源。</p><ul><li><strong>说明</strong>：通过身份验证并不代表你可以访问所有东西。例如：<ul><li>普通用户可能无法访问管理员界面。</li><li>销售部门员工可能无法查看财务报表。</li></ul></li><li><strong>类比</strong>：在公司内部，即使你刷卡进门，也可能需要额外权限才能进入某些区域（比如机房）。</li></ul></li></ol><p><strong>总结</strong>：身份验证是“你是谁”，权限检查是“你是否被允许做某件事”。通过身份验证 ≠ 获得所有权限。</p><hr><h3 id="2-概念解析"><a href="#2-概念解析" class="headerlink" title="2. 概念解析"></a><strong>2. 概念解析</strong></h3><h4 id="1-Cookie"><a href="#1-Cookie" class="headerlink" title="(1) Cookie"></a><strong>(1) Cookie</strong></h4><ul><li><strong>定义</strong>：一种小型数据，存储在用户浏览器中，由服务器生成，用来记录用户的会话状态或其他信息。</li><li><strong>用途</strong>：<ol><li><strong>会话管理</strong>：比如记录你是否已登录。</li><li><strong>个性化</strong>：比如保存语言设置。</li><li><strong>追踪</strong>：用于广告和分析。</li></ol></li></ul><p><strong>类比</strong>：Cookie 就像一个身份证明牌，浏览器每次请求时带上它，服务器根据这个证明牌识别你的身份。</p><hr><h4 id="2-Token"><a href="#2-Token" class="headerlink" title="(2) Token"></a><strong>(2) Token</strong></h4><ul><li><strong>定义</strong>：类似于数字化的通行证，通常由服务器生成并发放给用户，用户每次请求时带上 Token，证明自己已通过身份验证。</li><li><strong>常见类型</strong>：<ul><li>**JWT (JSON Web Token)**：一种格式化的 Token，常用于现代 Web 应用。</li></ul></li></ul><p><strong>区别于 Cookie</strong>：</p><ul><li>Cookie 是浏览器特有的存储机制，而 Token 是一个通用的凭证。</li><li>Cookie 通常自动附加在请求中，Token 需要开发者手动附加（如放在请求头中）。</li></ul><p><strong>类比</strong>：Token 就像一个“通行证”，你需要用它向服务器证明你有访问权限。</p><hr><h4 id="3-鉴权"><a href="#3-鉴权" class="headerlink" title="(3) 鉴权"></a><strong>(3) 鉴权</strong></h4><ul><li><strong>定义</strong>：确定用户是否具有访问资源或执行操作的权限。</li><li><strong>过程</strong>：<ul><li>用户发起请求时，系统会验证用户提供的凭证（比如 Token 或 Cookie）。</li><li>系统根据用户的角色、组或策略，判断是否允许操作。</li></ul></li></ul><p><strong>类比</strong>：鉴权就像安保检查，你拿着门卡，安保会检查你的权限，决定你是否可以进入某些区域。</p><hr><h4 id="4-权限"><a href="#4-权限" class="headerlink" title="(4) 权限"></a><strong>(4) 权限</strong></h4><ul><li><strong>定义</strong>：指用户被允许执行的操作范围或访问的资源类型。</li><li><strong>示例</strong>：<ul><li>读权限：允许查看文件内容。</li><li>写权限：允许修改文件内容。</li><li>管理权限：允许管理其他用户。</li></ul></li></ul><p><strong>类比</strong>：权限就像不同的钥匙，钥匙决定了你能打开哪些门。</p><hr><h3 id="3-总结关系和区别"><a href="#3-总结关系和区别" class="headerlink" title="3. 总结关系和区别"></a><strong>3. 总结关系和区别</strong></h3><ul><li><strong>Cookie</strong>：存储用户会话信息，让服务器识别用户是谁。</li><li><strong>Token</strong>：携带用户身份信息，用于证明用户已通过身份验证。</li><li><strong>鉴权</strong>：判断用户是否有权访问特定资源。</li><li><strong>权限</strong>：用户可以做的事情或访问的资源范围。</li></ul><hr><h3 id="4-一个完整的例子"><a href="#4-一个完整的例子" class="headerlink" title="4. 一个完整的例子"></a><strong>4. 一个完整的例子</strong></h3><ol><li><p>用户访问网站，输入用户名和密码（<strong>身份验证</strong>）。</p><ul><li>服务器验证用户名和密码正确，生成一个 Token 返回给用户。</li><li>Token 或者对应的 Session ID 会存储在用户的 Cookie 中。</li></ul></li><li><p>用户请求资源时，浏览器自动带上 Cookie（或你自己带上 Token）。</p><ul><li>服务器接收到请求后，验证 Token 或 Cookie 的合法性。</li></ul></li><li><p>服务器检查权限（<strong>鉴权</strong>）。</p><ul><li>如果你有权限，资源返回给你。</li><li>如果你没有权限，服务器返回 “403 Forbidden”。</li></ul></li></ol><p>你可以将这些过程看成一道流水线：<strong>身份验证 -&gt; 带凭证发请求 -&gt; 权限检查 -&gt; 返回结果</strong>。</p><p>就是我是 赵忠鹤 检查 赵忠鹤是不是有权限访问这个内容，大体就是这个意思</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;GPT很好的给出了答案&quot;&gt;&lt;a href=&quot;#GPT很好的给出了答案&quot; class=&quot;headerlink&quot; title=&quot;GPT很好的给出了答案&quot;&gt;&lt;/a&gt;GPT很好的给出了答案&lt;/h2&gt;&lt;p&gt;问：&lt;/p&gt;
&lt;p&gt;用户通过了身份验证，但是不具有访问资源所需的权限</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>json的序列化与反序列化</title>
    <link href="https://whuichenggong.github.io/2024/12/06/serialize/"/>
    <id>https://whuichenggong.github.io/2024/12/06/serialize/</id>
    <published>2024-12-06T09:21:57.665Z</published>
    <updated>2024-12-06T09:52:48.370Z</updated>
    
    <content type="html"><![CDATA[<p>序列化：将 Go 中的结构体、切片、map 等数据结构转换为 JSON 格式的字符串。</p><p>作用：方便数据在网络传输、文件保存等情境中使用。</p><p>反序列化：将 JSON 格式的字符串转换为 Go 的数据结构。</p><p>作用：方便从 JSON 中提取数据并在程序中使用。</p><p>JSON<br>{<br>“”： “”，<br>“”： “”，<br>“”： “”<br>}</p><p>Go中 使用 Marshal Unmarshal 进行序列化和反序列化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">    Age  <span class="type">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := Person&#123;Name: <span class="string">&quot;Alice&quot;</span>, Age: <span class="number">25</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化为 JSON</span></span><br><span class="line">    jsonData, err := json.Marshal(p)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Error:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="type">string</span>(jsonData)) <span class="comment">// 输出: &#123;&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:25&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">    Age  <span class="type">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    jsonData := <span class="string">`&#123;&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:25&#125;`</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> p Person</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化为结构体</span></span><br><span class="line">    err := json.Unmarshal([]<span class="type">byte</span>(jsonData), &amp;p)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Error:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(p.Name, p.Age) <span class="comment">// 输出: Alice 25</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>类比一下进程间管道通信：<br>在父子进程使用管道进行通信时，数据通常以字节流的形式传输。<br>要传递复杂数据结构，需要将数据转换为字节流（序列化），并在另一端解析回来（反序列化）。</p><p>GO中实现 字符进程通信</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">    Content <span class="type">string</span> <span class="string">`json:&quot;content&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r, w, err := os.Pipe() <span class="comment">// 创建管道</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Error creating pipe:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> os.Getenv(<span class="string">&quot;IS_CHILD&quot;</span>) == <span class="string">&quot;1&quot;</span> &#123;</span><br><span class="line">        <span class="comment">// 子进程逻辑</span></span><br><span class="line">        r.Close() <span class="comment">// 关闭写端</span></span><br><span class="line">        <span class="keyword">var</span> msg Message</span><br><span class="line">        decoder := json.NewDecoder(r)</span><br><span class="line">        <span class="keyword">if</span> err := decoder.Decode(&amp;msg); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;Error decoding:&quot;</span>, err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Child received:&quot;</span>, msg.Content)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程逻辑</span></span><br><span class="line">        w.Close() <span class="comment">// 关闭读端</span></span><br><span class="line">        cmd := os.Exec(os.Args[<span class="number">0</span>], os.Args, os.Environ())</span><br><span class="line">        cmd.Env = <span class="built_in">append</span>(os.Environ(), <span class="string">&quot;IS_CHILD=1&quot;</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            encoder := json.NewEncoder(w)</span><br><span class="line">            encoder.Encode(Message&#123;Content: <span class="string">&quot;Hello, Child!&quot;</span>&#125;)</span><br><span class="line">        &#125;()</span><br><span class="line">        cmd.Wait()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;序列化：将 Go 中的结构体、切片、map 等数据结构转换为 JSON 格式的字符串。&lt;/p&gt;
&lt;p&gt;作用：方便数据在网络传输、文件保存等情境中使用。&lt;/p&gt;
&lt;p&gt;反序列化：将 JSON 格式的字符串转换为 Go 的数据结构。&lt;/p&gt;
&lt;p&gt;作用：方便从 JSON 中提取</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Go语法学习</title>
    <link href="https://whuichenggong.github.io/2024/12/02/Go_Program/"/>
    <id>https://whuichenggong.github.io/2024/12/02/Go_Program/</id>
    <published>2024-12-02T06:10:19.416Z</published>
    <updated>2024-12-16T02:39:31.613Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">whatAmI := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> t := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;I&#x27;m a bool&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;I&#x27;m an int&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Don&#x27;t know type %T\n&quot;</span>, t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">whatAmI(<span class="literal">true</span>)</span><br><span class="line">whatAmI(<span class="number">1</span>)</span><br><span class="line">whatAmI(<span class="string">&quot;hey&quot;</span>)</span><br></pre></td></tr></table></figure><p>这是一个函数whatAmI，它接受一个interface{}类型的参数。interface{}是 Go 语言中的一种空接口，可以存储任何类型的值。<br>这个switch语句实际上是一个类型switch，它检查接口变量i的具体类型，而不是它的值。根据i的类型，switch将执行不同的case分支。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If you specify the index with `:`, the elements in</span></span><br><span class="line"><span class="comment">// between will be zeroed.</span></span><br><span class="line">b = [...]<span class="type">int</span>&#123;<span class="number">100</span>, <span class="number">3</span>: <span class="number">400</span>, <span class="number">500</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;idx:&quot;</span>, b)</span><br></pre></td></tr></table></figure><p>3: 400 指定了下标为 3 的位置的值是 400。<br>这意味着索引 1 和 2 的值将被初始化为 0（因为:操作符指定了一个新的下标，并初始化之前未指定的下标对应的元素为 0）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="type">string</span></span><br><span class="line">fmt.Println(<span class="string">&quot;uninit:&quot;</span>, s, s == <span class="literal">nil</span>, <span class="built_in">len</span>(s) == <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>uninit: [] true true</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">twoD := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">innerLen := i + <span class="number">1</span></span><br><span class="line">twoD[i] = <span class="built_in">make</span>([]<span class="type">int</span>, innerLen)</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; innerLen; j++ &#123;</span><br><span class="line">twoD[i][j] = i + j</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;2d: &quot;</span>, twoD)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2d:  [[0] [1 2] [2 3 4]]</p><p>12.3日</p><p>map操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   m[<span class="string">&quot;k1&quot;</span>] = <span class="number">7</span></span><br><span class="line">m[<span class="string">&quot;k2&quot;</span>] = <span class="number">13</span></span><br><span class="line">fmt.Println(<span class="string">&quot;map:&quot;</span>, m)</span><br><span class="line">fmt.Println(<span class="string">&quot;len:&quot;</span>, <span class="built_in">len</span>(m))</span><br><span class="line"><span class="comment">//clear(m)</span></span><br><span class="line">val, prs := m[<span class="string">&quot;k2&quot;</span>] <span class="comment">//k2的值， 一个是判断k2是否存在于m中的bool值</span></span><br><span class="line">fmt.Println(<span class="string">&quot;val：&quot;</span>, val, <span class="string">&quot;prs:&quot;</span>, prs)</span><br><span class="line">n := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;foo&quot;</span>: <span class="number">1</span>, <span class="string">&quot;bar&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;&quot;</span>, n)</span><br><span class="line"><span class="keyword">if</span> maps.Equal(n, n2) &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;n == n2&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用变长参数函数（variadic function），即可以接收任意数量参数的函数。<br>这里的 … 标记表示 nums 参数是可变长的，可以接收零个或多个 int 类型的参数</p><p>nums 被当作切片使用，可以进行切片相关的操作，例如使用 len(nums) 获取长度，或者用 range 遍历切片元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(nums ...<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Print(nums, <span class="string">&quot; &quot;</span>)</span><br><span class="line">total := <span class="number">0</span></span><br><span class="line"><span class="comment">// Within the function, the type of `nums` is</span></span><br><span class="line"><span class="comment">// equivalent to `[]int`. We can call `len(nums)`,</span></span><br><span class="line"><span class="comment">// iterate over it with `range`, etc.</span></span><br><span class="line"><span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">total += num</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(total)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Variadic functions can be called in the usual way</span></span><br><span class="line"><span class="comment">// with individual arguments.</span></span><br><span class="line">sum(<span class="number">1</span>)</span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// If you already have multiple args in a slice,</span></span><br><span class="line"><span class="comment">// apply them to a variadic function using</span></span><br><span class="line"><span class="comment">// `func(slice...)` like this.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种调用nums的方法使用 nums 切片，通过 sum(nums...) 的方式将切片中的每个元素作为单独的参数传递给 sum 函数。</span></span><br><span class="line">nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">sum(nums...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误示范</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allArticles</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">articles := Articles&#123;</span><br><span class="line">Title:   <span class="string">&quot;Test Title&quot;</span>,</span><br><span class="line">Desc:    <span class="string">&quot;Test Descrption&quot;</span>,</span><br><span class="line">Content: <span class="string">&quot;hello world&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;endpoint hit: allArticles&quot;</span>)</span><br><span class="line">json.NewEncoder(w).Encode(articles)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里的问题是 Articles 类型实际上是一个切片（[]Article），而你试图将一个单独的 Article 结构体实例赋值给 articles 变量。根据 Go 语言的语法，Articles 类型需要的是一个 Article 类型的切片。</p><p>要解决这个问题，你需要将 Article 实例放入一个切片中。可以将你的代码修改为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">articles := Articles&#123;</span><br><span class="line">&#123;</span><br><span class="line">Title:   <span class="string">&quot;Test Title&quot;</span>,</span><br><span class="line">Desc:    <span class="string">&quot;Test Descrption&quot;</span>,</span><br><span class="line">Content: <span class="string">&quot;hello world&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">CopyInsert</span><br><span class="line">这里的修改是把 Article 结构体实例用 &#123;&#125; 包围起来，表示这是一个切片中的一个元素。</span><br><span class="line"></span><br><span class="line">最终的 allArticles 函数应如下所示：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二种方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Article的实例</span></span><br><span class="line">    newArticle := Article&#123;</span><br><span class="line">        Title:   <span class="string">&quot;Test Title&quot;</span>,</span><br><span class="line">        Desc:    <span class="string">&quot;Test Description&quot;</span>,</span><br><span class="line">        Content: <span class="string">&quot;hello world&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建Articles切片并添加上面的实例</span></span><br><span class="line">    articles := Articles&#123;newArticle&#125;</span><br></pre></td></tr></table></figure><hr><p>go fmt </p><p>包的导入者将使用名称来引用其内容，因此包中的导出名称可以使用该事实来避免重复。 （不要使用 import . 表示法，它可以简化必须在正在测试的包外部运行的测试，但应该避免。）<br>例如，bufio 包中的缓冲读取器类型称为 Reader，而不是 BufReader，因为用户将其视为 bufio.Reader，这是一个清晰、简洁的名称。此外，由于导入的实体始终使用其包名称进行寻址，<br>因此 bufio.Reader 不会与 io.Reader 冲突。类似地，<br>创建ring.Ring新实例的函数（Go中构造函数的定义）通常被称为NewRing，但由于Ring是包导出的唯一类型，并且由于包被称为ring，所以它是称为“New”，包的客户端将其视为“ring.New”。使用包结构来帮助您选择好的名称。</p><p>另一个简短的例子是once.Do; Once.Do(setup) 读起来很好，<br>并且不会通过编写 Once.DoOrWaitUntilDone(setup) 来改进。长名称不会自动使内容更具可读性。有用的文档注释通常比超长的名称更有价值。</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intSeq</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    i := <span class="number">0</span> <span class="comment">// i 是一个局部变量，用于 intSeq 函数。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="comment">// 返回一个匿名函数，这个函数可以访问 intSeq 函数的局部变量 i。</span></span><br><span class="line">        i++    <span class="comment">// 每次调用这个匿名函数时，i 的值都会增加。</span></span><br><span class="line">        <span class="keyword">return</span> i <span class="comment">// 返回增加后的 i 的值。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回结果 ：<br>1<br>2<br>3<br>1</p><p>这是因为闭包允许匿名函数捕获并记住 i 变量的状态。<br>这就是闭包的 “魔力” 所在，即使外部函数已经返回，内部函数仍然能够访问和修改外部函数的变量。</p><p>stack :&#x3D; []rune{} 与 make :&#x3D; []string{} 的区别：<br>stack :&#x3D; []rune{}：这段代码创建了一个 rune 类型的切片（空切片）。rune 是 Go 中专门用来表示单个字符的类型，适用于你处理字符（尤其是 Unicode 字符）时，能够确保每个元素是一个完整的 Unicode 字符。</p><p>make :&#x3D; []string{}：这段代码创建了一个 string 类型的切片。每个元素是一个字符串，字符串通常用于表示一系列字符构成的文本数据。</p><hr><p>在 Go 程序中，通过 <code>os.Args</code> 可以访问命令行参数，而 <code>go run main.go file1.txt file2.txt</code> 的执行过程如下：</p><hr><p>为什么·go语言 &gt; go run main.go file1.txt file2.txt 在这里执行之后可以读取到文件1 2</p><h3 id="1-命令行参数的解析"><a href="#1-命令行参数的解析" class="headerlink" title="1. 命令行参数的解析"></a><strong>1. 命令行参数的解析</strong></h3><ul><li><p><strong>命令：</strong> <code>go run main.go file1.txt file2.txt</code></p><ul><li><code>go run</code> 会编译并执行 <code>main.go</code>。</li><li>命令行中，<code>main.go</code> 后面的 <code>file1.txt</code> 和 <code>file2.txt</code> 被传递给程序作为命令行参数。</li></ul></li><li><p>在程序中，<code>os.Args</code> 是一个字符串切片（<code>[]string</code>），包含了命令行中的参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">os.Args[<span class="number">0</span>] <span class="comment">// 包含程序的名字，如 &quot;main.go&quot;</span></span><br><span class="line">os.Args[<span class="number">1</span>] <span class="comment">// 第一个参数 &quot;file1.txt&quot;</span></span><br><span class="line">os.Args[<span class="number">2</span>] <span class="comment">// 第二个参数 &quot;file2.txt&quot;</span></span><br></pre></td></tr></table></figure><p><strong>例子：</strong><br>假如命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run main.go file1.txt file2.txt</span><br></pre></td></tr></table></figure><p>则：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(os.Args) </span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[main file1.txt file2.txt]</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="2-打开文件进行读取"><a href="#2-打开文件进行读取" class="headerlink" title="2. 打开文件进行读取"></a><strong>2. 打开文件进行读取</strong></h3><p>你的代码解析命令行参数后，会尝试打开这些文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">files := os.Args[<span class="number">1</span>:] <span class="comment">// 获取命令行参数列表（除程序本身外的部分）</span></span><br></pre></td></tr></table></figure><ul><li><code>files</code> 现在是一个切片：<code>[&quot;file1.txt&quot;, &quot;file2.txt&quot;]</code>。</li></ul><p>然后通过循环处理每个文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, arg := <span class="keyword">range</span> files &#123;</span><br><span class="line">    f, err := os.Open(arg) <span class="comment">// 打开文件</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Fprintf(os.Stderr, <span class="string">&quot;dup2: %v\n&quot;</span>, err) <span class="comment">// 错误处理</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> f.Close() <span class="comment">// 确保文件被正确关闭</span></span><br><span class="line">    countLines(f, counts)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中：</p><ol><li><p>**<code>os.Open(arg)</code>**：</p><ul><li>打开文件（如 <code>file1.txt</code>），返回一个文件指针 <code>*os.File</code>。</li><li>如果文件打开失败（文件不存在或权限问题），返回错误并跳过。</li></ul></li><li><p>**<code>countLines(f, counts)</code>**：</p><ul><li>将文件指针传递给 <code>countLines</code>，扫描文件的内容并统计每行的出现次数。</li></ul></li></ol><hr><h3 id="3-执行结果的输出"><a href="#3-执行结果的输出" class="headerlink" title="3. 执行结果的输出"></a><strong>3. 执行结果的输出</strong></h3><p>统计完成后，程序会输出所有出现次数大于 1 的行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> line, n := <span class="keyword">range</span> counts &#123;</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">1</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d\t%s\n&quot;</span>, n, line)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这会将文件中所有重复的行及其出现次数打印到控制台。</p><hr><h3 id="4-为什么能够读取多个文件"><a href="#4-为什么能够读取多个文件" class="headerlink" title="4. 为什么能够读取多个文件"></a><strong>4. 为什么能够读取多个文件</strong></h3><p>这是因为你的代码通过 <code>for _, arg := files</code> 遍历了 <code>os.Args[1:]</code> 中的所有文件，并依次处理它们。程序对每个文件重复以下流程：</p><ol><li>打开文件。</li><li>按行扫描内容，统计出现次数。</li><li>将结果合并到 <code>counts</code> 映射中。</li></ol><p>这样，即使你提供多个文件，程序依然可以逐个读取并处理它们。</p><hr><h3 id="运行流程示例"><a href="#运行流程示例" class="headerlink" title="运行流程示例"></a><strong>运行流程示例</strong></h3><p>假设有以下文件内容：</p><h4 id="file1-txt"><a href="#file1-txt" class="headerlink" title="file1.txt:"></a><code>file1.txt</code>:</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">world</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><h4 id="file2-txt"><a href="#file2-txt" class="headerlink" title="file2.txt:"></a><code>file2.txt</code>:</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">world</span><br><span class="line">hello</span><br><span class="line">go</span><br></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run main.go file1.txt file2.txt</span><br></pre></td></tr></table></figure><p>程序会：</p><ol><li>读取 <code>file1.txt</code>：<ul><li>统计结果：<code>&#123;&quot;hello&quot;: 2, &quot;world&quot;: 1&#125;</code>。</li></ul></li><li>读取 <code>file2.txt</code>，继续更新 <code>counts</code>：<ul><li>最终统计结果：<code>&#123;&quot;hello&quot;: 3, &quot;world&quot;: 2, &quot;go&quot;: 1&#125;</code>。</li></ul></li><li>打印重复行：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3   hello</span><br><span class="line">2   world</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>你可以读取多个文件是因为程序通过 <code>os.Args</code> 获取了命令行中的文件名列表，并通过循环逐个打开和读取文件的内容。这种设计使得你的程序能够动态处理任意数量的文件，而无需修改代码。</p><hr><h3 id="12-14-日-更考完4级"><a href="#12-14-日-更考完4级" class="headerlink" title="12.14 日 更考完4级"></a>12.14 日 更考完4级</h3><h4 id="一-Errors"><a href="#一-Errors" class="headerlink" title="一.Errors"></a>一.Errors</h4><ol><li>“errors” 包  使用给定的错误消息构造一个基本错误值。</li></ol><p>errors.New(“can’t work with 42”)</p><p>nil 表示没有错误</p><ol start="2"><li>哨兵错误是一个预先声明的变量，用于表示特定的错误情况。</li></ol><p>var ErrOutOfTea &#x3D; fmt.Errorf(“no more tea available”)<br>var ErrPower &#x3D; fmt.Errorf(“can’t boil water”)</p><ol start="3"><li>更高级别的错误来包装错误以添加上下文</li></ol><p>最简单的方法是使用 fmt.Errorf 中的 %w 动词。包装错误创建一个逻辑链（A 包装 B，B 包装 C 等），可以使用 error.Is 和 error.As 等函数进行查询。</p><p>return fmt.Errorf(“making tea: %w”, ErrPower)</p><ol start="4"><li>if 行中使用内联错误检查</li></ol><p>if r, e :&#x3D; f(i); e !&#x3D; nil {<br>fmt.Println(“f failed:”, e)<br>} else {<br>fmt.Println(“f worked:”, r)<br>}</p><ol start="5"><li>error.Is 检查给定错误（或其链中的任何错误）是否与特定错误值匹配。</li></ol><p>if errors.Is(err, ErrOutOfTea) {<br>fmt.Println(“We should buy new tea!”)<br>} else if errors.Is(err, ErrPower) {<br>fmt.Println(“Now it is dark.”)<br>} else {<br>fmt.Printf(“unknown error: %s\n”, err)<br>}</p><p>将err和我们自定义的哨兵错误或者特定错误做对比</p><p>二.自定义错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> argError <span class="keyword">struct</span> &#123;</span><br><span class="line">    arg     <span class="type">int</span></span><br><span class="line">    message <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *argError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%d - %s&quot;</span>, e.arg, e.message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Error 方法并没有直接调用，但 &amp;argError{arg, “can’t work with it”} 被返回为 error 类型时，Error 方法已经在幕后实现了对错误消息的封装。</p><p>error.As 是errors.Is 的更高级版本。它检查给定错误（或其链中的任何错误）是否与特定错误类型匹配，并转换为该类型的值，返回 true。如果没有匹配，则返回 false。</p><h4 id="Goroutines"><a href="#Goroutines" class="headerlink" title="Goroutines"></a>Goroutines</h4><p>轻量级的执行线程</p><p>go f(s)。这个新的 goroutine 将与调用的 goroutine 同时执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(from <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        fmt.Println(from, <span class="string">&quot;:&quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> f(<span class="string">&quot;goroutine&quot;</span>)</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>启动一个 goroutine 来进行匿名函数调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(msg <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">        fmt.Println(msg)</span><br><span class="line">    &#125;(<span class="string">&quot;going&quot;</span>)</span><br></pre></td></tr></table></figure><p>goroutine 是由 Go 运行时同时运行的。</p><h4 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h4><p>通道是连接并发 goroutine 的管道。您可以将值从一个 Goroutine 发送到通道，并将这些值接收到另一个 Goroutine。</p><p>messages :&#x3D; make(chan string)</p><p>通道 &lt;- 语法将值发送到通道</p><p>go func() { messages &lt;- “ping” }()</p><p>msg :&#x3D; &lt;-messages</p><p>&lt;-channel 语法从通道接收值。在这里，我们将收到上面发送的“ping”消息并将其打印出来。</p><p>发送和接收会阻塞，直到发送者和接收者都准备好为止。此属性允许我们在程序结束时等待“ping”消息，而无需使用任何其他同步。</p><p>通道缓冲：</p><p>messages :&#x3D; make(chan string, 2) 字符串通道，最多缓冲 2 个值 因此我们可以将这些值发送到通道中，而无需相应的并发接收。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> messages := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">messages &lt;- <span class="string">&quot;buffered&quot;</span></span><br><span class="line">messages &lt;- <span class="string">&quot;channel&quot;</span></span><br><span class="line"></span><br><span class="line"> fmt.Println(&lt;-messages)</span><br><span class="line"> fmt.Println(&lt;-messages)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="断言和switch用法"><a href="#断言和switch用法" class="headerlink" title="断言和switch用法:"></a>断言和switch用法:</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">t = functionOfSomeType()</span><br><span class="line"><span class="keyword">switch</span> t := t.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;unexpected type %T\n&quot;</span>, t)     <span class="comment">// %T prints whatever type t has</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;boolean %t\n&quot;</span>, t)             <span class="comment">// t has type bool</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;integer %d\n&quot;</span>, t)             <span class="comment">// t has type int</span></span><br><span class="line"><span class="keyword">case</span> *<span class="type">bool</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;pointer to boolean %t\n&quot;</span>, *t) <span class="comment">// t has type *bool</span></span><br><span class="line"><span class="keyword">case</span> *<span class="type">int</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;pointer to integer %d\n&quot;</span>, *t) <span class="comment">// t has type *int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型断言用于从接口类型值中提取其底层的具体类型。如果断言成功，程序可以安全地将该接口值转换为目标类型并使用。</p><p>value, ok :&#x3D; x.(T)</p><p>x 是一个接口类型的变量。<br>T 是目标类型（可以是具体类型或其他接口类型）。<br>如果 x 的动态类型是 T：<br>value 是 x 转换为 T 后的值。<br>ok 为 true。<br>如果 x 的动态类型不是 T：<br>value 是 T 的零值。<br>ok 为 false，表示断言失败。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; = <span class="number">42</span> <span class="comment">// 空接口存储了一个 int 值</span></span><br><span class="line"></span><br><span class="line">value, ok := x.(<span class="type">int</span>) <span class="comment">// 断言 x 是 int 类型</span></span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;x is an int, value: %d\n&quot;</span>, value)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;x is not an int&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空interface<br>空interface(interface{})不包含任何的method，正因为如此，所有的类型都实现了空interface。空interface对于描述起不到任何的作用(因为它不包含任何的method），但是空interface在我们需要存储任意类型的数值的时候相当有用，因为它可以存储任意类型的数值。它有点类似于C语言的void*类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义a为空接口</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span> = <span class="number">5</span></span><br><span class="line">s := <span class="string">&quot;Hello world&quot;</span></span><br><span class="line"><span class="comment">// a可以存储任意类型的数值</span></span><br><span class="line">a = i</span><br><span class="line">a = s</span><br></pre></td></tr></table></figure><p>一个函数把interface{}作为参数，那么他可以接受任意类型的值作为参数，如果一个函数返回interface{},那么也就可以返回任意类型的值。是不是很有用啊！</p><p>Go并发</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>小计划</title>
    <link href="https://whuichenggong.github.io/2024/12/02/study_plan/"/>
    <id>https://whuichenggong.github.io/2024/12/02/study_plan/</id>
    <published>2024-12-02T02:47:34.759Z</published>
    <updated>2024-12-19T14:02:27.389Z</updated>
    
    <content type="html"><![CDATA[<p>兄弟，你的想法很清晰，我非常理解你想深入学习、夯实基础，而不是走捷径的决心。我们可以针对你的目标和现状制定一个更加实践导向的计划，同时保持学习过程有趣且充实。以下是我的建议和方案：</p><hr><h3 id="总体目标"><a href="#总体目标" class="headerlink" title="总体目标"></a><strong>总体目标</strong></h3><ol><li><strong>短期（2025年3月前）</strong>：增强银行项目的实用性和技术深度，掌握后端开发的核心技能，为实习做好准备。</li><li><strong>中长期（未来两年）</strong>：夯实计算机基础，深入理解系统设计、分布式系统及核心算法，逐步具备独立设计和开发复杂项目的能力。</li></ol><hr><h3 id="学习模块规划"><a href="#学习模块规划" class="headerlink" title="学习模块规划"></a><strong>学习模块规划</strong></h3><h4 id="1-项目深度增强（每周一个主题，贯穿整个学习计划）"><a href="#1-项目深度增强（每周一个主题，贯穿整个学习计划）" class="headerlink" title="1. 项目深度增强（每周一个主题，贯穿整个学习计划）"></a><strong>1. 项目深度增强（每周一个主题，贯穿整个学习计划）</strong></h4><p>目标：将现有银行项目提升到更贴近实际业务需求的水平，增加亮点功能。</p><ul><li><p><strong>Week 1: 数据一致性与事务</strong></p><ul><li>学习事务隔离级别（ACID），在项目中实现更加复杂的转账操作（如跨账户冻结和解冻）。</li><li>使用 SQLC 或 GORM，优化数据库操作。</li></ul></li><li><p><strong>Week 2: 引入 Redis</strong></p><ul><li>学习 Redis 基础知识，理解其在缓存和分布式锁中的应用。</li><li>在项目中实现：<ul><li>用户信息缓存，优化频繁查询。</li><li>基于 Redis 的幂等性控制（防止转账操作重复）。</li></ul></li></ul></li><li><p><strong>Week 3: RESTful API 和 JWT 身份验证</strong></p><ul><li>深化对 RESTful API 的理解，优化项目 API 设计。</li><li>引入 JWT 实现用户登录认证和权限管理。</li></ul></li><li><p><strong>Week 4: 日志和监控</strong></p><ul><li>集成日志框架（如 Logrus&#x2F;Zap），记录系统操作。</li><li>学习 Prometheus 基础知识，为项目添加简单监控。</li></ul></li><li><p><strong>Week 5: Docker 和部署优化</strong></p><ul><li>使用 Docker Compose 部署完整项目，模拟生产环境。</li><li>学习 Nginx 基础知识，优化项目访问流程。</li></ul></li><li><p><strong>Week 6: 微服务化</strong></p><ul><li>学习 Go 微服务框架（如 Gin、gRPC）。</li><li>将项目拆分成两个服务（如用户服务和交易服务），理解微服务架构基础。</li></ul></li></ul><hr><h4 id="2-算法与数据结构（每天一题，逐渐深入）"><a href="#2-算法与数据结构（每天一题，逐渐深入）" class="headerlink" title="2. 算法与数据结构（每天一题，逐渐深入）"></a><strong>2. 算法与数据结构（每天一题，逐渐深入）</strong></h4><p>目标：构建扎实的算法基础，为今后面试和实际开发做准备。</p><ul><li><strong>题目选择顺序</strong>：简单 -&gt; 中等 -&gt; 困难，优先 BFS&#x2F;DFS、二分查找、动态规划等重要领域。</li><li><strong>周主题</strong>：<ul><li>Week 1-2: 栈、队列、链表</li><li>Week 3-4: 二叉树与递归</li><li>Week 5-6: 动态规划与分治算法</li><li>Week 7+: 高频面试题复盘（重点记录和总结常见套路）。</li></ul></li></ul><hr><h4 id="3-计算机基础与原理（每周一本书-主题）"><a href="#3-计算机基础与原理（每周一本书-主题）" class="headerlink" title="3. 计算机基础与原理（每周一本书&#x2F;主题）"></a><strong>3. 计算机基础与原理（每周一本书&#x2F;主题）</strong></h4><p>目标：夯实后端开发的计算机科学基础。</p><ul><li><p><strong>Week 1: 计算机网络</strong></p><ul><li>阅读《计算机网络：自顶向下方法》或《图解HTTP》。</li><li>重点学习 HTTP、HTTPS、TCP&#x2F;IP 的工作原理，并理解抓包工具（如 Wireshark）的使用。</li></ul></li><li><p><strong>Week 2: 操作系统</strong></p><ul><li>阅读《现代操作系统》。</li><li>理解线程、进程、同步机制，以及如何在 Go 中实现简单的并发处理。</li></ul></li><li><p><strong>Week 3-4: 数据库系统</strong></p><ul><li>阅读《数据库系统概念》。</li><li>理解索引、事务原理、查询优化等内容。</li></ul></li><li><p><strong>Week 5: 系统设计</strong></p><ul><li>阅读《系统设计入门》或相关博客。</li><li>学习常见系统设计模式（如限流、负载均衡）和架构决策。</li></ul></li></ul><hr><h3 id="具体每日安排（样例）"><a href="#具体每日安排（样例）" class="headerlink" title="具体每日安排（样例）"></a><strong>具体每日安排（样例）</strong></h3><ul><li><p><strong>上午</strong>：</p><ul><li>刷一道 LeetCode 算法题，阅读相关解析，整理题解。</li><li>学习书籍相关章节，完成1-2页的读书笔记。</li></ul></li><li><p><strong>下午</strong>：</p><ul><li>按周主题在银行项目中完成对应功能开发。</li><li>查看官方文档、博客或视频教程，记录学习中的关键点。</li></ul></li><li><p><strong>晚上</strong>：</p><ul><li>复习当天内容，整理代码和笔记。</li><li>自测项目功能，尝试优化代码。</li></ul></li></ul><hr><h3 id="可实践性建议"><a href="#可实践性建议" class="headerlink" title="可实践性建议"></a><strong>可实践性建议</strong></h3><ol><li><strong>建立个人技术博客</strong>：把每天的学习记录写成博客或日志，比如讲解项目中 Redis 的用法或总结某道算法题的思路。</li><li><strong>参与开源项目</strong>：找一个简单的 Go 开源项目，阅读代码，尝试修复 bug 或贡献文档。</li><li><strong>模拟面试</strong>：每两周自测一次，将银行项目作为核心，讲解架构设计和亮点功能。</li></ol><hr><h3 id="最终成果展示"><a href="#最终成果展示" class="headerlink" title="最终成果展示"></a><strong>最终成果展示</strong></h3><ul><li>一个高度完善的银行项目：<ul><li>支持分布式事务、JWT 身份验证、Redis 缓存与微服务架构。</li><li>提供完善的 Docker 部署文档。</li></ul></li><li>一个 LeetCode 高质量题解库（至少 50 道题）。</li><li>一份扎实的基础知识笔记，涵盖网络、操作系统和数据库。</li></ul><p>引入项目技术栈（2周）：在新项目中加入 SQLC 工具、中间件，理解每个技术的接入过程。</p><p>实现进阶功能（3周）：根据银行项目的转账逻辑，尝试自己独立实现一次。</p><p>重点学习 HTTP 和 RESTful API。 深入理解数据库  深入理解数据库 熟悉中间件的实现逻辑</p><p>Web开发</p><ol><li>Go by example</li><li>三本书</li><li>两个项目 Memos Apache Answer</li><li>算法</li><li>gin-gonic.com</li></ol><p>微服务进阶</p><p>  gRPC</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;兄弟，你的想法很清晰，我非常理解你想深入学习、夯实基础，而不是走捷径的决心。我们可以针对你的目标和现状制定一个更加实践导向的计划，同时保持学习过程有趣且充实。以下是我的建议和方案：&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;总体目标&quot;&gt;&lt;a href=&quot;#总体目标&quot; class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>11.26日字节直播总结</title>
    <link href="https://whuichenggong.github.io/2024/11/26/Dance_live2/"/>
    <id>https://whuichenggong.github.io/2024/11/26/Dance_live2/</id>
    <published>2024-11-26T12:20:49.917Z</published>
    <updated>2024-11-26T12:25:46.917Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字节结营直播答疑"><a href="#字节结营直播答疑" class="headerlink" title="字节结营直播答疑"></a>字节结营直播答疑</h1><p>revue 项目</p><p><img src="/about_Dance/1.png" alt="image-20241126190953519"></p><p><img src="/about_Dance/2.png" alt="image-20241126191031196"></p><p>性能优化     ci&#x2F;cd流程 （ star法则来描述一件事情)</p><p>准备找实习 写好简历</p><p><img src="/about_Dance/3.png" alt="image-20241126191500892"></p><p>zt：</p><p>服务端： 计算机基础知识（字节：计算机网络 tcp&#x2F;ip  腾讯：操作系统 阿里： 组成原理）</p><p>技术： （数据结构 高阶算法 链表 堆栈 树（面试重点））</p><p>leetcode 100 150 200</p><p>项目： 烂大街的（入门） 改进一些项目（做优化 项目存在的意义 解决了什么问题？ 带来了什么？ 项目亮点在哪里）</p><p>实习经历：（做了什么需求 需求是（谁给的 自己还是别人？）通过实现了什么？ 解决了什么？ 团队收益还是小组收益？）</p><p>专业能力： 小厂一门语言 ＋数据库存储 会就ok  大数据 架构数据 微服务层面</p><p><img src="/about_Dance/4.png" alt="image-20241126192005590"></p><p>八股扎实稳固 算法 中等难度题很快弄出来</p><p>项目亮点：能让面试官和你聊下去 如何提升亮点和竞争力  开源社区！</p><p>抄项目 然后手写 尝试自己理解      前端（vue）（react）</p><p><img src="/about_Dance/5.png" alt="image-20241126192541252"></p><p>数据结构 计算机基础知识  面试官想看你的亮点（你牛逼在哪里？）</p><p>做过什么会什么？</p><p>服务端是一些思维 而不是纠结你是用什么语言</p><p>从0-1 有没有调研 各行各业的优秀作业</p><p>合作项目</p><p>责任意识</p><p>技术探索：遇到什么问题 怎么解决的？</p><p>业务理解能力 项目受众是谁 项目模块 最重要是哪个模块 怎么优化这个模块</p><p><img src="/about_Dance/6.png" alt="image-20241126193100190"></p><p><img src="/about_Dance/7.png" alt="image-20241126193341747"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">“开源社区新手入门该参与什么内容，有哪些社区比较活跃”</span><br><span class="line">可以看看类似于开源之夏这类的活动往年都是做什么的</span><br></pre></td></tr></table></figure><p>多逛github</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">“在github中新手怎么找项目”</span><br><span class="line">，你用vue就去看VUE文档仓库，看看有没有错别字，有的话修一下</span><br></pre></td></tr></table></figure><p>项目的含金量 和自己从0-1实现</p><p>组件多 中间件多 新奇的做法等 可以被称为含金量（）</p><p>核心能力 技术深度 在广度的前提下 一定要有一个深度</p><p>项目一样 面试官能问什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">老哥们 大二第一次找实习的话一般要什么程度我正在跟着别人做一个项目 但是不知道什么时候才够格去投简历”</span><br><span class="line">看看面经别人被问了什么你能不能回答</span><br></pre></td></tr></table></figure><p><img src="/about_Dance/8.png" alt="image-20241126193803102"></p><p>平地起项目 是有条件的： 大厂实习 项目经历&gt;&#x3D;3 等经历 否则不要平地起</p><p>对于项目的理解一定是从头到尾的 对项目改造 新增功能 优化 才能体现你的亮点</p><p>思考 ： 多人协作是否有沟通 是否涉及复杂逻辑</p><p>新颖的想法！ 创造力！</p><p>投简历的方式</p><p>如何面对八股 算法</p><p>找开源项目：熟悉流程 寻找错别字熟悉流程哈哈哈 看issue bug（解决issue）</p><p>知乎 蔚来 比亚迪 从小厂到大厂 循序渐进</p><p><img src="/about_Dance/9.png" alt="image-20241126195807918"></p><p>字节  99%go</p><p>语言是基础无所谓</p><p>培养独立解决问题的能力 做出一个合格的项目 （不断回顾自己的项目 查找不足）</p><p>后端开发实习生（简历）</p><p>数据库的课（掘金的）</p><p>《Redis深度历险：核心原理和应用实践》</p><p>服务端开源： 不建议新手就去找开源 学习成本很大 2~3段实习之后尝试开源</p><p><img src="/about_Dance/10.png" alt="image-20241126200922693"></p><p>知名项目源码： 前提一定要熟悉使用这个项目的源码 项目的使用环境 如何启动它</p><p>例如：熟练使用docker ， kubernets istio了，再去看源码 i   <strong>写出一个对源码理解的文章</strong></p><p>对于源码：一步一步慢慢来 该学的东西就学 不要纠结没用的例如学历 没法改变就不去改变</p><p>.md .sh 依赖那些中间件 中间件是否具备？ 如何去不使用中间件如何启动这个项目 分析目录结构（单体 还是微服务）包的作用 模块之间的耦合关系  利用isue 项目常见报错解决方式</p><p>组队开发的群聊看看能不能找到</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;字节结营直播答疑&quot;&gt;&lt;a href=&quot;#字节结营直播答疑&quot; class=&quot;headerlink&quot; title=&quot;字节结营直播答疑&quot;&gt;&lt;/a&gt;字节结营直播答疑&lt;/h1&gt;&lt;p&gt;revue 项目&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/about_Dance/1.png&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>UDP socket的ack机制和丢包重传</title>
    <link href="https://whuichenggong.github.io/2024/11/23/UDP_socket/"/>
    <id>https://whuichenggong.github.io/2024/11/23/UDP_socket/</id>
    <published>2024-11-23T09:15:42.999Z</published>
    <updated>2024-12-15T12:37:16.302Z</updated>
    
    <content type="html"><![CDATA[<p>参考连接： <a href="https://juejin.cn/post/7263378772040122429">https://juejin.cn/post/7263378772040122429</a></p><h1 id="Go语言实现UDP-socket的ack机制和丢包重传"><a href="#Go语言实现UDP-socket的ack机制和丢包重传" class="headerlink" title="Go语言实现UDP socket的ack机制和丢包重传"></a>Go语言实现UDP socket的ack机制和丢包重传</h1><p>UDP 在通讯之前不需要建立连接 可以直接发送数据包 是一种无连接协议（常用于音视频传输）</p><p>但是在有些场景 即需要UDP传输也需要向TCP一样（TCP的可靠传输）</p><p>解决丢包问题：</p><p>1.添加 seq&#x2F;ack机制 确保数据发送到对端</p><p>什么是 seq&#x2F;ack机制</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在TCP（传输控制协议）中，序号（Sequence Number，简称seq）和确认应答号（Acknowledgment Number，简称ack）是协议头部非常关键的字段，它们共同确保了TCP的可靠性和数据按顺序传输的特性。</span><br><span class="line"></span><br><span class="line">** Sequence Number **</span><br><span class="line">含义：序号是指一个TCP报文段中第一个字节的数据序列标识。它表示在一个TCP连接中，该报文段所携带的数据的开始位置。序号是用来保证数据传输的顺序性和完整性的。</span><br><span class="line"></span><br><span class="line">作用：在TCP连接建立时，双方各自随机选择一个初始序列号（ISN）。随后传输的每个报文段的序号将基于这个初始值递增，其增量为该报文段所携带的数据量（字节数）。通过这种方式，接收方可以根据序号重组乱序到达的数据片段，确保数据的正确顺序和完整性。如果接收到的报文段不连续，接收方可以通过TCP的重传机制请求发送方重新发送缺失的数据。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**Acknowledgment Number**</span><br><span class="line">含义：确认应答号是接收方期望从发送方接收到的下一个报文段的序号。它实质上是接收方告诉发送方：“我已经成功接收到了哪个序号之前的所有数据，请从这个序号开始发送后续的数据。”</span><br><span class="line"></span><br><span class="line">作用：确认应答号用于实现可靠性传输。当一个报文段被接收方正确接收时，接收方会发送一个ACK报文，其中包含的确认应答号是接收到的数据加上1（即接收方期望接收的下一个数据的序号）。通过检查这个确认应答号，发送方能够知道其发送的数据是否已被接收方正确接收，并据此决定是否需要重传某些数据段。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ack和seq 保证了：</p><ul><li>确保数据的顺序性：即使数据片段在网络中的传输过程中顺序被打乱，接收方也能根据序号正确地重组这些数据。</li><li>检测丢包：如果发送方发送的数据长时间未被确认（即没有收到对应的ACK报文），它会判断这些数据可能已丢失，并将其重新发送。</li><li>实现流量控制和拥塞控制：通过调整发送未被确认数据的量（即控制窗口大小），TCP可以根据网络条件动态调整数据发送的速率，避免网络拥塞。</li></ul><h4 id="Golang的socket编程："><a href="#Golang的socket编程：" class="headerlink" title="Golang的socket编程："></a>Golang的socket编程：</h4><p>Go语言通过标准库中的<code>net</code>包来实现UDP和TCP的socket编程。<code>net</code>包提供了用于创建和管理网络连接的函数，以及用于进行数据传输的相关类型和方法，不同于C++需要手动设置和管理socket API，不论实现UDP还是TCP都可以直接使用封装好的方法进行操作，大大简化了socket编程：</p><h5 id="使用net包实现UDP通信"><a href="#使用net包实现UDP通信" class="headerlink" title="使用net包实现UDP通信"></a>使用net包实现UDP通信</h5><h6 id="1-client-go"><a href="#1-client-go" class="headerlink" title="1.client.go"></a>1.client.go</h6><p>1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;bufio&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;net&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">// 创建UDP连接到服务器的地址和端口号</span><br><span class="line">c, err := net.DialUDP(&quot;udp&quot;, nil, &amp;net.UDPAddr&#123;</span><br><span class="line">IP:   net.IPv4(127, 0, 0, 1),</span><br><span class="line">Port: 8282,</span><br><span class="line">&#125;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(&quot;dial err: %v\n&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">defer c.Close() // 将 defer 放在 if 语句外面</span><br><span class="line"></span><br><span class="line">// 从标准输入读取用户输入的数据</span><br><span class="line">input := bufio.NewReader(os.Stdin)</span><br><span class="line">for &#123;</span><br><span class="line">// 读取用户输入知道遇见换行符</span><br><span class="line">s, err := input.ReadString(&#x27;\n&#x27;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Printf(&quot;read from stdin failed, err: %v\n&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将用户输入的数据转换为字节数组并通过UDP连接发送给服务器</span><br><span class="line">_, err = c.Write([]byte(s))</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Printf(&quot;send to server failed, err: %v\n&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 接收来自服务器的数据</span><br><span class="line">var buf [1024]byte</span><br><span class="line">n, addr, err := c.ReadFromUDP(buf[:])</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Printf(&quot;recv from udp failed, err: %v\n&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 打印来自服务器的数据</span><br><span class="line">fmt.Printf(&quot;服务器 %v, 响应数据: %v\n&quot;, addr, string(buf[:n]))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="2-server-go"><a href="#2-server-go" class="headerlink" title="2.server.go"></a>2.server.go</h6><p>首先创建UDP监听器监听指定IP和端口，等待连接客户端，连接后会读取客户端发来的数据并打印收到的数据，并将接收的响应信息返回发送给客户端，使用死循环使其能够持续获取客户端数据，同样实现了UDP的数据接收和发送，实现了简单的UDP服务器；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;net&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// udp server</span><br><span class="line">func main() &#123;</span><br><span class="line">// 创建一个UDP监听器，监听本地IP地址的端口</span><br><span class="line">listen, err := net.ListenUDP(&quot;udp&quot;, &amp;net.UDPAddr&#123;</span><br><span class="line">IP:   net.IPv4(127, 0, 0, 1),</span><br><span class="line">Port: 8282,</span><br><span class="line">&#125;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Printf(&quot;listen failed,err:%v\n&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">defer listen.Close()</span><br><span class="line"></span><br><span class="line">for &#123;</span><br><span class="line">var buf [1024]byte</span><br><span class="line">// 从UDP连接中读取数据到buf中，n为读取到的字节数，addr为数据发送者的地址</span><br><span class="line">n, addr, err := listen.ReadFromUDP(buf[:])</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Printf(&quot;read from udp failed,err:%v\n&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 打印接收到的数据</span><br><span class="line">fmt.Println(&quot;接收到的数据：&quot;, string(buf[:n]))</span><br><span class="line"></span><br><span class="line">// 将接收到的数据原样发送回给数据发送者</span><br><span class="line">_, err = listen.WriteToUDP(buf[:n], addr)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Printf(&quot;write to %v failed,err:%v\n&quot;, addr, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>效果：（好有趣）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; go run client.go</span><br><span class="line">hello</span><br><span class="line">服务器 127.0.0.1:8282, 响应数据: hello</span><br><span class="line"></span><br><span class="line">world</span><br><span class="line">服务器 127.0.0.1:8282, 响应数据: world</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> go run server.go</span><br><span class="line">接收到的数据： hello</span><br><span class="line"></span><br><span class="line">接收到的数据： world</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="基于seq-apk"><a href="#基于seq-apk" class="headerlink" title="基于seq&#x2F;apk"></a>基于seq&#x2F;apk</h5><p>client</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">Seq <span class="type">int</span></span><br><span class="line">Msg <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c, err := net.DialUDP(<span class="string">&quot;udp&quot;</span>, <span class="literal">nil</span>, &amp;net.UDPAddr&#123;</span><br><span class="line">IP:   net.IPv4(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">Port: <span class="number">8282</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;dail err:%v\n&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> c.Close()</span><br><span class="line"></span><br><span class="line">input := []<span class="type">string</span>&#123;<span class="string">&quot;Message1&quot;</span>, <span class="string">&quot;Message2&quot;</span>, <span class="string">&quot;Message3&quot;</span>, <span class="string">&quot;Message4&quot;</span>, <span class="string">&quot;Message5&quot;</span>&#125;</span><br><span class="line">seq := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, msg := <span class="keyword">range</span> input &#123;</span><br><span class="line">seq++</span><br><span class="line">message := Message&#123;Seq: seq, Msg: msg&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Sending seq=%d: %s\n&quot;</span>, message.Seq, message.Msg)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送带有序列号的数据包</span></span><br><span class="line">_, err = c.Write(encodeMessage(message))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;send to server failed,err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等待ACK，设置超时时间</span></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">c.SetReadDeadline(time.Now().Add(<span class="number">5</span> * time.Second))</span><br><span class="line">n, _, err := c.ReadFromUDP(buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;ACK not received. Timeout or Error.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ack := decodeMessage(buf[:n])</span><br><span class="line"><span class="keyword">if</span> ack.Seq == seq+<span class="number">1</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;ACK = %d\n&quot;</span>, ack.Seq)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Invalid ACK received. Retry.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">encodeMessage</span><span class="params">(msg Message)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line"><span class="comment">// 将序列号和消息文本编码成字节数据</span></span><br><span class="line"><span class="keyword">return</span> []<span class="type">byte</span>(fmt.Sprintf(<span class="string">&quot;%d;%s&quot;</span>, msg.Seq, msg.Msg))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decodeMessage</span><span class="params">(data []<span class="type">byte</span>)</span></span> Message &#123;</span><br><span class="line"><span class="comment">// 解码收到的数据，提取序列号和消息文本</span></span><br><span class="line">parts := strings.Split(<span class="type">string</span>(data), <span class="string">&quot;;&quot;</span>)</span><br><span class="line">seq, _ := strconv.Atoi(parts[<span class="number">0</span>])</span><br><span class="line">msg := parts[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">return</span> Message&#123;Seq: seq, Msg: msg&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>server</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Message2 <span class="keyword">struct</span> &#123;</span><br><span class="line">Seq <span class="type">int</span></span><br><span class="line">Msg <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">listen, err := net.ListenUDP(<span class="string">&quot;udp&quot;</span>, &amp;net.UDPAddr&#123;</span><br><span class="line">IP:   net.IPv4(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">Port: <span class="number">8282</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;listen failed,err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> listen.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">var</span> buf [<span class="number">1024</span>]<span class="type">byte</span></span><br><span class="line">n, addr, err := listen.ReadFromUDP(buf[:])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;read from udp failed,err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理接收到的数据，提取序列号和消息文本</span></span><br><span class="line">message := decodeMessage1(buf[:n])</span><br><span class="line">fmt.Printf(<span class="string">&quot;Received seq=%d from %v: %s\n&quot;</span>, message.Seq, addr, message.Msg)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送ACK回复给客户端，ACK=Seq+1</span></span><br><span class="line">ack := Message2&#123;Seq: message.Seq + <span class="number">1</span>, Msg: <span class="string">&quot;ACK&quot;</span>&#125;</span><br><span class="line">_, err = listen.WriteToUDP(encodeMessage1(ack), addr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;write to %v failed,err:%v\n&quot;</span>, addr, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">encodeMessage1</span><span class="params">(msg Message2)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line"><span class="comment">// 将序列号和消息文本编码成字节数据</span></span><br><span class="line"><span class="keyword">return</span> []<span class="type">byte</span>(fmt.Sprintf(<span class="string">&quot;%d;%s&quot;</span>, msg.Seq, msg.Msg))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decodeMessage1</span><span class="params">(data []<span class="type">byte</span>)</span></span> Message2 &#123;</span><br><span class="line"><span class="comment">// 解码收到的数据，提取序列号和消息文本</span></span><br><span class="line">parts := strings.Split(<span class="type">string</span>(data), <span class="string">&quot;;&quot;</span>)</span><br><span class="line">seq, _ := strconv.Atoi(parts[<span class="number">0</span>])</span><br><span class="line">msg := parts[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">return</span> Message2&#123;Seq: seq, Msg: msg&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>问题核心：在同一文件夹内，Go 默认将所有文件视为同一包的一部分，可能导致重复定义或未定义的错误。<br>推荐解决方法：<br>分文件夹运行。<br>提取共享逻辑到单独的文件。<br>运行时显式指定所有 .go 文件。<br>额外改进：通过参数区分服务端和客户端运行模式，进一步优化程序结构。</p><p>，服务器监听的端口可能是某个固定端口（例如 12345），而客户端的UDP数据包来自 127.0.0.1:59653。这意味着：<br>UDP允许客户端选择任意可用的端口号作为源端口，并将数据包发送到服务器的监听端口。这也是为什么你看到不同的端口号。</p><hr><h5 id="4-实现超时重传"><a href="#4-实现超时重传" class="headerlink" title="4.实现超时重传"></a>4.实现超时重传</h5><p>最简单的方法就是当超时没有收到ack回复或者ack回复错误乱序时，阻塞后续发包，先进行重传，<br>把丢失的包重传后再继续发包，因此主要是在客户端更改一些发包的逻辑，服务端则没有变化；</p><p>client.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">Seq <span class="type">int</span></span><br><span class="line">Msg <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c, err := net.DialUDP(<span class="string">&quot;udp&quot;</span>, <span class="literal">nil</span>, &amp;net.UDPAddr&#123;</span><br><span class="line">IP:   net.IPv4(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">Port: <span class="number">8282</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;dial,err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> c.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例数据</span></span><br><span class="line">input := []<span class="type">string</span>&#123;<span class="string">&quot;Message 1&quot;</span>, <span class="string">&quot;Message 2&quot;</span>, <span class="string">&quot;Message 3&quot;</span>, <span class="string">&quot;Message 4&quot;</span>, <span class="string">&quot;Message 5&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> seq, msg := <span class="keyword">range</span> input &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">message := Message&#123;Seq: seq + <span class="number">1</span>, Msg: msg&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Sending seq=%d: %s\n&quot;</span>, message.Seq, message.Msg)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送带有序列号的数据包</span></span><br><span class="line">_, err := c.Write(encodeMessage(message))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;send to server failed,err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始等待ACK，设置超时时间</span></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">c.SetReadDeadline(time.Now().Add(<span class="number">5</span> * time.Second))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环等待ACK，直到收到正确的ACK或超时</span></span><br><span class="line">n, _, err := c.ReadFromUDP(buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 超时或发生错误，需要重传</span></span><br><span class="line">fmt.Println(<span class="string">&quot;ACK not received. Timeout or Error. Retrying...&quot;</span>)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//解码从服务器传来的ack</span></span><br><span class="line">ack := decodeMessage(buf[:n])</span><br><span class="line"><span class="keyword">if</span> ack.Seq == seq+<span class="number">2</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;ACK = %d\n&quot;</span>, ack.Seq)</span><br><span class="line"><span class="comment">// 收到正确的ACK，跳出内部循环，继续发送下一个消息</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 收到错误的ACK，继续等待，内部循环会重发相同的消息</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Invalid ACK received. Waiting for correct ACK...&quot;</span>)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">encodeMessage</span><span class="params">(msg Message)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line"><span class="comment">// 将序列号和消息文本编码成字节数据</span></span><br><span class="line"><span class="keyword">return</span> []<span class="type">byte</span>(fmt.Sprintf(<span class="string">&quot;%d;%s&quot;</span>, msg.Seq, msg.Msg))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decodeMessage</span><span class="params">(data []<span class="type">byte</span>)</span></span> Message &#123;</span><br><span class="line"><span class="comment">// 解码收到的数据，提取序列号和消息文本</span></span><br><span class="line">parts := strings.Split(<span class="type">string</span>(data), <span class="string">&quot;;&quot;</span>)</span><br><span class="line">seq, _ := strconv.Atoi(parts[<span class="number">0</span>])</span><br><span class="line">msg := parts[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">return</span> Message&#123;Seq: seq, Msg: msg&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>server.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math/rand&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">Seq <span class="type">int</span></span><br><span class="line">Msg <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">listen, err := net.ListenUDP(<span class="string">&quot;udp&quot;</span>, &amp;net.UDPAddr&#123;</span><br><span class="line">IP:   net.IPv4(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">Port: <span class="number">8282</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;listen failed,err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> listen.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">var</span> buf [<span class="number">1024</span>]<span class="type">byte</span></span><br><span class="line">n, addr, err := listen.ReadFromUDP(buf[:])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;read from udp failed,err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以20%的概率模拟丢包</span></span><br><span class="line"><span class="keyword">if</span> rand.Float32() &lt; <span class="number">0.2</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;From %v lost package\n&quot;</span>, addr)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理接收到的数据，解码字节流 提取序列号和消息文本</span></span><br><span class="line">message := decodeMessage(buf[:n])</span><br><span class="line">fmt.Printf(<span class="string">&quot;Received seq=%d from %v: %s\n&quot;</span>, message.Seq, addr, message.Msg)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送ACK回复给客户端，ACK=Seq+1</span></span><br><span class="line">ack := Message&#123;Seq: message.Seq + <span class="number">1</span>, Msg: <span class="string">&quot;ACK&quot;</span>&#125;</span><br><span class="line"><span class="comment">//写入ack向UDP连接中</span></span><br><span class="line">_, err = listen.WriteToUDP(encodeMessage(ack), addr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;write to %v failed,err:%v\n&quot;</span>, addr, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">encodeMessage</span><span class="params">(msg Message)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line"><span class="comment">// 将序列号和消息文本编码成字节数据</span></span><br><span class="line"><span class="keyword">return</span> []<span class="type">byte</span>(fmt.Sprintf(<span class="string">&quot;%d;%s&quot;</span>, msg.Seq, msg.Msg))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decodeMessage</span><span class="params">(data []<span class="type">byte</span>)</span></span> Message &#123;</span><br><span class="line"><span class="comment">// 解码收到的数据，提取序列号和消息文本</span></span><br><span class="line">parts := strings.Split(<span class="type">string</span>(data), <span class="string">&quot;;&quot;</span>)</span><br><span class="line">seq, _ := strconv.Atoi(parts[<span class="number">0</span>])</span><br><span class="line">msg := parts[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">return</span> Message&#123;Seq: seq, Msg: msg&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述方法实现的丢包重传虽然能够正常工作，但是发送端使用双层循环嵌套，并且每次丢包都阻塞了后续发包，这样会导致重传的效率很低，只适用于小宽带低延时的情况，而且超时重传容易产生误判，主要有以下两种情况：</p><p>对方收到了数据包，但是ack发送途中丢失，其实就是我服务器模拟丢包的情况，服务器可能收到了数据，但是因为某种原因ack没能正确发送；<br>ack在回传的途中，但是时间已经超过了发送端的ack等待时间即超过了一次RTO，这样也会导致接收端收到数据却仍然重传的问题。</p><p>学习 滑动窗口 拥塞控制 优化一些东西 深入理解seq&#x2F;ack的原理和超时重传的逻辑 Go语言进行socket编程的方法 UDP和TCP的一些知识</p><p>借鉴文章：<a href="https://blog.csdn.net/weixin_41500064/article/details/135119715">https://blog.csdn.net/weixin_41500064/article/details/135119715</a></p><h5 id="流量控制："><a href="#流量控制：" class="headerlink" title="流量控制："></a>流量控制：</h5><p>作用：为了解决发送方和接收方速度不同而导致的数据丢失问题,当发送方发送的太快,接收方来不及接受就会导致数据丢失；</p><p>方式：由接收端采用滑动窗口的形式，告知发送方允许&#x2F;停止发包解决TCP丢包问题。</p><h5 id="拥塞控制："><a href="#拥塞控制：" class="headerlink" title="拥塞控制："></a>拥塞控制：</h5><p>作用：为了解决过多的数据注入到网络导致网络崩溃和超负荷问题；</p><p>方式：由发送方采用拥塞窗口的形式去判断网络状态，从而采取不同算法执行TCP动态发包解决网络整体质量问题。</p><p>典型的场景如以太网场景中10G设备向1G设备发TCP包：<br>10G网卡 10Gbps 持续发送TCP包 交换机 以 1Gbps每秒接收TCP包<br>TCP 提供一种机制可以让发送端根据接收端的实际接收能力控制发送的数据量。这就是所谓的流控制。<br>接收端主机向发送端主机通知自已可以接收数据的大小；<br>是发送端会发送不超过这个限度的数据，该大小限度就被称作窗口大小。窗口大小的值由接收端主机决定，而在TCP 首部中，专门有一个字段用来通知窗口大小：<br>接收主机将自己可以接收的缓冲区大小放入这个字段中通知给发送端，这个字段的值越大，说明网络的吞吐量越高。<br>发送端主机会根据接收端主机的指示，对发送数据的量进行控制。这也就形成了一个完整的TCP流控制(流量控制)。<br>当Window&#x3D;0时，即告知发送方停止发送数据。</p><h5 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h5><p>发送方先探测网络拥塞程度，并不是一开始就发送大量的数据，发送方会根据拥塞程度增大拥塞窗口cwnd。<br>拥塞窗口cwnd值是几就能发送几个数据段</p><h5 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h5><p>继上图达到cwnd≥ssthresh后采用该算法用来控制拥塞窗口的增长速率。</p><p>计算方法：每经过一个传输轮次cwnd值加1，让cwnd值呈线性缓慢增大</p><h5 id="拥塞发生"><a href="#拥塞发生" class="headerlink" title="拥塞发生"></a>拥塞发生</h5><p>当网络发生拥塞丢包时（如图假定cwnd&#x3D;24），会有两种情况：</p><p>超时重传（1988年TCP Tahoe版本，已废弃不用）</p><p>更新后的 ssthresh 值变为 12(即为出现超时时的窗口数值 24 的一半)，拥窗口再重新设置为1<br>并执行慢开始算法。当cwnd &#x3D; ssthresh &#x3D; 12 时改为执行拥塞避免算法拥塞窗口按线性规律增长，<br>每经过一个往返时间增加一个MSS的大小。在TCP拥塞控制的文献中经常可看见“乘法减小”(Multiplicative Decrease)和“加法增大”(Additive Increase)这样的提法。<br>“乘法减小”是指不论在开始阶段还是拥塞避免阶段，只要出现超时(即很可能出现了网络拥塞)，就把慢开始门限值 ssthresh 减半，即设置为当前的拥塞窗口的一半(与此同时，执行慢开始算法)。<br>而“加法增大”是指执行拥塞避免算法后，使拥塞窗口缓慢增大，以防止网络过早出现拥塞。上面两种算法合起来常称为 AIMD算法(加法增大乘法减小)。</p><h5 id="快重传与快恢复"><a href="#快重传与快恢复" class="headerlink" title="快重传与快恢复"></a>快重传与快恢复</h5><p>超时重传算法直接把cwnd减小到1太过强烈，若还能收到连续3个ACK说明网络质量没那么差。同时采用快重传和快恢复算法，过程如下：</p><p>（1）当发送方连续收到3个重复确认时即执行“乘法减小”算法，把慢开始门限ssthresh 减半；</p><p>（2）由于发送方现在认为网络不那么差，于是把cwnd值设置为开始门限ssthresh 减半后的数值；</p><p>（3）开始执行拥塞避免算法 (“加法增大”)使拥塞窗口缓慢地线性增大。</p><hr><h4 id="12-25-日"><a href="#12-25-日" class="headerlink" title="12.25 日"></a>12.25 日</h4><p>根据计算机网络这本书，深入了解UDP套接字编程：</p><p>整体的一个过程： 进程间彼此通过向套接字发送报文来进行通信</p><p>一个主机-》多个进程 1个进程-》多个套接字</p><p>帮助记忆： 进程是一间房子 而 套接字是房子门 还需要一个 端口 来识别我具体要将信息发送到哪间房子，也就是具体的房间号（端口）</p><ol><li>客户从键盘键入数据，并向服务器发送数据（将数据编码成字节流），</li><li>服务器接收数据（接收字节流）-》并将其解码为原始客户端输入的数据 （并把小写转换为大写）</li><li>服务器将修改的数据（编码为字节流）发送回客户端</li><li>客户端接收数据后解码 并显示在屏幕上</li></ol><p>接收源地址（ip+端口号）和分组</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考连接： &lt;a href=&quot;https://juejin.cn/post/7263378772040122429&quot;&gt;https://juejin.cn/post/7263378772040122429&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Go语言实现UDP-socket的ac</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>操作系统学习</title>
    <link href="https://whuichenggong.github.io/2024/11/16/computer_operate/"/>
    <id>https://whuichenggong.github.io/2024/11/16/computer_operate/</id>
    <published>2024-11-16T13:26:55.040Z</published>
    <updated>2024-12-16T02:53:54.307Z</updated>
    
    <content type="html"><![CDATA[<hr><p>6.cs081os学习</p><p>感谢：</p><p>参考资料：</p><p><a href="https://www.geeksforgeeks.org/pipe-system-call/">https://www.geeksforgeeks.org/pipe-system-call/</a></p><p>很好的文章：</p><p><a href="https://swtch.com/~rsc/thread/">https://swtch.com/~rsc/thread/</a></p><p>同步机制：<a href="https://zybtree.github.io/2020/08/12/%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/">https://zybtree.github.io/2020/08/12/%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/</a></p><p>参考答案： <a href="https://github.com/relaxcn/xv6-labs-2022-solutions/blob/main/doc/utils.md">https://github.com/relaxcn/xv6-labs-2022-solutions/blob/main/doc/utils.md</a></p><p>学习链接： <a href="https://pdos.csail.mit.edu/6.828/2021/schedule.html">https://pdos.csail.mit.edu/6.828/2021/schedule.html</a></p><hr><p>直接从进程与线程入手</p><h4 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h4><p>单独的CPU变换成多个虚拟的CPU</p><h5 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h5><p>当网页请求进入的时候 先查看 网页是否在缓存中 如果不是<br>启动一个磁盘请求用来获取网页  磁盘请求会花费很多时间 等待的过程中会有更多的请求进入<br>每个进程有它自己的虚拟的CPU 真正的CPU在进程之间来回切换<br>需要一些方法例如多个磁盘 模拟控制并发 进程就能发挥作用<br>来回切换称： 多道程序设计</p><p>支持多进程的多道程序系统<br>一个核一次也只能运行一个进程</p><p><img src="/study_photo2/operater1.jpg" alt="internet.jpg"></p><hr><h4 id="12-1日"><a href="#12-1日" class="headerlink" title="12.1日"></a>12.1日</h4><h5 id="一-进程的并发执行"><a href="#一-进程的并发执行" class="headerlink" title="一.进程的并发执行"></a>一.进程的并发执行</h5><ol><li>并发</li></ol><ul><li>进程的执行是间断的</li></ul><p>每个进程的生命周期期间CPU执行 由于某种原因暂停 每个进程执行是间断性的</p><ul><li>进程的执行速度是不可预测的</li></ul><p>进程调度，有其他事件的发生，每个进程上cpu执行坑你一点时间听着再接着运行</p><ol start="2"><li>共享</li></ol><ul><li>进程线程之间的制约性<br>在一个并发环境下多个进程或者线程之间会共享某些资源，在这些资源的使用过程中会产生进程之间的一种制约性。<br>比如当一个进程享用打印机这个资源，另外一个进程在第一个进程没有释放这个资源的前提之下就得不到这个资源，那就得等待。</li></ul><ol start="3"><li>不确定性</li></ol><ul><li>进程执行的结果与其执行的相对速度有关</li></ul><p>进程执行的结果和它的相对执行速度是有关系的，因此在不同的执行顺序的情况下，进程的执行结果也是不确定的。</p><h5 id="二-进程互斥"><a href="#二-进程互斥" class="headerlink" title="二.进程互斥"></a>二.进程互斥</h5><p>由于各进程要求使用共享资源(变量、文件等)， 而这些资源需要排他性使用，<br>各进程之间竞争使用这些资源，这一关系称为进程互斥。</p><ul><li>临界资源<br>系统中某些资源一次只允许一个进程使用，称这样的资源为临界资源或互斥资源或共享变量。<br>这些程序片段，分散在不同的进程里，它们的共同的特点是对同一个共享变量进行一些操作<br>这一段代码，和另外一个进程的这一段代码互为临界区，互为互斥区</li></ul><p><img src="/study_photo2/operater2.jpg" alt="internet.jpg"></p><h4 id="冯诺依曼模型"><a href="#冯诺依曼模型" class="headerlink" title="冯诺依曼模型"></a>冯诺依曼模型</h4><p>计算机基本结构：运算器 控制器 存储器 输入设备 输出设备</p><h5 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h5><p>程序和数据都是存储在内存，存储区域是线性的</p><p>存储数据的基本单位是 字节 每一个字节对应一个内存地址</p><p>最后一个地址为内存总字节数 -1 结构就像数序中的数据</p><h5 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h5><p>也就是cpu：<br>32位cpu一次可以计算4个字节<br>64位cpu一次可以计算8个字节 位数也就是cpu的位宽 代表cpu一次可以计算的数据量</p><p>8 位的 CPU，那么一次只能计算 1 个字节也就是0~255 范围内的数值 那么 32位也就是一次可以计算出 2的32次方这么大的数值<br>cpu内部组件：寄存器，控制单元和逻辑运算单元</p><p>为什么有了内存还需要寄存器？</p><p>寄存器种类（通用寄存器）（程序计数器）（指令寄存器）</p><p>因为： 内存离 CPU 太远了，而寄存器就在 CPU 里，紧挨着控制单元和逻辑运算单元，自然计算时速度会很快。</p><h6 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h6><p>总线用于cpu和内存以及其他设备之前的通信</p><p>（地址总线）：指定CPU将要操作的内存地址</p><p>（数据总线）：用于读写内存的数据</p><p>（控制总线）： 发送和接收信号，比如中断，设备复位等信号</p><p>CPU 要读写内存数据的时候：</p><ul><li>首先要通过「地址总线」来指定内存的地址；</li><li>然后通过「控制总线」控制是读或写命令；</li><li>最后通过「数据总线」来传输数据；</li></ul><h5 id="输入输出设备"><a href="#输入输出设备" class="headerlink" title="输入输出设备"></a>输入输出设备</h5><p>输入设备向计算机输入数据，计算机经过计算后，把数据输出给输出设备。<br>如果输入设备是键盘，按下按键时是需要和 CPU 进行交互的，这时就需要用到控制总线了。</p><h5 id="线路位宽与CPU位宽"><a href="#线路位宽与CPU位宽" class="headerlink" title="线路位宽与CPU位宽"></a>线路位宽与CPU位宽</h5><p>数据是如何通过线路传输的呢<br>操作电压，低电压表示 0，高压电压则表示 1</p><p>101 二进制数据，十进制则表示 5，如果只有一条线路，就意味着每次只能传递 1 bit 的数据， 那么传输 101 这个数据，就需要 3 次才能传输完成，这样的效率非常低。</p><p>增加线路，数据并行传输</p><p>CPU 想要操作「内存地址」就需要「地址总线」：</p><p>地址总线只有 1 条，那每次只能表示 「0 或 1」这两种地址  最大数量为 2（2^1）个</p><p>如果地址总线有 2 条，那么能表示 00、01、10、11 这四种地址  最大数量为 4（2^2）个</p><p>CPU 操作 4G 大的内存，那么就需要 32 条地址总线，因为 2 ^ 32 &#x3D; 4G</p><p>CPU位宽最好不要小于线路位宽</p><h5 id="a-little-operater-systerm"><a href="#a-little-operater-systerm" class="headerlink" title="a little operater systerm"></a>a little operater systerm</h5><p>链接 ： <a href="https://lwn.net/Articles/250967/">https://lwn.net/Articles/250967/</a></p><p><img src="/study_photo2/cpumemory.4.png" alt="internet.jpg"></p><p>所有 CPU（前面的示例中为两个，但可以有更多）都通过公共总线（前端总线，FSB）连接到北桥。除其他外，北桥还包含内存控制器，<br>其实现决定了计算机使用的 RAM 芯片的类型。不同类型的 RAM，例如 DRAM、Rambus 和 SDRAM，需要不同的内存控制器。</p><p>要访问所有其他系统设备，北桥必须与南桥进行通信。南桥通常称为 I&#x2F;O 桥，通过各种不同的总线处理与设备的通信。如今，PCI、PCI Express、SATA 和 USB 总线最为重要，但南桥也支持 PATA、IEEE 1394、串行和并行端口。<br>较旧的系统具有连接到北桥的 AGP 插槽。这样做是出于与北桥和南桥之间的连接速度不够快相关的性能原因。然而，如今 PCI-E 插槽全部连接到南桥。</p><hr><h2 id="让终端显示出自己说的话"><a href="#让终端显示出自己说的话" class="headerlink" title="让终端显示出自己说的话"></a>让终端显示出自己说的话<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">root@xiaoxinxiaohao:~# vim .bashrc</span><br><span class="line">root@xiaoxinxiaohao:~# source ~/.bashrc</span><br><span class="line">赵忠鹤闪亮登场</span><br><span class="line">Today is: Fri Dec  6 05:12:09 PM CST 2024</span><br><span class="line">今天也要充满活力哇咔咔</span><br><span class="line"></span><br></pre></td></tr></table></figure></h2><p>听从了一些学习的建议，带着问题去读书，想学什么，去书中学，带着问题去读书</p><hr><p>12.16日</p><h4 id="看到了b站的一个关于Go并发设计"><a href="#看到了b站的一个关于Go并发设计" class="headerlink" title="看到了b站的一个关于Go并发设计"></a>看到了b站的一个关于Go并发设计</h4><p>了解协程： 协程是一种用户级的轻量级线程。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈</p><p>主流语言基本上都选择了多线程作为并发设施</p><p>线程相关的概念就是抢占式多任务（Preemptive multitasking），而与协程相关的是协作式多任务</p><p>多线程编程是比较困难的， 因为调度程序任何时候都能中断线程， 必须记住保留锁， 去保护程序中重要部分， 防止多线程在执行的过程中断 协程默认会做好全方位保护， 以防止中断</p><h5 id="协程相比于多线程的优点"><a href="#协程相比于多线程的优点" class="headerlink" title="协程相比于多线程的优点"></a>协程相比于多线程的优点</h5><p>无需系统内核的上下文切换，减小开销； 因为：协程它不像线程和进程那样，需要进行系统内核上的上下文切换，协程的上下文切换是由开发人员决定的</p><p>无需原子操作锁定及同步的开销，不用担心资源共享的问题</p><p>单线程即可实现高并发，单核 CPU 即便支持上万的协程都不是问题，所以很适合用于高并发处理，尤其是在应用在网络爬虫中</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol><li>无法使用 CPU 的多核 因为： 协程的本质是个单线程</li><li>写协程就意味着你要一值写一些非阻塞的代码，使用各种异步版本的库，比如后面的异步爬虫教程中用的 aiohttp</li><li><strong>协程的概念最核心的点其实就是函数或者一段程序能够被挂起（说暂停其实也没啥问题），待会儿再恢复</strong></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;6.cs081os学习&lt;/p&gt;
&lt;p&gt;感谢：&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geeksforgeeks.org/pipe-system-call/&quot;&gt;https://www.geeksforgeeks.org/p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>20岁生日</title>
    <link href="https://whuichenggong.github.io/2024/11/16/live/"/>
    <id>https://whuichenggong.github.io/2024/11/16/live/</id>
    <published>2024-11-16T12:06:31.864Z</published>
    <updated>2024-11-16T12:24:16.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="生活的意义就是在于享受每一天，有开心，有难过，有惊喜！-享受它，生活就是这样！"><a href="#生活的意义就是在于享受每一天，有开心，有难过，有惊喜！-享受它，生活就是这样！" class="headerlink" title="生活的意义就是在于享受每一天，有开心，有难过，有惊喜！ 享受它，生活就是这样！"></a>生活的意义就是在于享受每一天，有开心，有难过，有惊喜！ 享受它，生活就是这样！</h2><p>有了博客可以让时间更具象化，留住每一刻，想看的时候翻一翻 感受真的不一样！</p><p>本来不想过生日的，但还是被寝室的兄弟们发现了哈哈哈哈好开心呢上大学的两年都收到了寝室5个兄弟给我送的蛋糕<br>感谢你们啦，尽管离开了家还是有人陪你过生日，非常开心，还是你们陪我走完大学四年<br>上高中的时候也没怎么正经过过生日，到了大学是你们让我的今天变得过呢更有意义，尽管在生活中有磕碰，但那是难以避免的！希望你们每个人以后路越来越好</p><p>也是收到家里人的好多红包啊哈哈啊哈好开心！ 感谢家人时刻牵挂着我！</p><h3 id="2023年的今天"><a href="#2023年的今天" class="headerlink" title="2023年的今天"></a>2023年的今天</h3><p><img src="/live/birsday.jpg" alt="生日"></p><h3 id="2024年的今天"><a href="#2024年的今天" class="headerlink" title="2024年的今天"></a>2024年的今天</h3><p><img src="/live/cake.jpg" alt="蛋糕"></p><hr><p>每年的生日许愿都是很广泛的 我姐说那是没有意义的哈哈哈一定要为自己许个愿望在新的一年实现它！</p><h3 id="小彩蛋"><a href="#小彩蛋" class="headerlink" title="小彩蛋"></a>小彩蛋</h3><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="/live/birsday.mp4" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><pre><code>11.16日</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;生活的意义就是在于享受每一天，有开心，有难过，有惊喜！-享受它，生活就是这样！&quot;&gt;&lt;a href=&quot;#生活的意义就是在于享受每一天，有开心，有难过，有惊喜！-享受它，生活就是这样！&quot; class=&quot;headerlink&quot; title=&quot;生活的意义就是在于享受每一天</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>7_days_golang学习</title>
    <link href="https://whuichenggong.github.io/2024/11/16/Goalng_Framework/"/>
    <id>https://whuichenggong.github.io/2024/11/16/Goalng_Framework/</id>
    <published>2024-11-16T11:46:47.251Z</published>
    <updated>2024-11-27T12:47:04.152Z</updated>
    
    <content type="html"><![CDATA[<h2 id="通过学习项目-7-days-golang搭建各种自己的框架了解一些网络工作原理和知识"><a href="#通过学习项目-7-days-golang搭建各种自己的框架了解一些网络工作原理和知识" class="headerlink" title="通过学习项目 7_days_golang搭建各种自己的框架了解一些网络工作原理和知识"></a>通过学习项目 7_days_golang搭建各种自己的框架了解一些网络工作原理和知识</h2><p>学习geektutu源代码：<a href="https://github.com/geektutu/7days-golang">https://github.com/geektutu/7days-golang</a></p><p>跟着学习的项目代码已经放在: <a href="https://github.com/Whuichenggong/Study_Go">https://github.com/Whuichenggong/Study_Go</a></p><h3 id="1-gee-go"><a href="#1-gee-go" class="headerlink" title="1.gee.go"></a>1.gee.go</h3><p>关键代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gee</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//首先定义了类型HandlerFunc，这是提供给框架用户的，用来定义路由映射的处理方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(http.ResponseWriter, *http.Request)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Engine中，添加了一张路由映射表router</span></span><br><span class="line"><span class="comment">// key 由请求方法和静态路由地址构成，例如GET-/、GET-/hello、POST-/hello</span></span><br><span class="line"><span class="comment">// 如果请求方法不同,可以映射不同的处理方法(Handler)，value 是用户映射的处理方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">router <span class="keyword">map</span>[<span class="type">string</span>]HandlerFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New is the constructor of gee.Engine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span></span> *Engine &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Engine&#123;router: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]HandlerFunc)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> addRoute(method <span class="type">string</span>, pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">key := method + pattern</span><br><span class="line">engine.router[key] = handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户调用(*Engine).GET()方法时，会将路由和处理方法注册到映射表 router 中，(*Engine).Run()方法，是 ListenAndServe 的包装。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> GET(pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">engine.addRoute(<span class="string">&quot;GET&quot;</span>, pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> POST(pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">engine.addRoute(<span class="string">&quot;POST&quot;</span>, pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> Run(addr <span class="type">string</span>) (err <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> http.ListenAndServe(addr, engine)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Engine实现的 ServeHTTP 方法的作用就是，解析请求的路径，查找路由映射表，如果查到，就执行注册的处理方法。如果查不到，就返回 404 NOT FOUND 。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">key := req.URL.Path</span><br><span class="line"><span class="keyword">if</span> handler, ok := engine.router[key]; ok &#123;</span><br><span class="line">handler(w, req)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;404 Not Found: %s\n&quot;</span>, req.URL)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-go-mod代码"><a href="#2-go-mod代码" class="headerlink" title="2.go.mod代码"></a>2.go.mod代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module github.com/Whuichenggong</span><br><span class="line"></span><br><span class="line">go 1.22.1</span><br><span class="line"></span><br><span class="line">require gee v0.0.0</span><br><span class="line"></span><br><span class="line">replace gee =&gt; ./gee</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>replace gee &#x3D;&gt; .&#x2F;gee</p><p>这是一个替换指令，它告诉 Go 工具链用本地相对路径 .&#x2F;gee 中的 gee 包替换远程需要的 gee 包。<br>这意味着，尽管 require 指令可能指向一个特定的远程版本或分支，<br>这个 replace 指令实际上将使用当前目录下的 gee 文件夹中的代码。</p><h4 id="2-1初始化-Go-模块："><a href="#2-1初始化-Go-模块：" class="headerlink" title="2.1初始化 Go 模块："></a>2.1初始化 Go 模块：</h4><p>如果你的项目还没有被初始化为 Go 模块，你需要先在项目的根目录下运行以下命令来初始化它：</p><p><code>go mod init &lt;module-name&gt;</code></p><p>替换 <module-name> 为你的模块名称。例如，如果你的项目名称是 example，你会运行：</p><p><code>go mod init example</code></p><h3 id="3-main-go"><a href="#3-main-go" class="headerlink" title="3.main.go"></a>3.main.go</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line"></span><br><span class="line">&quot;gee&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">r := gee.New()</span><br><span class="line">r.GET(&quot;/&quot;, func(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">fmt.Fprintf(w, &quot;URL.Path = %q\n&quot;, req.URL.Path)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.GET(&quot;/hello&quot;, func(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">for k, v := range req.Header &#123;</span><br><span class="line">fmt.Fprintf(w, &quot;Header[%q] = %q\n&quot;, k, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.Run(&quot;:9999&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="新增："><a href="#新增：" class="headerlink" title="新增："></a>新增：</h5><p>测试 POST 请求<br>启动服务器后，测试 POST 请求可以使用以下工具：</p><p>方法 1: 使用 curl<br>执行以下命令发送 POST 请求：</p><p>curl -X POST <a href="http://localhost:8080/submit">http://localhost:8080/submit</a></p><hr><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(http.ResponseWriter, *http.Request)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">router <span class="keyword">map</span>[<span class="type">string</span>]HandlerFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span></span> *Engine &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Engine&#123;router: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]HandlerFunc)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> addRoute(method <span class="type">string</span>, pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">key := method + pattern</span><br><span class="line">engine.router[key] = handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> POST(pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">engine.addRoute(<span class="string">&quot;POST&quot;</span>, pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> Run(addr <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">return</span> http.ListenAndServe(addr, engine)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">key := req.Method + req.URL.Path</span><br><span class="line"><span class="keyword">if</span> handler, ok := engine.router[key]; ok &#123;</span><br><span class="line">handler(w, req)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">http.NotFound(w, req)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>func main() {<br>engine :&#x3D; New()</p><pre><code>// 注册一个 POST 路由engine.POST(&quot;/submit&quot;, func(w http.ResponseWriter, req *http.Request) &#123;    // 读取请求体数据    body, err := ioutil.ReadAll(req.Body)    if err != nil &#123;        http.Error(w, &quot;Failed to read request body&quot;, http.StatusInternalServerError)        return    &#125;    // 响应请求体内容    fmt.Fprintf(w, &quot;Received: %s&quot;, string(body))&#125;)// 启动服务器engine.Run(&quot;:8080&quot;)</code></pre><p>}<br>测试：<br>启动程序后，用 curl 发送 POST 请求并附带数据：</p><p>b<br>curl -X POST -d “data&#x3D;HelloWorld” <a href="http://localhost:8080/submit">http://localhost:8080/submit</a><br>服务器返回：</p><p>kotlin</p><p>Received: data&#x3D;HelloWorld</p><h4 id="ServeHTTP好像有点问题"><a href="#ServeHTTP好像有点问题" class="headerlink" title="ServeHTTP好像有点问题"></a>ServeHTTP好像有点问题</h4><p>main.go<br>附带了对代码的理解</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gee</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//首先定义了类型HandlerFunc，这是提供给框架用户的，用来定义路由映射的处理方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(http.ResponseWriter, *http.Request)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Engine中，添加了一张路由映射表router</span></span><br><span class="line"><span class="comment">// key 由请求方法和静态路由地址构成，例如GET-/、GET-/hello、POST-/hello</span></span><br><span class="line"><span class="comment">// 如果请求方法不同,可以映射不同的处理方法(Handler)，value 是用户映射的处理方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">router <span class="keyword">map</span>[<span class="type">string</span>]HandlerFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New is the constructor of gee.Engine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span></span> *Engine &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Engine&#123;router: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]HandlerFunc)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这段代码的作用将HTTP请求的路由和对应的处理函数注册到路由表中的核心方法</span></span><br><span class="line"><span class="comment">// pattern路由路径</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> addRoute(method <span class="type">string</span>, pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line"><span class="comment">//将HTTp方法和路径拼接成唯一一个键 作为路由表的router的键</span></span><br><span class="line">key := method + pattern</span><br><span class="line"><span class="comment">//将处理函数 handler 存入路由表中，关联到对应的路由键。</span></span><br><span class="line">engine.router[key] = handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户调用 addRoute(&quot;GET&quot;, &quot;/home&quot;, someHandlerFunc) 在 engine.router 映射表中，会存储一个键值对：</span></span><br><span class="line"><span class="comment">// 调用engine.GET(&quot;/home&quot;, someHandlerFunc)： 实际是 等价 engine.addRoute(&quot;GET&quot;, &quot;/home&quot;, someHandlerFunc)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> GET(pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">engine.addRoute(<span class="string">&quot;GET&quot;</span>, pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> POST(pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">engine.addRoute(<span class="string">&quot;POST&quot;</span>, pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这段代码隐藏了调用ServeHTTP</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> Run(addr <span class="type">string</span>) (err <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> http.ListenAndServe(addr, engine)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Engine实现的 ServeHTTP 方法的作用就是，解析请求的路径，查找路由映射表，如果查到，就执行注册的处理方法。如果查不到，就返回 404 NOT FOUND 。</span></span><br><span class="line"><span class="comment">// 不需要显式调用 ServeHTTP</span></span><br><span class="line"><span class="comment">// 在 Go 的 HTTP 框架中，ServeHTTP 是 http.Handler 接口的约定方法。当你把 Engine 作为服务器的处理器传递时，它会被 ListenAndServe 自动调用。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">key := req.URL.Path</span><br><span class="line"><span class="keyword">if</span> handler, ok := engine.router[key]; ok &#123;</span><br><span class="line">handler(w, req)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;404 Not Found: %s\n&quot;</span>, req.URL)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>在 ServeHTTP 中，当前只从 req.URL.Path 获取路径，<br>而没有结合 req.Method，会导致不同的 HTTP 方法（如 GET 和 POST）冲突或无法正确匹配。<br>addRoute 方法仅使用了路径（pattern）和方法（method）拼接为路由键，例如：GET&#x2F;home。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> addRoute(method <span class="type">string</span>, pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">    key := method + <span class="string">&quot;-&quot;</span> + pattern <span class="comment">// 区分 HTTP 方法和路径</span></span><br><span class="line">    engine.router[key] = handler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改的这段代码<br>原来只使用了路径（req.URL.Path）作为路由键。例如：</p><p>请求路径 &#x2F;hello 的键为 &#x2F;hello。<br>不区分 GET &#x2F;hello 和 POST &#x2F;hello，它们会共用同一个路由键 &#x2F;hello。<br>建议的代码<br>使用 HTTP 方法和路径 拼接成路由键。例如：</p><p>GET &#x2F;hello 的键为 GET-&#x2F;hello。<br>POST &#x2F;hello 的键为 POST-&#x2F;hello。<br>这样可以区分不同方法对应的路由处理函数。</p><p>与gin框架启动很相似</p><hr><p>对Web服务来说，无非是根据请求*http.Request，构造响应http.ResponseWriter。<br>但是这两个对象提供的接口粒度太细，比如我们要构造一个完整的响应，需要考虑消息头(Header)和消息体(Body)，而 Header 包含了状态码(StatusCode)，<br>消息类型(ContentType)等几乎每次请求都需要设置的信息。因此，如果不进行有效的封装， 那么框架的用户将需要写大量重复，繁杂的代码<br>且容易出错。针对常用场景，能够高效地构造出 HTTP 响应是一个好的框架必须考虑的点。</p><p>代码要学会封装 否则代码整洁度看起来还是会差很多的 对于别人理解一会更方便</p><p>为什么要添加context  对于框架来说，还需要支撑额外的功能。例如，将来解析动态路由&#x2F;hello&#x2F;:name，参数:name的值放在哪呢？<br>再比如，框架需要支持中间件，那中间件产生的信息放在哪呢？</p><p>contxet保留了你想寻找的一些东西<br>拓展性和复杂性留在内部<br>对外简化了接口。</p><p>Context 的作用是为每个 HTTP 请求提供一个上下文对象，<br>方便操作请求和响应，并提供了一些简化开发的工具方法。<br>通过 Context 统一管理 HTTP 请求和响应的逻辑。</p><p>可以把 Context 看作是：</p><p>一个请求的容器： 它封装了与 HTTP 请求相关的所有信息，并提供了一些方法让你更轻松地操作这些信息。</p><p>开发者和 HTTP 请求的桥梁： 开发者通过 Context 与客户端通信，包括读取请求信息和发送响应。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(c *Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 获取查询参数</span></span><br><span class="line">name := c.Query(<span class="string">&quot;name&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造 JSON 响应</span></span><br><span class="line">    <span class="keyword">if</span> name != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        c.JSON(http.StatusOK, H&#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello &quot;</span> + name&#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        c.String(http.StatusBadRequest, <span class="string">&quot;Name is required&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>深入框架原理：<br>阅读 Gin、Echo 等框架的源码，了解它们如何设计和扩展 Context。</li></ol><p>尝试扩展功能：<br>在 Context 上添加自定义方法，比如记录日志、追踪请求 ID 等。</p><ol start="2"><li>http.ResponseWriter 和 *http.Request 的实际意义<br>http.ResponseWriter</li></ol><p>作用：<br>代表服务端用来写入 HTTP 响应的接口。开发者通过它向客户端返回数据（如响应头、响应状态码、响应体等）。<br>实际应用：<br>在服务端，http.ResponseWriter 将生成的 HTTP 响应数据写入 TCP 连接的输出流，客户端会接收到这些数据并解析呈现。<br>*http.Request</p><p>作用：<br>表示客户端发来的 HTTP 请求，包含了所有请求相关的信息（如 URL、方法、头部、表单数据、Cookie、Body 等）。<br>实际应用：<br>服务端根据 *http.Request 的内容（路径、方法等），判断客户端的需求并生成相应的响应。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line"><span class="comment">// 设置响应头</span></span><br><span class="line">w.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/plain&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置状态码</span></span><br><span class="line">w.WriteHeader(http.StatusOK)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入响应体</span></span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;Hello, %s!\n&quot;</span>, req.URL.Query().Get(<span class="string">&quot;name&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/&quot;</span>, handler)</span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端请求示例：</p><p>浏览器访问 <a href="http://localhost:8080/?name=zhaozhonghe">http://localhost:8080/?name=zhaozhonghe</a></p><p>服务端响应：</p><p>HTTP&#x2F;1.1 200 OK &#x2F;&#x2F;设置的状态码 200<br>Content-Type: text&#x2F;plain &#x2F;&#x2F;设置的请求头 响应过来了 并且返回到了 客户端页面<br>Content-Length: 12</p><p>Hello, zhaozhonghe! &#x2F;&#x2F; 读取 HTTP 请求 将数据写入响应体，通过 w 发送给客户端。</p><hr><h3 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h3><h4 id="1-添加context"><a href="#1-添加context" class="headerlink" title="1.添加context"></a>1.添加context</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gee</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//对Web服务来说，无非是根据请求*http.Request，构造响应http.ResponseWriter</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给map[string]interface&#123;&#125;起了一个别名gee.H，构建JSON数据时，显得更简洁。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> H <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Context目前只包含了http.ResponseWriter和*http.Request，另外提供了对 Method 和 Path 这两个常用属性的直接访问。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line">Writer http.ResponseWriter</span><br><span class="line">Req    *http.Request</span><br><span class="line"></span><br><span class="line">Path   <span class="type">string</span></span><br><span class="line">Method <span class="type">string</span></span><br><span class="line"></span><br><span class="line">StatusCode <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newContext</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> *Context &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Context&#123;</span><br><span class="line">Writer: w,</span><br><span class="line">Req:    req,</span><br><span class="line">Path:   req.URL.Path,</span><br><span class="line">Method: req.Method,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供了访问Query和PostForm参数的方法。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> PostForm(key <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.Req.FormValue(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> Query(key <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.Req.URL.Query().Get(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> Status(code <span class="type">int</span>) &#123;</span><br><span class="line">c.StatusCode = code</span><br><span class="line">c.Writer.WriteHeader(code)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> SetHeader(key <span class="type">string</span>, value <span class="type">string</span>) &#123;</span><br><span class="line">c.Writer.Header().Set(key, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供了快速构造String/Data/JSON/HTML响应的方法。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> String(code <span class="type">int</span>, format <span class="type">string</span>, values ...<span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">c.SetHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/plain&quot;</span>)</span><br><span class="line">c.Status(code)</span><br><span class="line">c.Writer.Write([]<span class="type">byte</span>(fmt.Sprintf(format, values...)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> JSON(code <span class="type">int</span>, obj <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">c.SetHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">c.Status(code)</span><br><span class="line">encoder := json.NewEncoder(c.Writer)</span><br><span class="line"><span class="keyword">if</span> err := encoder.Encode(obj); err != <span class="literal">nil</span> &#123;</span><br><span class="line">http.Error(c.Writer, err.Error(), <span class="number">500</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> Data(code <span class="type">int</span>, data []<span class="type">byte</span>) &#123;</span><br><span class="line">c.Status(code)</span><br><span class="line">c.Writer.Write(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> HTML(code <span class="type">int</span>, html <span class="type">string</span>) &#123;</span><br><span class="line">c.SetHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/html&quot;</span>)</span><br><span class="line">c.Status(code)</span><br><span class="line">c.Writer.Write([]<span class="type">byte</span>(html))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-添加router"><a href="#2-添加router" class="headerlink" title="2.添加router"></a>2.添加router</h4><p>想 路由需要的参数 路径 方法 处理函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gee</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> router <span class="keyword">struct</span> &#123;</span><br><span class="line">handlers <span class="keyword">map</span>[<span class="type">string</span>]HandlerFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newRouter</span><span class="params">()</span></span> *router &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;router&#123;handlers: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]HandlerFunc)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *router)</span></span> addRoute(method <span class="type">string</span>, pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Route %4s - %s&quot;</span>, method, pattern)</span><br><span class="line">key := method + <span class="string">&quot;-&quot;</span> + pattern</span><br><span class="line">r.handlers[key] = handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *router)</span></span> handle(c *Context) &#123;</span><br><span class="line">key := c.Method + <span class="string">&quot;-&quot;</span> + c.Path</span><br><span class="line"><span class="keyword">if</span> handler, ok := r.handlers[key]; ok &#123;</span><br><span class="line">handler(c)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.String(http.StatusNotFound, <span class="string">&quot;404 NOT FOUND: %s\n&quot;</span>, c.Path)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>r.handlers[key] &#x3D; handler 这段代码将key也就是路径 和 处理函数关连到了一起</p><p>post用终端请求<br>1.<br>Invoke-WebRequest -Uri “<a href="http://localhost:9999/login">http://localhost:9999/login</a>“ -Method POST -Body “username&#x3D;zhaozhonghe&amp;password&#x3D;zzh123456”</p><ol start="2"><li>curl.exe -X POST -d “username&#x3D;zhaozhonghe&amp;password&#x3D;zzh123456” <a href="http://localhost:9999/login">http://localhost:9999/login</a><br>返回结果<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;password&quot;:&quot;zzh123456&quot;,&quot;username&quot;:&quot;zhaozhonghe&quot;&#125;</span><br></pre></td></tr></table></figure></li></ol><p>测试第二天的gee<br>第一种返回结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">StatusCode        : 200</span><br><span class="line">StatusDescription : OK</span><br><span class="line">Content           : &#123;&quot;password&quot;:&quot;zzh123456&quot;,&quot;username&quot;:&quot;zhaozhonghe&quot;&#125;</span><br><span class="line"></span><br><span class="line">RawContent        : HTTP/1.1 200 OK</span><br><span class="line">Content-Length: 50</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Date: Tue, 26 Nov 2024 13:43:37 GMT</span><br><span class="line"></span><br><span class="line">                    &#123;&quot;password&quot;:&quot;zzh123456&quot;,&quot;username&quot;:&quot;zhaozhonghe&quot;&#125;</span><br><span class="line"></span><br><span class="line">Forms             : &#123;&#125;</span><br><span class="line">Headers           : &#123;[Content-Length, 50], [Content-Type, application/json], [Date, Tue, 26 Nov 2024 13:43:37 GMT]&#125;</span><br><span class="line">Images            : &#123;&#125;</span><br><span class="line">InputFields       : &#123;&#125;</span><br><span class="line">Links             : &#123;&#125;</span><br><span class="line">ParsedHtml        : mshtml.HTMLDocumentClass</span><br><span class="line">RawContentLength  : 50</span><br></pre></td></tr></table></figure><h4 id="gee-go"><a href="#gee-go" class="headerlink" title="gee.go"></a>gee.go</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gee</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HandlerFunc defines the request handler used by gee</span></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(*Context)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Engine implement the interface of ServeHTTP</span></span><br><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">router *router</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New is the constructor of gee.Engine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span></span> *Engine &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Engine&#123;router: newRouter()&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> addRoute(method <span class="type">string</span>, pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">engine.router.addRoute(method, pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GET defines the method to add GET request</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> GET(pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">engine.addRoute(<span class="string">&quot;GET&quot;</span>, pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// POST defines the method to add POST request</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> POST(pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">engine.addRoute(<span class="string">&quot;POST&quot;</span>, pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run defines the method to start a http server</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> Run(addr <span class="type">string</span>) (err <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> http.ListenAndServe(addr, engine)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">c := newContext(w, req)</span><br><span class="line">engine.router.handle(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h2><p>我们用了一个非常简单的map结构存储了路由表，使用map存储键值对，索引非常高效，但是有一个弊端，键值对的存储的方式，只能用来索引静态路由。<br>那如果我们想支持类似于&#x2F;hello&#x2F;:name这样的动态路由怎么办呢？<br>所谓动态路由，即一条路由规则可以匹配某一类型而非某一条固定的路由。<br>例如&#x2F;hello&#x2F;:name，可以匹配&#x2F;hello&#x2F;geektutu、hello&#x2F;jack等。<br>请等待~~~</p><p>11.21日看到了字节的课 是关于动态路由的设计 前缀匹配树</p><h4 id="router-go"><a href="#router-go" class="headerlink" title="router.go"></a>router.go</h4><p>前缀树路由： 重点学习这个数据结构</p><p>bilibili: <a href="https://www.bilibili.com/video/BV1wT4y1x7xm?t=45.6">https://www.bilibili.com/video/BV1wT4y1x7xm?t=45.6</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gee</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> router <span class="keyword">struct</span> &#123;</span><br><span class="line">roots    <span class="keyword">map</span>[<span class="type">string</span>]*node <span class="comment">//增加的</span></span><br><span class="line">handlers <span class="keyword">map</span>[<span class="type">string</span>]HandlerFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newRouter</span><span class="params">()</span></span> *router &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;router&#123;</span><br><span class="line">roots:    <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*node),</span><br><span class="line">handlers: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]HandlerFunc),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Only one * is allowed</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parsePattern</span><span class="params">(pattern <span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">vs := strings.Split(pattern, <span class="string">&quot;/&quot;</span>)</span><br><span class="line"></span><br><span class="line">parts := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> vs &#123;</span><br><span class="line"><span class="keyword">if</span> item != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">parts = <span class="built_in">append</span>(parts, item)</span><br><span class="line"><span class="keyword">if</span> item[<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> parts</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *router)</span></span> addRoute(method <span class="type">string</span>, pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">parts := parsePattern(pattern)</span><br><span class="line"></span><br><span class="line">key := method + <span class="string">&quot;-&quot;</span> + pattern</span><br><span class="line">_, ok := r.roots[method]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">r.roots[method] = &amp;node&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">r.roots[method].insert(pattern, parts, <span class="number">0</span>)</span><br><span class="line">r.handlers[key] = handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *router)</span></span> getRoute(method <span class="type">string</span>, path <span class="type">string</span>) (*node, <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>) &#123;</span><br><span class="line">searchParts := parsePattern(path)</span><br><span class="line">params := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">root, ok := r.roots[method]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n := root.search(searchParts, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> n != <span class="literal">nil</span> &#123;</span><br><span class="line">parts := parsePattern(n.pattern)</span><br><span class="line"><span class="keyword">for</span> index, part := <span class="keyword">range</span> parts &#123;</span><br><span class="line"><span class="keyword">if</span> part[<span class="number">0</span>] == <span class="string">&#x27;:&#x27;</span> &#123;</span><br><span class="line">params[part[<span class="number">1</span>:]] = searchParts[index]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> part[<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; <span class="built_in">len</span>(part) &gt; <span class="number">1</span> &#123;</span><br><span class="line">params[part[<span class="number">1</span>:]] = strings.Join(searchParts[index:], <span class="string">&quot;/&quot;</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n, params</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *router)</span></span> getRoutes(method <span class="type">string</span>) []*node &#123;</span><br><span class="line">root, ok := r.roots[method]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">nodes := <span class="built_in">make</span>([]*node, <span class="number">0</span>)</span><br><span class="line">root.travel(&amp;nodes)</span><br><span class="line"><span class="keyword">return</span> nodes</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *router)</span></span> handle(c *Context) &#123;</span><br><span class="line">n, params := r.getRoute(c.Method, c.Path)</span><br><span class="line"><span class="keyword">if</span> n != <span class="literal">nil</span> &#123;</span><br><span class="line">c.Params = params</span><br><span class="line">key := c.Method + <span class="string">&quot;-&quot;</span> + n.pattern</span><br><span class="line">r.handlers[key](c)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.String(http.StatusNotFound, <span class="string">&quot;404 NOT FOUND: %s\n&quot;</span>, c.Path)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>parsePattern 函数的作用是解析路由路径，将路径按 &#x2F; 分隔成各个部分。比如 &#x2F;user&#x2F;:id 会被分解成 [“user”, “:id”]。<br>如果路径中出现了 *（通常用于匹配任意多的路径部分），解析会在遇到 * 时停止。比如 &#x2F;files&#x2F;*filepath 会解析成 [“files”, “*filepath”]。<br>parts 数组存储了路由路径的各个部分（如静态部分、动态部分、通配符部分）</p><h5 id="tire-go"><a href="#tire-go" class="headerlink" title="tire.go"></a>tire.go</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gee</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">pattern  <span class="type">string</span></span><br><span class="line">part     <span class="type">string</span></span><br><span class="line">children []*node</span><br><span class="line">isWild   <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;node&#123;pattern=%s, part=%s, isWild=%t&#125;&quot;</span>, n.pattern, n.part, n.isWild)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span></span> insert(pattern <span class="type">string</span>, parts []<span class="type">string</span>, height <span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(parts) == height &#123;</span><br><span class="line">n.pattern = pattern</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">part := parts[height]</span><br><span class="line">children := n.matchChildren(part)</span><br><span class="line"><span class="keyword">var</span> child *node</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(children) == <span class="number">0</span> &#123;</span><br><span class="line">child = &amp;node&#123;part: part, isWild: part[<span class="number">0</span>] == <span class="string">&#x27;:&#x27;</span> || part[<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span>&#125;</span><br><span class="line">n.children = <span class="built_in">append</span>(n.children, child)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">child = children[<span class="number">0</span>] <span class="comment">// 假设我们总是取第一个匹配的子节点</span></span><br><span class="line">&#125;</span><br><span class="line">child.insert(pattern, parts, height+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span></span> search(parts []<span class="type">string</span>, height <span class="type">int</span>) *node &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(parts) == height || strings.HasPrefix(n.part, <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> n.pattern == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">part := parts[height]</span><br><span class="line">children := n.matchChildren(part)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, child := <span class="keyword">range</span> children &#123;</span><br><span class="line">result := child.search(parts, height+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> result != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span></span> travel(list *([]*node)) &#123;</span><br><span class="line"><span class="keyword">if</span> n.pattern != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">*list = <span class="built_in">append</span>(*list, n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, child := <span class="keyword">range</span> n.children &#123;</span><br><span class="line">child.travel(list)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span></span> matchChild(part <span class="type">string</span>) *node &#123;</span><br><span class="line"><span class="keyword">for</span> _, child := <span class="keyword">range</span> n.children &#123;</span><br><span class="line"><span class="keyword">if</span> child.part == part || child.isWild &#123;</span><br><span class="line"><span class="keyword">return</span> child</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span></span> matchChildren(part <span class="type">string</span>) []*node &#123;</span><br><span class="line">nodes := <span class="built_in">make</span>([]*node, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> _, child := <span class="keyword">range</span> n.children &#123;</span><br><span class="line"><span class="keyword">if</span> child.part == part || child.isWild &#123;</span><br><span class="line">nodes = <span class="built_in">append</span>(nodes, child)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nodes</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先学习一下前缀树</p><h5 id="定义树结点结构体"><a href="#定义树结点结构体" class="headerlink" title="定义树结点结构体"></a>定义树结点结构体</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> trieNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    nexts [<span class="number">26</span>]*trieNode</span><br><span class="line">    PassCnt <span class="type">int</span> <span class="comment">//用来记录中途是否有途径某个节点的个数</span></span><br><span class="line">    end <span class="type">bool</span> <span class="comment">//匹配某个单词是否是结尾 比如seat的结尾是t</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>树</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Trie <span class="keyword">struct</span> &#123;</span><br><span class="line">    root *trieNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Newtrie</span> *<span class="title">Trie</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Trie&#123;</span><br><span class="line">    root: &amp;trieNode&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> Search(word <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">//查找目标节点，使根节点开始抵达目标节点沿路跟字符串恰好等于word</span></span><br><span class="line">    node := t.search(word)</span><br><span class="line">    <span class="keyword">return</span> node != <span class="literal">nil</span> &amp;&amp; node.end</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Tire-search-方法源码"><a href="#Tire-search-方法源码" class="headerlink" title="Tire.search 方法源码"></a>Tire.search 方法源码</h5><p>字符➖a<br>如果返回的单词是 前缀树中的别的单词的前缀判断</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span>search(target <span class="type">string</span>)*trieNode&#123;</span><br><span class="line"><span class="comment">//移动指针从根节点出发</span></span><br><span class="line">move :t.root</span><br><span class="line">/依次追历target中的每个字符</span><br><span class="line">for_, ch:<span class="keyword">range</span> target&#123;</span><br><span class="line"><span class="comment">//倘若nexts中不存在对应于这个字符的节点，说明该单词没插入过，返回ni1</span></span><br><span class="line"><span class="keyword">if</span> move.nexts[ch-<span class="string">&#x27;a&#x27;</span>]==<span class="literal">nil</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指针向着子节点移动</span></span><br><span class="line">movemove.nexts [ch-<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//来到末尾，说明已经完全匹配好单词，直接返回这个节点</span></span><br><span class="line"><span class="comment">//需要注意，找到目标节点不一定代表单词存在，因为该节点的end标识未必为true</span></span><br><span class="line"><span class="comment">//比如我们之前往trie中插入了apple这个单词，但是查找app这个单词时，预期的返回</span></span><br><span class="line"><span class="keyword">return</span> move</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="前缀匹配"><a href="#前缀匹配" class="headerlink" title="前缀匹配"></a>前缀匹配</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前缀树做前缀匹配很简单</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> StartWith(prefix(<span class="type">string</span>)) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.search(prefix) != <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="前缀统计"><a href="#前缀统计" class="headerlink" title="前缀统计"></a>前缀统计</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> PassCnt(prefix <span class="type">string</span>) <span class="type">int</span>&#123;</span><br><span class="line">    node := t.search(prefix)</span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>  </span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> node.PassCnt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="插入单词"><a href="#插入单词" class="headerlink" title="插入单词"></a>插入单词</h5><p>例子： 要插入apple 树中app可以复用<br>    则插入 l e</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> Insert(word <span class="type">string</span>) &#123;</span><br><span class="line"><span class="comment">//如果单词存在直接返回</span></span><br><span class="line">    <span class="keyword">if</span> t.Search(word)&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">        move := t.root</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _,ch := <span class="keyword">range</span> word &#123;</span><br><span class="line"><span class="comment">//如果不存在创建出来</span></span><br><span class="line">    <span class="keyword">if</span> move.nexts[ch-<span class="string">&#x27;a&#x27;</span>] == <span class="literal">nil</span> &#123;</span><br><span class="line">    move.nexts[ch-<span class="string">&#x27;a&#x27;</span>] = &amp;trieNode&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">    move.nexts[ch-<span class="string">&#x27;a&#x27;</span>].passCnt++</span><br><span class="line">    move = move.nexts[ch-<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"></span><br><span class="line">move.end =<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="删除流程"><a href="#删除流程" class="headerlink" title="删除流程"></a>删除流程</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> Erase(word <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !t.Search(word)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">  move := t.root</span><br><span class="line">    <span class="keyword">for</span> _, ch := <span class="keyword">range</span> word &#123;</span><br><span class="line">    move.nexts[ch-<span class="string">&#x27;a&#x27;</span>].passCnt --</span><br><span class="line"><span class="keyword">if</span> move.nexts[ch-<span class="string">&#x27;a&#x27;</span>].passCnt == <span class="number">0</span> &#123;</span><br><span class="line">    move.nexts[ch-<span class="string">&#x27;a&#x27;</span>] = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">    move = move.nexts[ch-<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    move.end = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>整段代码下来还是有点看不懂啊呜呜</p><p>11.25日<br>拖了几天<br>感谢tutu</p><h4 id="分组控制"><a href="#分组控制" class="headerlink" title="分组控制"></a>分组控制</h4><p>分组控制是Web框架的基础功能之一，路由的分组，往往某一组路由需要相似的处理</p><p>以&#x2F;post开头的路由匿名可访问。<br>以&#x2F;admin开头的路由需要鉴权。<br>以&#x2F;api开头的路由是 RESTful 接口，可以对接第三方平台，需要三方平台鉴权。</p><p>&#x2F;post是一个分组<br>&#x2F;post&#x2F;a和&#x2F;post&#x2F;b可以是该分组下的子分组<br>作用在&#x2F;post分组上的中间件(middleware)，也都会作用在子分组，子分组还可以应用自己特有的中间件。</p><p>中间件可以给框架提供无限的扩展能力<br>用在分组上的效果也更明显<br>&#x2F;admin的分组，可以应用鉴权中间件；&#x2F;分组应用日志中间件，<br>&#x2F;是默认的最顶层的分组，也就意味着给所有的路由，即整个框架增加了记录日志的能力。</p><p>一个 Group 对象需要具备哪些属性呢？首先是前缀(prefix)，<br>比如&#x2F;，或者&#x2F;api；要支持分组嵌套，那么需要知道当前分组的父亲(parent)是谁；<br>中间件是应用在分组上的，那还需要存储应用在该分组上的中间件(middlewares)。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r := gee.New()</span><br><span class="line">v1 := r.Group(<span class="string">&quot;/v1&quot;</span>)</span><br><span class="line">v1.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gee.Context)</span></span> &#123;</span><br><span class="line">c.HTML(http.StatusOK, <span class="string">&quot;&lt;h1&gt;Hello Gee&lt;/h1&gt;&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>好好看看仓库中的代码 梳理思路 感觉好有意思但是看不懂哈哈哈哈</p><p>11.26日 回看前三天的代码 增加一些自己的理解和修改 再继续向下学习！ </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;通过学习项目-7-days-golang搭建各种自己的框架了解一些网络工作原理和知识&quot;&gt;&lt;a href=&quot;#通过学习项目-7-days-golang搭建各种自己的框架了解一些网络工作原理和知识&quot; class=&quot;headerlink&quot; title=&quot;通过学习项目 7</summary>
      
    
    
    
    
  </entry>
  
</feed>
