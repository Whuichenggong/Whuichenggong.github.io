<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>赵忠赫的个人博客</title>
  
  
  <link href="https://whuichenggong.github.io/atom.xml" rel="self"/>
  
  <link href="https://whuichenggong.github.io/"/>
  <updated>2024-12-18T12:57:34.101Z</updated>
  <id>https://whuichenggong.github.io/</id>
  
  <author>
    <name>赵忠赫</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一位老哥的分享给了我一些启发</title>
    <link href="https://whuichenggong.github.io/2024/12/18/live3/"/>
    <id>https://whuichenggong.github.io/2024/12/18/live3/</id>
    <published>2024-12-18T12:43:19.542Z</published>
    <updated>2024-12-18T12:57:34.101Z</updated>
    
    <content type="html"><![CDATA[<p>学习方法：老哥的思维方式也给了我一些启发</p><p>以下是老哥的分享：</p><p>当知识点量大起来时, 我觉得”写作”的意义应该在于辅助思考</p><p>因为短时间内可能我们能记得很好, 但是对于长时间的庞大知识体系的学习, 就容易忘记一些分支内容 </p><p>所以第一步我做的是把长长的博客尽量拆解为小的讨论主题</p><p>作为”词条”存在</p><p>比如我写了个k8s主题的词条 写道”容器”这个词会自动链接到我之前写过的容器相关的内容  里面的内容是否符合当下我需要的定义  如果是, 那么可以知识复用  如果不是, 那么我需不需要创建新的词条来讨论这个主题<br>然后关联知识形成网络</p><p>比如一个使用mysql + reids搭建的系统, 即用到了mysql, 又用到了redis, 同时它本身还是个系统设计就会难以归类 </p><p>但是 一个文章可以同时带有mysql, redis, 系统设计三种tag  让知识形成网络！</p><p>先把书的标题提取出来 建立一个词条  然后去网上查, 这个东西包含哪些东西 然后去网上查, 这个东西包含哪些东西 等熟悉了基于零散信息的网络后  再去快速浏览权威书籍 迭代网络  </p><hr><p>听了老哥的分享！ 我觉得自己再生活中真的缺乏太多的思考了！什么事知道他困难，不想办法，应该去思考一些东西才能让东西变得更活！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习方法：老哥的思维方式也给了我一些启发&lt;/p&gt;
&lt;p&gt;以下是老哥的分享：&lt;/p&gt;
&lt;p&gt;当知识点量大起来时, 我觉得”写作”的意义应该在于辅助思考&lt;/p&gt;
&lt;p&gt;因为短时间内可能我们能记得很好, 但是对于长时间的庞大知识体系的学习, 就容易忘记一些分支内容 &lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>学习数据库</title>
    <link href="https://whuichenggong.github.io/2024/12/16/Database/"/>
    <id>https://whuichenggong.github.io/2024/12/16/Database/</id>
    <published>2024-12-16T01:12:34.566Z</published>
    <updated>2024-12-20T11:33:22.632Z</updated>
    
    <content type="html"><![CDATA[<hr><p>参考书籍： 数据库设计</p><hr><p>我先从事务入手：</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p><strong>概念</strong> ： 与单个用户或者程序执行，完成读取或者更新数据库内容的一个或一串操作</p><p>应用程序的一次执行就是一个事务或者多个事务</p><p>示例：</p><p>简单事务： 更新x员工的工资（涉及：数据库的读和写，和非数据库操作）</p><p>复杂事务：删除x的员工记录，并把x员工的事务交付给其他人去做。 （过程中若并非所有的操作都被执行，那么数据库的引用完整性将遭到破坏）（数据库也处于不一致状态）</p><p>尽管一致性暂时遭到破坏，但是数据库总是可以从一种一致状态转换到另一种一致的状态</p><h3 id="数据库最终的结果"><a href="#数据库最终的结果" class="headerlink" title="数据库最终的结果"></a>数据库最终的结果</h3><ol><li>COMMIT：执行成功，事务最终被提交 （数据库也达到了一种新的状态）</li><li>ABORTED：事务没有执行成功 （事务被撤销）则数据库必须要还原事务开始之前的一致状态</li><li>已经提交的事务不能被撤销，只能通过（补偿事务）进行覆盖 消除事务产生的影响</li><li>DBMS将在程序正确结束后自动执行COMMIT操作，若不能成功执行则 ROBACK</li><li>PARTIALLY COMITTED：若在最后一条语句被执行时产生了 破坏了可串行化或违反了完整约束 因此事务必须被撤销 或者系统出现故障，事务更新的事务没有被安全的写到二级存储设备上（部分提交） 以上两种情况最终都会进入</li><li>FAILED（失败状态） 事务无法被提交，或者事务处于ACTIVE状态就被撤销 则 处于FAILED状态</li></ol><h3 id="事务性质"><a href="#事务性质" class="headerlink" title="事务性质"></a>事务性质</h3><p>ACID</p><ol><li>原子性：</li><li>一致性：</li><li>隔离性：</li><li>持久性：</li></ol><p>事务的隔离级别<br>事务隔离级别控制了事务之间的可见性和并发行为。常见的隔离级别包括：</p><ul><li>读未提交（Read Uncommitted）：在这个隔离级别下，一个事务可以读取其他事务尚未提交的数据。这可能导致脏读（读取了未提交的数据）、不可重复读（同一查询在事务执行期间返回不同结果）和幻读（事务在同一查询中看到不同的数据行）等问题。读未提交的隔离级别最不严格，可能会引发数据不一致问题</li><li>读已提交（Read Committed）：在这个隔离级别下，一个事务只能读取已经提交的数据，避免了脏读问题。但是，不可重复读和幻读问题仍然可能出现。因为其他事务可能在事务进行期间提交新的数据，导致不同时间点的查询结果不一致。</li><li>可重复读（Repeatable Read）：可重复读隔离级别确保在同一事务内，同一个查询的结果保持一致。这意味着一个事务中的查询不会受到其他事务的修改影响。这可以防止脏读和不可重复读问题，但幻读问题仍然可能出现，因为其他事务可能插入新数据，导致新数据行的出现。</li><li>串行化（Serializable）：串行化是最严格的隔离级别，它确保每个事务都在独立的时间段内执行，防止了并发问题。事务按照顺序一个接一个地执行，这可以解决脏读、不可重复读和幻读问题。然而，串行化可能会对性能产生较大的影响，因为事务需要依次执行。</li></ul><p>事务的隔离级别可以解决脏读、幻读、不可重复读的问题。</p><ol><li>脏读： 脏读指的是在一个事务中读取了另一个事务未提交的数据。假设事务 A 修改了某一行数据，但还没有提交。同时，事务 B 尝试读取了事务 A 修改的数据。如果事务 A 最终回滚了，那么事务 B 读取的数据就是不存在的，这就是脏读。脏读会导致不准确的数据展示，因为<strong>读取的数据可能是临时的未经验证的。</strong>、</li><li>不可重复读：不可重复读是指在同一个事务内，多次读取同一数据时，得到不同的结果。这可能是因为在事务执行期间，其他事务修改了数据。例如，事务 A 在读取某一行数据后，事务 B 修改了这行数据，并提交了。现在事务 A 再次读取相同的数据，注重数据：<strong>发现数据已经不同了</strong>，造成了不一致的现象。</li><li>幻读： 幻读是指在同一个事务内，多次查询同一范围的数据时，得到不同的结果。这与不可重复读类似，但幻读关注的是数据的数量变化。例如，事务 A 在查询某个范围内的所有数据时，事务 B 插入了新数据，并提交了。现在事务 A 再次查询同一范围的数据，注重：<strong>发现数据行的数量增加了</strong>，这就是幻读。</li></ol><hr><p>22.2 并发控制 </p><p>讲解了数据库中的一些问题 幻读等</p><p>[点击这里查看PDF文件] (<a href="https://github.com/Whuichenggong/Knowledge-network/blob/main/docs/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BD%91%E7%BB%9C.pdf">https://github.com/Whuichenggong/Knowledge-network/blob/main/docs/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BD%91%E7%BB%9C.pdf</a>)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;参考书籍： 数据库设计&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我先从事务入手：&lt;/p&gt;
&lt;h2 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; title=&quot;事务&quot;&gt;&lt;/a&gt;事务&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;概念&lt;/strong&gt; ： 与单个</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于我学习的一些资源和方法</title>
    <link href="https://whuichenggong.github.io/2024/12/15/resource/"/>
    <id>https://whuichenggong.github.io/2024/12/15/resource/</id>
    <published>2024-12-15T07:45:03.995Z</published>
    <updated>2024-12-15T07:45:24.392Z</updated>
    
    <content type="html"><![CDATA[<p>兄弟，我理解你的心态，觉得实践的收获更直观，看书反而有点慢。但实际上，看书和实践结合，效果会倍增。下面我不仅推荐优质资源，还会分享高效阅读的方法，帮你更好地平衡学习时间。</p><hr><h3 id="学习资料推荐"><a href="#学习资料推荐" class="headerlink" title="学习资料推荐"></a><strong>学习资料推荐</strong></h3><h4 id="1-数据库相关"><a href="#1-数据库相关" class="headerlink" title="1. 数据库相关"></a><strong>1. 数据库相关</strong></h4><ul><li><strong>书籍</strong>：《高性能 MySQL》<ul><li>重点阅读：索引优化、事务机制、查询优化。</li><li><strong>免费在线教程</strong>：<ul><li><a href="https://www.w3schools.com/sql/">SQL 教程（w3schools）</a></li><li><a href="https://dev.mysql.com/doc/">MySQL 官方文档</a></li></ul></li></ul></li></ul><h4 id="2-计算机网络"><a href="#2-计算机网络" class="headerlink" title="2. 计算机网络"></a><strong>2. 计算机网络</strong></h4><ul><li><strong>书籍</strong>：《计算机网络：自顶向下方法》或《图解HTTP》<ul><li>重点章节：HTTP、TCP&#x2F;IP、DNS、HTTPS。</li><li><strong>免费资源</strong>：<ul><li><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1030595307488672">HTTP 协议详解</a></li><li><a href="https://www.wireshark.org/">Wireshark 网络分析教程</a></li></ul></li></ul></li></ul><h4 id="3-操作系统"><a href="#3-操作系统" class="headerlink" title="3. 操作系统"></a><strong>3. 操作系统</strong></h4><ul><li><strong>书籍</strong>：《现代操作系统》<ul><li>重点章节：进程、线程、同步、内存管理。</li><li><strong>免费资源</strong>：<ul><li><a href="https://pages.cs.wisc.edu/~remzi/OSTEP/">Operating Systems: Three Easy Pieces</a></li><li><a href="https://www.linuxfoundation.org/">Linux 操作系统入门</a></li></ul></li></ul></li></ul><h4 id="4-系统设计"><a href="#4-系统设计" class="headerlink" title="4. 系统设计"></a><strong>4. 系统设计</strong></h4><ul><li><strong>书籍</strong>：《系统设计入门》（Grokking the System Design Interview）<ul><li>重点学习：缓存、负载均衡、限流。</li><li><strong>博客</strong>：<ul><li><a href="https://www.educative.io/courses/grokking-the-system-design-interview">系统设计基础</a></li></ul></li></ul></li></ul><h4 id="5-Redis"><a href="#5-Redis" class="headerlink" title="5. Redis"></a><strong>5. Redis</strong></h4><ul><li><strong>书籍</strong>：《Redis 实战》<ul><li>重点章节：缓存机制、分布式锁。</li><li><strong>免费资源</strong>：<ul><li><a href="https://redis.io/docs/">Redis 官方文档</a></li></ul></li></ul></li></ul><h4 id="6-算法与数据结构"><a href="#6-算法与数据结构" class="headerlink" title="6. 算法与数据结构"></a><strong>6. 算法与数据结构</strong></h4><ul><li><strong>书籍</strong>：《算法（第4版）》或《编程珠玑》<ul><li>重点章节：常用数据结构（栈、队列、二叉树）、动态规划。</li><li><strong>网站</strong>：<ul><li><a href="https://leetcode.com/">LeetCode 官方</a></li><li><a href="https://visualgo.net/">VisuAlgo（算法可视化）</a></li></ul></li></ul></li></ul><hr><h3 id="高效看书方法"><a href="#高效看书方法" class="headerlink" title="高效看书方法"></a><strong>高效看书方法</strong></h3><h4 id="1-目的导向阅读"><a href="#1-目的导向阅读" class="headerlink" title="1. 目的导向阅读"></a><strong>1. 目的导向阅读</strong></h4><ul><li><strong>明确目标</strong>：每次看书前，明确你要解决的问题。比如：<ul><li>“我需要理解事务是怎么实现的” → 阅读事务相关章节，跳过其他部分。</li><li>“我需要掌握 TCP 的连接过程” → 只看 TCP 的工作原理。</li></ul></li></ul><h4 id="2-略读和精读结合"><a href="#2-略读和精读结合" class="headerlink" title="2. 略读和精读结合"></a><strong>2. 略读和精读结合</strong></h4><ul><li><strong>略读</strong>：先快速翻阅目录和每章的开头，总结书的主要内容。</li><li><strong>精读</strong>：挑选与项目或刷题直接相关的部分深入看，配合做笔记和练习。</li></ul><h4 id="3-配合实践"><a href="#3-配合实践" class="headerlink" title="3. 配合实践"></a><strong>3. 配合实践</strong></h4><ul><li><strong>边学边做</strong>：看完书中某个知识点，立即在项目或代码中实现。<ul><li>例子：学完 Redis 的分布式锁，马上在银行项目中添加。</li></ul></li><li><strong>用书作为工具</strong>：书可以成为你的“随手参考”，遇到不懂的概念再翻阅相关章节，而不必一次性啃完。</li></ul><h4 id="4-输出内容"><a href="#4-输出内容" class="headerlink" title="4. 输出内容"></a><strong>4. 输出内容</strong></h4><ul><li><strong>写笔记</strong>：总结书中学到的知识，用自己的语言重新描述。</li><li><strong>录制分享</strong>：试着用 3 分钟向别人讲解你刚学的内容，加深记忆。</li></ul><h4 id="5-番茄工作法"><a href="#5-番茄工作法" class="headerlink" title="5. 番茄工作法"></a><strong>5. 番茄工作法</strong></h4><ul><li>每次阅读 25 分钟后，花 5 分钟总结这段时间的收获，然后休息片刻。效率会提升很多。</li></ul><hr><h3 id="实践与看书的时间分配"><a href="#实践与看书的时间分配" class="headerlink" title="实践与看书的时间分配"></a><strong>实践与看书的时间分配</strong></h3><ol><li><strong>每天早上&#x2F;晚上固定 1 小时阅读</strong>。<ul><li>比如：早上看《高性能 MySQL》，晚上看《计算机网络》。</li></ul></li><li><strong>实践时遇到问题，马上查书解决</strong>。<ul><li>例子：如果 Redis 配置缓存遇到问题，就查《Redis 实战》。</li></ul></li><li><strong>每周末专门安排 2 小时总结书中知识点，结合项目整理成笔记</strong>。</li></ol><hr><p>这样安排既能保持实践的节奏，又能让你从书中挖掘深层的原理。如果还有具体内容不理解，可以随时问我，我也可以帮你分解章节内容！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;兄弟，我理解你的心态，觉得实践的收获更直观，看书反而有点慢。但实际上，看书和实践结合，效果会倍增。下面我不仅推荐优质资源，还会分享高效阅读的方法，帮你更好地平衡学习时间。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;学习资料推荐&quot;&gt;&lt;a href=&quot;#学习资料推荐&quot; class=&quot;h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>聊聊最近</title>
    <link href="https://whuichenggong.github.io/2024/12/12/current/"/>
    <id>https://whuichenggong.github.io/2024/12/12/current/</id>
    <published>2024-12-12T12:57:12.010Z</published>
    <updated>2024-12-13T07:20:24.060Z</updated>
    
    <content type="html"><![CDATA[<p>最近的日子在想着达到就业的水平，不断地提升额，嗯然后今天手机掉水里了，烘干24小时，看看能不能复活吧，突然觉得之前手机不是那么重要，回想起它占用<br>我的时间，好像都不是什么重要的事情，近期来，感觉是为了让自己舒服一点，白天学完，晚上回去就刷手机而且就是 12点 1点，恶性循环，本想着晚上回去看会<br>书，自己却暗示自己，学一天了，玩吧哈哈哈。好像都没做，但是确实没有那么重要，吃饭可以让同学帮我付，哈哈，还是得学习呢，反省一下，是不是你想要的太多了<br>而导致你很累，那种精神上的压迫自己，反思~</p><p>今天12.12日试着实现将单片机的数据传输到数据库中交互<br>先简单的使用按钮的高低电平0 1 实现交互试试看</p><p>后端服务代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/jackc/pgx/v4&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ButtonPress <span class="keyword">struct</span> &#123;</span><br><span class="line">DeviceID  <span class="type">string</span> <span class="string">`json:&quot;device_id&quot;`</span></span><br><span class="line">Button    <span class="type">int</span>    <span class="string">`json:&quot;button&quot;`</span></span><br><span class="line">Timestamp <span class="type">string</span> <span class="string">`json:&quot;timestamp&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">dbHost     = <span class="string">&quot;localhost&quot;</span></span><br><span class="line">dbPort     = <span class="number">5432</span></span><br><span class="line">dbUser     = <span class="string">&quot;root&quot;</span></span><br><span class="line">dbPassword = <span class="string">&quot;secret&quot;</span></span><br><span class="line">dbName     = <span class="string">&quot;data&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Set up the database connection</span></span><br><span class="line">connStr := fmt.Sprintf(<span class="string">&quot;postgresql://%s:%s@%s:%d/%s&quot;</span>, dbUser, dbPassword, dbHost, dbPort, dbName)</span><br><span class="line">conn, err := pgx.Connect(context.Background(), connStr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;Unable to connect to the database: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close(context.Background())</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set up the HTTP server</span></span><br><span class="line">http.HandleFunc(<span class="string">&quot;/receive&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r.Method != http.MethodPost &#123;</span><br><span class="line">http.Error(w, <span class="string">&quot;Only POST requests are supported&quot;</span>, http.StatusMethodNotAllowed)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data ButtonPress</span><br><span class="line"><span class="keyword">if</span> err := json.NewDecoder(r.Body).Decode(&amp;data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">http.Error(w, <span class="string">&quot;Invalid JSON format&quot;</span>, http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">&quot;Received data: %+v&quot;</span>, data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> data.Button == <span class="number">1</span> &#123;</span><br><span class="line"><span class="comment">// Store the data in the database</span></span><br><span class="line">query := <span class="string">&quot;INSERT INTO button_presses (device_id, button, timestamp) VALUES ($1, $2, $3)&quot;</span></span><br><span class="line">_, err := conn.Exec(context.Background(), query, data.DeviceID, data.Button, data.Timestamp)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">http.Error(w, <span class="string">&quot;Failed to store data in the database&quot;</span>, http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">log.Println(<span class="string">&quot;Data successfully stored in the database&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">w.WriteHeader(http.StatusOK)</span><br><span class="line">w.Write([]<span class="type">byte</span>(<span class="string">&quot;Data received and processed&quot;</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">log.Println(<span class="string">&quot;Starting server on 192.168.111.1:8080&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err := http.ListenAndServe(<span class="string">&quot;192.168.111.1:8080&quot;</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;Server failed: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是简单的实现</p><p>单片机端代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266HTTPClient.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* ssid = <span class="string">&quot;Your_SSID&quot;</span>;          <span class="comment">// Wi-Fi 名称</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* password = <span class="string">&quot;Your_PASSWORD&quot;</span>;  <span class="comment">// Wi-Fi 密码</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* serverUrl = <span class="string">&quot;http://8.222.186.212:8080/send&quot;</span>;  <span class="comment">// 后端服务器地址</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">115200</span>); <span class="comment">// 初始化串口</span></span><br><span class="line">  WiFi.begin(ssid, password);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 连接到 Wi-Fi</span></span><br><span class="line">  Serial.print(<span class="string">&quot;Connecting to Wi-Fi&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> (WiFi.status() != WL_CONNECTED) &#123;</span><br><span class="line">    delay(<span class="number">1000</span>);</span><br><span class="line">    Serial.print(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Serial.println(<span class="string">&quot;\nConnected to Wi-Fi&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (WiFi.status() == WL_CONNECTED) &#123;</span><br><span class="line">    HTTPClient http;</span><br><span class="line">    http.begin(serverUrl);   <span class="comment">// 设置服务器 URL</span></span><br><span class="line">    http.addHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>); <span class="comment">// 设置请求头</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例 JSON 数据</span></span><br><span class="line">    String jsonData = <span class="string">&quot;&#123;\&quot;sensor\&quot;: \&quot;temperature\&quot;, \&quot;value\&quot;: 25.5&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// POST 请求</span></span><br><span class="line">    <span class="type">int</span> httpResponseCode = http.POST(jsonData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查响应状态</span></span><br><span class="line">    <span class="keyword">if</span> (httpResponseCode &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      String response = http.getString();</span><br><span class="line">      Serial.println(<span class="string">&quot;Response: &quot;</span> + response);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Serial.println(<span class="string">&quot;Error on sending POST: &quot;</span> + String(httpResponseCode));</span><br><span class="line">    &#125;</span><br><span class="line">    http.end(); <span class="comment">// 关闭连接</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.println(<span class="string">&quot;Wi-Fi not connected&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  delay(<span class="number">5000</span>); <span class="comment">// 每 5 秒发送一次数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>HTTP就是那么的神奇</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近的日子在想着达到就业的水平，不断地提升额，嗯然后今天手机掉水里了，烘干24小时，看看能不能复活吧，突然觉得之前手机不是那么重要，回想起它占用&lt;br&gt;我的时间，好像都不是什么重要的事情，近期来，感觉是为了让自己舒服一点，白天学完，晚上回去就刷手机而且就是 12点 1点，恶</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>分布式系统学习</title>
    <link href="https://whuichenggong.github.io/2024/12/09/Distributed/"/>
    <id>https://whuichenggong.github.io/2024/12/09/Distributed/</id>
    <published>2024-12-09T12:53:55.062Z</published>
    <updated>2024-12-09T13:14:34.908Z</updated>
    
    <content type="html"><![CDATA[<p><code>go build -buildmode=plugin ../mrapps/wc.go</code><br>这个指令是什么意思 :</p><p>这个命令的作用是编译 ..&#x2F;mrapps&#x2F;wc.go 文件，并将其生成一个 Go 插件文件。生成的插件文件通常是一个 .so（共享库文件）文件，它可以在运行时被其他 Go 程序通过 plugin 包加载和调用。</p><p>例如：</p><p>你可以在主程序中使用 plugin 包动态加载 wc.so 插件，并调用插件中的函数。</p><p><code>go run mrsequential.go wc.so pg*.txt：</code></p><p>go run：用于编译并运行 Go 程序。它会在内存中临时编译指定的 Go 文件，并立即执行。</p><p>mrsequential.go：这是要执行的 Go 源文件，Go 编译器会先编译这个文件并运行它。这个文件应该包含 main 函数，通常是程序的入口点。</p><p>wc.so：这是一个 Go 插件文件（共享库）。它通常是通过 go build -buildmode&#x3D;plugin 命令生成的。该文件包含 Go 代码，可能定义了一个插件接口，在运行时可以被主程序（mrsequential.go）动态加载和调用。wc.so 可能提供某些功能，mrsequential.go 将加载并使用这些功能。</p><p>pg*.txt：这是一个通配符表达式，表示所有以 pg 开头，后面跟任意字符，且以 .txt 结尾的文件。例如，pg1.txt, pg42.txt, pgfile.txt 都会被匹配并作为参数传递给程序。</p><p><code>more mr-out-0</code> 将会输出很多文本 这是因为：</p><p>mrsequential.go 将其输出保留在文件 mr-out-0 中。输入来自名为 pg-xxx.txt 的文本文件</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;go build -buildmode=plugin ../mrapps/wc.go&lt;/code&gt;&lt;br&gt;这个指令是什么意思 :&lt;/p&gt;
&lt;p&gt;这个命令的作用是编译 ..&amp;#x2F;mrapps&amp;#x2F;wc.go 文件，并将其生成一个 Go 插件文件。生成的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数据库学习</title>
    <link href="https://whuichenggong.github.io/2024/12/08/postgres/"/>
    <id>https://whuichenggong.github.io/2024/12/08/postgres/</id>
    <published>2024-12-08T10:47:54.793Z</published>
    <updated>2024-12-08T10:52:44.696Z</updated>
    
    <content type="html"><![CDATA[<p>学习文档：</p><p><a href="https://www.rockdata.net/zh-cn/tutorial/toc/">https://www.rockdata.net/zh-cn/tutorial/toc/</a></p><p>WHERE 语句如何使用</p><p><a href="https://www.rockdata.net/zh-cn/tutorial/dml-where/%E3%80%81">https://www.rockdata.net/zh-cn/tutorial/dml-where/、</a></p><p>总结来说： 放入condition，返回结果只会返回符合condition条件的， 搭配 AND OR IN LIKE等使用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.rockdata.net/zh-cn/tutorial/toc/&quot;&gt;https://www.rockdata.net/zh-cn/tutorial/toc/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;WHERE 语句如何使用&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>为什么别人写项目知道用什么？</title>
    <link href="https://whuichenggong.github.io/2024/12/07/confusion/"/>
    <id>https://whuichenggong.github.io/2024/12/07/confusion/</id>
    <published>2024-12-07T09:19:23.441Z</published>
    <updated>2024-12-07T09:20:17.605Z</updated>
    
    <content type="html"><![CDATA[<p>同样来自GPT的回答：</p><p>你的疑惑非常好！许多人在学习编程时都会有类似的感受，尤其是在学习阶段，看到博主轻松选择某些包或者工具来解决问题时，会觉得他们似乎“无所不知”。事实上，这背后是<strong>经验</strong>和<strong>积累</strong>的结果。以下几点可以帮助你理解和逐步建立这种能力：</p><hr><h3 id="1-经验的积累"><a href="#1-经验的积累" class="headerlink" title="1. 经验的积累"></a><strong>1. 经验的积累</strong></h3><ul><li><strong>博主的背景</strong>：他们可能已经解决过类似问题，因此知道哪些包是高效的选择。这是经验的体现。</li><li><strong>类比</strong>：就像一位厨师在做菜时，很容易知道用什么调料，而新手可能需要查配方。</li></ul><h4 id="你可以这样做："><a href="#你可以这样做：" class="headerlink" title="你可以这样做："></a><strong>你可以这样做：</strong></h4><ul><li><strong>多看、多学</strong>：通过模仿优秀项目和学习文档，积累对常用库和框架的了解。</li><li><strong>练习总结</strong>：每次解决问题后，记录用到的包和方法，慢慢形成自己的“工具箱”。</li></ul><hr><h3 id="2-文档与生态"><a href="#2-文档与生态" class="headerlink" title="2. 文档与生态"></a><strong>2. 文档与生态</strong></h3><ul><li><p><strong>语言和框架的生态</strong>：每种语言或框架都有一些社区公认的、<strong>常用的库</strong>。</p><ul><li>比如，Go 语言处理配置时，大家常用 <code>viper</code> 或 <code>yaml</code>。</li><li>HTTP 请求：<code>net/http</code>（原生）或社区的 <code>gin</code>（框架）。</li></ul></li><li><p><strong>社区推荐</strong>：很多库被推荐使用，是因为它们：</p><ol><li><strong>功能齐全</strong>。</li><li><strong>易于使用</strong>。</li><li><strong>社区活跃</strong>，有长期维护。</li></ol></li></ul><h4 id="你可以这样做：-1"><a href="#你可以这样做：-1" class="headerlink" title="你可以这样做："></a><strong>你可以这样做：</strong></h4><ul><li><strong>了解生态</strong>：多逛 GitHub、Go 的标准库文档以及社区资源（比如 Go 的官方博客）。</li><li><strong>参考优秀代码</strong>：通过学习开源项目，你可以快速了解哪些包解决了哪些问题。</li></ul><hr><h3 id="3-搜索能力"><a href="#3-搜索能力" class="headerlink" title="3. 搜索能力"></a><strong>3. 搜索能力</strong></h3><ul><li><p>很多开发者的知识并不是“记住的”，而是“查到的”。他们遇到问题时，会：</p><ol><li><strong>搜索问题</strong>：查找类似场景的解决方案。</li><li><strong>评估方案</strong>：根据实际需求选择合适的库或框架。</li></ol></li><li><p>搜索时的技巧：</p><ul><li>用精准关键词，比如“Go JWT authentication package”。</li><li>看社区推荐，比如 Stack Overflow、Reddit、GitHub 等。</li></ul></li></ul><h4 id="你可以这样做：-2"><a href="#你可以这样做：-2" class="headerlink" title="你可以这样做："></a><strong>你可以这样做：</strong></h4><ul><li>当不知道用哪个包时，搜索类似场景的关键词，看看其他开发者用了什么库。</li><li>慢慢熟悉常用的社区推荐来源，比如：<ul><li><a href="https://awesome-go.com/">Awesome Go</a>：列出了 Go 的优秀库。</li><li><a href="https://pkg.go.dev/">Go Packages</a>：Go 的官方包文档和搜索平台。</li></ul></li></ul><hr><h3 id="4-理解需求，选择工具"><a href="#4-理解需求，选择工具" class="headerlink" title="4. 理解需求，选择工具"></a><strong>4. 理解需求，选择工具</strong></h3><ul><li>博主并不是“盲选”包，而是基于需求选工具。<ul><li>例如：需要读取配置文件，就会选择支持多种格式的 <code>viper</code>。</li><li>需要快速搭建 Web 服务框架，就会用 <code>gin</code> 或 <code>echo</code>。</li></ul></li></ul><h4 id="你可以这样做：-3"><a href="#你可以这样做：-3" class="headerlink" title="你可以这样做："></a><strong>你可以这样做：</strong></h4><ul><li>学会分析问题：问自己——“这个问题需要解决什么？”“有没有原生支持？”</li><li>学会看库文档：<ul><li>比如，在 GitHub 项目中，看 ReadMe 和示例代码，理解库的功能。</li></ul></li></ul><hr><h3 id="5-你的问题如何转换为实践"><a href="#5-你的问题如何转换为实践" class="headerlink" title="5. 你的问题如何转换为实践"></a><strong>5. 你的问题如何转换为实践</strong></h3><ol><li><strong>明确目标</strong>：先理解你要解决的问题，比如“实现一个 JWT 登录功能”。</li><li><strong>学习思路</strong>：看看博主怎么解决的，模仿过程并分析他们选择的工具是否合理。</li><li><strong>尝试自己实现</strong>：不要依赖博主的方案，尝试用其他库或者原生代码实现。</li></ol><hr><h3 id="总结：知识的形成是一个积累过程"><a href="#总结：知识的形成是一个积累过程" class="headerlink" title="总结：知识的形成是一个积累过程"></a><strong>总结：知识的形成是一个积累过程</strong></h3><p>博主看似“知道一切”，实际上是基于：</p><ol><li><strong>经验积累</strong>：长期的项目经验让他们知道常用包。</li><li><strong>良好工具链</strong>：对语言生态了解，知道优秀的社区推荐。</li><li><strong>高效搜索</strong>：遇到新问题时，他们可以快速找到解决方案。</li></ol><p><strong>行动建议</strong>：</p><ul><li>多积累项目经验，模仿优秀代码，逐渐形成自己的“工具箱”。</li><li>学会分解问题和尝试不同工具，在实践中找到更适合的解决方案。<br>坚持下去，你也会越来越“有经验”！ 😊</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;同样来自GPT的回答：&lt;/p&gt;
&lt;p&gt;你的疑惑非常好！许多人在学习编程时都会有类似的感受，尤其是在学习阶段，看到博主轻松选择某些包或者工具来解决问题时，会觉得他们似乎“无所不知”。事实上，这背后是&lt;strong&gt;经验&lt;/strong&gt;和&lt;strong&gt;积累&lt;/strong&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>理解鉴权，权限等名词的区别</title>
    <link href="https://whuichenggong.github.io/2024/12/07/authority/"/>
    <id>https://whuichenggong.github.io/2024/12/07/authority/</id>
    <published>2024-12-07T09:13:14.230Z</published>
    <updated>2024-12-07T09:15:05.767Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GPT很好的给出了答案"><a href="#GPT很好的给出了答案" class="headerlink" title="GPT很好的给出了答案"></a>GPT很好的给出了答案</h2><p>问：</p><p>用户通过了身份验证，但是不具有访问资源所需的权限。 这句话我应该怎么理解，我还有的疑惑是Cookie，Token，鉴权，权限等这几个名词都是什么意思，我现在对他们的理解有点模糊</p><p>答：</p><p>这些概念是 Web 安全和权限管理的核心部分。让我们分两步：<strong>先理解句子的含义</strong>，再深入解析相关概念（Cookie、Token、鉴权、权限等）。</p><hr><h3 id="1-句子的含义"><a href="#1-句子的含义" class="headerlink" title="1. 句子的含义"></a><strong>1. 句子的含义</strong></h3><blockquote><p><strong>“用户通过了身份验证，但是不具有访问资源所需的权限。”</strong></p></blockquote><p>这句话分为两个阶段：</p><ol><li><p><strong>身份验证</strong>（Authentication）：系统确认了用户的身份（比如你用正确的用户名和密码登录）。</p><ul><li><strong>说明</strong>：你确实是你声称的那个人。</li><li><strong>类比</strong>：这就像进入公司时，你刷卡证明你是公司的员工。</li></ul></li><li><p><strong>权限检查</strong>（Authorization）：系统检查用户是否有权访问某些特定资源。</p><ul><li><strong>说明</strong>：通过身份验证并不代表你可以访问所有东西。例如：<ul><li>普通用户可能无法访问管理员界面。</li><li>销售部门员工可能无法查看财务报表。</li></ul></li><li><strong>类比</strong>：在公司内部，即使你刷卡进门，也可能需要额外权限才能进入某些区域（比如机房）。</li></ul></li></ol><p><strong>总结</strong>：身份验证是“你是谁”，权限检查是“你是否被允许做某件事”。通过身份验证 ≠ 获得所有权限。</p><hr><h3 id="2-概念解析"><a href="#2-概念解析" class="headerlink" title="2. 概念解析"></a><strong>2. 概念解析</strong></h3><h4 id="1-Cookie"><a href="#1-Cookie" class="headerlink" title="(1) Cookie"></a><strong>(1) Cookie</strong></h4><ul><li><strong>定义</strong>：一种小型数据，存储在用户浏览器中，由服务器生成，用来记录用户的会话状态或其他信息。</li><li><strong>用途</strong>：<ol><li><strong>会话管理</strong>：比如记录你是否已登录。</li><li><strong>个性化</strong>：比如保存语言设置。</li><li><strong>追踪</strong>：用于广告和分析。</li></ol></li></ul><p><strong>类比</strong>：Cookie 就像一个身份证明牌，浏览器每次请求时带上它，服务器根据这个证明牌识别你的身份。</p><hr><h4 id="2-Token"><a href="#2-Token" class="headerlink" title="(2) Token"></a><strong>(2) Token</strong></h4><ul><li><strong>定义</strong>：类似于数字化的通行证，通常由服务器生成并发放给用户，用户每次请求时带上 Token，证明自己已通过身份验证。</li><li><strong>常见类型</strong>：<ul><li>**JWT (JSON Web Token)**：一种格式化的 Token，常用于现代 Web 应用。</li></ul></li></ul><p><strong>区别于 Cookie</strong>：</p><ul><li>Cookie 是浏览器特有的存储机制，而 Token 是一个通用的凭证。</li><li>Cookie 通常自动附加在请求中，Token 需要开发者手动附加（如放在请求头中）。</li></ul><p><strong>类比</strong>：Token 就像一个“通行证”，你需要用它向服务器证明你有访问权限。</p><hr><h4 id="3-鉴权"><a href="#3-鉴权" class="headerlink" title="(3) 鉴权"></a><strong>(3) 鉴权</strong></h4><ul><li><strong>定义</strong>：确定用户是否具有访问资源或执行操作的权限。</li><li><strong>过程</strong>：<ul><li>用户发起请求时，系统会验证用户提供的凭证（比如 Token 或 Cookie）。</li><li>系统根据用户的角色、组或策略，判断是否允许操作。</li></ul></li></ul><p><strong>类比</strong>：鉴权就像安保检查，你拿着门卡，安保会检查你的权限，决定你是否可以进入某些区域。</p><hr><h4 id="4-权限"><a href="#4-权限" class="headerlink" title="(4) 权限"></a><strong>(4) 权限</strong></h4><ul><li><strong>定义</strong>：指用户被允许执行的操作范围或访问的资源类型。</li><li><strong>示例</strong>：<ul><li>读权限：允许查看文件内容。</li><li>写权限：允许修改文件内容。</li><li>管理权限：允许管理其他用户。</li></ul></li></ul><p><strong>类比</strong>：权限就像不同的钥匙，钥匙决定了你能打开哪些门。</p><hr><h3 id="3-总结关系和区别"><a href="#3-总结关系和区别" class="headerlink" title="3. 总结关系和区别"></a><strong>3. 总结关系和区别</strong></h3><ul><li><strong>Cookie</strong>：存储用户会话信息，让服务器识别用户是谁。</li><li><strong>Token</strong>：携带用户身份信息，用于证明用户已通过身份验证。</li><li><strong>鉴权</strong>：判断用户是否有权访问特定资源。</li><li><strong>权限</strong>：用户可以做的事情或访问的资源范围。</li></ul><hr><h3 id="4-一个完整的例子"><a href="#4-一个完整的例子" class="headerlink" title="4. 一个完整的例子"></a><strong>4. 一个完整的例子</strong></h3><ol><li><p>用户访问网站，输入用户名和密码（<strong>身份验证</strong>）。</p><ul><li>服务器验证用户名和密码正确，生成一个 Token 返回给用户。</li><li>Token 或者对应的 Session ID 会存储在用户的 Cookie 中。</li></ul></li><li><p>用户请求资源时，浏览器自动带上 Cookie（或你自己带上 Token）。</p><ul><li>服务器接收到请求后，验证 Token 或 Cookie 的合法性。</li></ul></li><li><p>服务器检查权限（<strong>鉴权</strong>）。</p><ul><li>如果你有权限，资源返回给你。</li><li>如果你没有权限，服务器返回 “403 Forbidden”。</li></ul></li></ol><p>你可以将这些过程看成一道流水线：<strong>身份验证 -&gt; 带凭证发请求 -&gt; 权限检查 -&gt; 返回结果</strong>。</p><p>就是我是 赵忠鹤 检查 赵忠鹤是不是有权限访问这个内容，大体就是这个意思</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;GPT很好的给出了答案&quot;&gt;&lt;a href=&quot;#GPT很好的给出了答案&quot; class=&quot;headerlink&quot; title=&quot;GPT很好的给出了答案&quot;&gt;&lt;/a&gt;GPT很好的给出了答案&lt;/h2&gt;&lt;p&gt;问：&lt;/p&gt;
&lt;p&gt;用户通过了身份验证，但是不具有访问资源所需的权限</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>json的序列化与反序列化</title>
    <link href="https://whuichenggong.github.io/2024/12/06/serialize/"/>
    <id>https://whuichenggong.github.io/2024/12/06/serialize/</id>
    <published>2024-12-06T09:21:57.665Z</published>
    <updated>2024-12-06T09:52:48.370Z</updated>
    
    <content type="html"><![CDATA[<p>序列化：将 Go 中的结构体、切片、map 等数据结构转换为 JSON 格式的字符串。</p><p>作用：方便数据在网络传输、文件保存等情境中使用。</p><p>反序列化：将 JSON 格式的字符串转换为 Go 的数据结构。</p><p>作用：方便从 JSON 中提取数据并在程序中使用。</p><p>JSON<br>{<br>“”： “”，<br>“”： “”，<br>“”： “”<br>}</p><p>Go中 使用 Marshal Unmarshal 进行序列化和反序列化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">    Age  <span class="type">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := Person&#123;Name: <span class="string">&quot;Alice&quot;</span>, Age: <span class="number">25</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化为 JSON</span></span><br><span class="line">    jsonData, err := json.Marshal(p)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Error:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="type">string</span>(jsonData)) <span class="comment">// 输出: &#123;&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:25&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">    Age  <span class="type">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    jsonData := <span class="string">`&#123;&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:25&#125;`</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> p Person</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化为结构体</span></span><br><span class="line">    err := json.Unmarshal([]<span class="type">byte</span>(jsonData), &amp;p)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Error:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(p.Name, p.Age) <span class="comment">// 输出: Alice 25</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>类比一下进程间管道通信：<br>在父子进程使用管道进行通信时，数据通常以字节流的形式传输。<br>要传递复杂数据结构，需要将数据转换为字节流（序列化），并在另一端解析回来（反序列化）。</p><p>GO中实现 字符进程通信</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">    Content <span class="type">string</span> <span class="string">`json:&quot;content&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r, w, err := os.Pipe() <span class="comment">// 创建管道</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Error creating pipe:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> os.Getenv(<span class="string">&quot;IS_CHILD&quot;</span>) == <span class="string">&quot;1&quot;</span> &#123;</span><br><span class="line">        <span class="comment">// 子进程逻辑</span></span><br><span class="line">        r.Close() <span class="comment">// 关闭写端</span></span><br><span class="line">        <span class="keyword">var</span> msg Message</span><br><span class="line">        decoder := json.NewDecoder(r)</span><br><span class="line">        <span class="keyword">if</span> err := decoder.Decode(&amp;msg); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;Error decoding:&quot;</span>, err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Child received:&quot;</span>, msg.Content)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程逻辑</span></span><br><span class="line">        w.Close() <span class="comment">// 关闭读端</span></span><br><span class="line">        cmd := os.Exec(os.Args[<span class="number">0</span>], os.Args, os.Environ())</span><br><span class="line">        cmd.Env = <span class="built_in">append</span>(os.Environ(), <span class="string">&quot;IS_CHILD=1&quot;</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            encoder := json.NewEncoder(w)</span><br><span class="line">            encoder.Encode(Message&#123;Content: <span class="string">&quot;Hello, Child!&quot;</span>&#125;)</span><br><span class="line">        &#125;()</span><br><span class="line">        cmd.Wait()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;序列化：将 Go 中的结构体、切片、map 等数据结构转换为 JSON 格式的字符串。&lt;/p&gt;
&lt;p&gt;作用：方便数据在网络传输、文件保存等情境中使用。&lt;/p&gt;
&lt;p&gt;反序列化：将 JSON 格式的字符串转换为 Go 的数据结构。&lt;/p&gt;
&lt;p&gt;作用：方便从 JSON 中提取</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Go语法学习</title>
    <link href="https://whuichenggong.github.io/2024/12/02/Go_Program/"/>
    <id>https://whuichenggong.github.io/2024/12/02/Go_Program/</id>
    <published>2024-12-02T06:10:19.416Z</published>
    <updated>2024-12-16T02:39:31.613Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">whatAmI := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> t := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;I&#x27;m a bool&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;I&#x27;m an int&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Don&#x27;t know type %T\n&quot;</span>, t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">whatAmI(<span class="literal">true</span>)</span><br><span class="line">whatAmI(<span class="number">1</span>)</span><br><span class="line">whatAmI(<span class="string">&quot;hey&quot;</span>)</span><br></pre></td></tr></table></figure><p>这是一个函数whatAmI，它接受一个interface{}类型的参数。interface{}是 Go 语言中的一种空接口，可以存储任何类型的值。<br>这个switch语句实际上是一个类型switch，它检查接口变量i的具体类型，而不是它的值。根据i的类型，switch将执行不同的case分支。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If you specify the index with `:`, the elements in</span></span><br><span class="line"><span class="comment">// between will be zeroed.</span></span><br><span class="line">b = [...]<span class="type">int</span>&#123;<span class="number">100</span>, <span class="number">3</span>: <span class="number">400</span>, <span class="number">500</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;idx:&quot;</span>, b)</span><br></pre></td></tr></table></figure><p>3: 400 指定了下标为 3 的位置的值是 400。<br>这意味着索引 1 和 2 的值将被初始化为 0（因为:操作符指定了一个新的下标，并初始化之前未指定的下标对应的元素为 0）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="type">string</span></span><br><span class="line">fmt.Println(<span class="string">&quot;uninit:&quot;</span>, s, s == <span class="literal">nil</span>, <span class="built_in">len</span>(s) == <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>uninit: [] true true</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">twoD := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">innerLen := i + <span class="number">1</span></span><br><span class="line">twoD[i] = <span class="built_in">make</span>([]<span class="type">int</span>, innerLen)</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; innerLen; j++ &#123;</span><br><span class="line">twoD[i][j] = i + j</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;2d: &quot;</span>, twoD)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2d:  [[0] [1 2] [2 3 4]]</p><p>12.3日</p><p>map操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   m[<span class="string">&quot;k1&quot;</span>] = <span class="number">7</span></span><br><span class="line">m[<span class="string">&quot;k2&quot;</span>] = <span class="number">13</span></span><br><span class="line">fmt.Println(<span class="string">&quot;map:&quot;</span>, m)</span><br><span class="line">fmt.Println(<span class="string">&quot;len:&quot;</span>, <span class="built_in">len</span>(m))</span><br><span class="line"><span class="comment">//clear(m)</span></span><br><span class="line">val, prs := m[<span class="string">&quot;k2&quot;</span>] <span class="comment">//k2的值， 一个是判断k2是否存在于m中的bool值</span></span><br><span class="line">fmt.Println(<span class="string">&quot;val：&quot;</span>, val, <span class="string">&quot;prs:&quot;</span>, prs)</span><br><span class="line">n := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;foo&quot;</span>: <span class="number">1</span>, <span class="string">&quot;bar&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;&quot;</span>, n)</span><br><span class="line"><span class="keyword">if</span> maps.Equal(n, n2) &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;n == n2&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用变长参数函数（variadic function），即可以接收任意数量参数的函数。<br>这里的 … 标记表示 nums 参数是可变长的，可以接收零个或多个 int 类型的参数</p><p>nums 被当作切片使用，可以进行切片相关的操作，例如使用 len(nums) 获取长度，或者用 range 遍历切片元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(nums ...<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Print(nums, <span class="string">&quot; &quot;</span>)</span><br><span class="line">total := <span class="number">0</span></span><br><span class="line"><span class="comment">// Within the function, the type of `nums` is</span></span><br><span class="line"><span class="comment">// equivalent to `[]int`. We can call `len(nums)`,</span></span><br><span class="line"><span class="comment">// iterate over it with `range`, etc.</span></span><br><span class="line"><span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">total += num</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(total)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Variadic functions can be called in the usual way</span></span><br><span class="line"><span class="comment">// with individual arguments.</span></span><br><span class="line">sum(<span class="number">1</span>)</span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// If you already have multiple args in a slice,</span></span><br><span class="line"><span class="comment">// apply them to a variadic function using</span></span><br><span class="line"><span class="comment">// `func(slice...)` like this.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种调用nums的方法使用 nums 切片，通过 sum(nums...) 的方式将切片中的每个元素作为单独的参数传递给 sum 函数。</span></span><br><span class="line">nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">sum(nums...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误示范</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allArticles</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">articles := Articles&#123;</span><br><span class="line">Title:   <span class="string">&quot;Test Title&quot;</span>,</span><br><span class="line">Desc:    <span class="string">&quot;Test Descrption&quot;</span>,</span><br><span class="line">Content: <span class="string">&quot;hello world&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;endpoint hit: allArticles&quot;</span>)</span><br><span class="line">json.NewEncoder(w).Encode(articles)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里的问题是 Articles 类型实际上是一个切片（[]Article），而你试图将一个单独的 Article 结构体实例赋值给 articles 变量。根据 Go 语言的语法，Articles 类型需要的是一个 Article 类型的切片。</p><p>要解决这个问题，你需要将 Article 实例放入一个切片中。可以将你的代码修改为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">articles := Articles&#123;</span><br><span class="line">&#123;</span><br><span class="line">Title:   <span class="string">&quot;Test Title&quot;</span>,</span><br><span class="line">Desc:    <span class="string">&quot;Test Descrption&quot;</span>,</span><br><span class="line">Content: <span class="string">&quot;hello world&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">CopyInsert</span><br><span class="line">这里的修改是把 Article 结构体实例用 &#123;&#125; 包围起来，表示这是一个切片中的一个元素。</span><br><span class="line"></span><br><span class="line">最终的 allArticles 函数应如下所示：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二种方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Article的实例</span></span><br><span class="line">    newArticle := Article&#123;</span><br><span class="line">        Title:   <span class="string">&quot;Test Title&quot;</span>,</span><br><span class="line">        Desc:    <span class="string">&quot;Test Description&quot;</span>,</span><br><span class="line">        Content: <span class="string">&quot;hello world&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建Articles切片并添加上面的实例</span></span><br><span class="line">    articles := Articles&#123;newArticle&#125;</span><br></pre></td></tr></table></figure><hr><p>go fmt </p><p>包的导入者将使用名称来引用其内容，因此包中的导出名称可以使用该事实来避免重复。 （不要使用 import . 表示法，它可以简化必须在正在测试的包外部运行的测试，但应该避免。）<br>例如，bufio 包中的缓冲读取器类型称为 Reader，而不是 BufReader，因为用户将其视为 bufio.Reader，这是一个清晰、简洁的名称。此外，由于导入的实体始终使用其包名称进行寻址，<br>因此 bufio.Reader 不会与 io.Reader 冲突。类似地，<br>创建ring.Ring新实例的函数（Go中构造函数的定义）通常被称为NewRing，但由于Ring是包导出的唯一类型，并且由于包被称为ring，所以它是称为“New”，包的客户端将其视为“ring.New”。使用包结构来帮助您选择好的名称。</p><p>另一个简短的例子是once.Do; Once.Do(setup) 读起来很好，<br>并且不会通过编写 Once.DoOrWaitUntilDone(setup) 来改进。长名称不会自动使内容更具可读性。有用的文档注释通常比超长的名称更有价值。</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intSeq</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    i := <span class="number">0</span> <span class="comment">// i 是一个局部变量，用于 intSeq 函数。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="comment">// 返回一个匿名函数，这个函数可以访问 intSeq 函数的局部变量 i。</span></span><br><span class="line">        i++    <span class="comment">// 每次调用这个匿名函数时，i 的值都会增加。</span></span><br><span class="line">        <span class="keyword">return</span> i <span class="comment">// 返回增加后的 i 的值。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回结果 ：<br>1<br>2<br>3<br>1</p><p>这是因为闭包允许匿名函数捕获并记住 i 变量的状态。<br>这就是闭包的 “魔力” 所在，即使外部函数已经返回，内部函数仍然能够访问和修改外部函数的变量。</p><p>stack :&#x3D; []rune{} 与 make :&#x3D; []string{} 的区别：<br>stack :&#x3D; []rune{}：这段代码创建了一个 rune 类型的切片（空切片）。rune 是 Go 中专门用来表示单个字符的类型，适用于你处理字符（尤其是 Unicode 字符）时，能够确保每个元素是一个完整的 Unicode 字符。</p><p>make :&#x3D; []string{}：这段代码创建了一个 string 类型的切片。每个元素是一个字符串，字符串通常用于表示一系列字符构成的文本数据。</p><hr><p>在 Go 程序中，通过 <code>os.Args</code> 可以访问命令行参数，而 <code>go run main.go file1.txt file2.txt</code> 的执行过程如下：</p><hr><p>为什么·go语言 &gt; go run main.go file1.txt file2.txt 在这里执行之后可以读取到文件1 2</p><h3 id="1-命令行参数的解析"><a href="#1-命令行参数的解析" class="headerlink" title="1. 命令行参数的解析"></a><strong>1. 命令行参数的解析</strong></h3><ul><li><p><strong>命令：</strong> <code>go run main.go file1.txt file2.txt</code></p><ul><li><code>go run</code> 会编译并执行 <code>main.go</code>。</li><li>命令行中，<code>main.go</code> 后面的 <code>file1.txt</code> 和 <code>file2.txt</code> 被传递给程序作为命令行参数。</li></ul></li><li><p>在程序中，<code>os.Args</code> 是一个字符串切片（<code>[]string</code>），包含了命令行中的参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">os.Args[<span class="number">0</span>] <span class="comment">// 包含程序的名字，如 &quot;main.go&quot;</span></span><br><span class="line">os.Args[<span class="number">1</span>] <span class="comment">// 第一个参数 &quot;file1.txt&quot;</span></span><br><span class="line">os.Args[<span class="number">2</span>] <span class="comment">// 第二个参数 &quot;file2.txt&quot;</span></span><br></pre></td></tr></table></figure><p><strong>例子：</strong><br>假如命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run main.go file1.txt file2.txt</span><br></pre></td></tr></table></figure><p>则：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(os.Args) </span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[main file1.txt file2.txt]</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="2-打开文件进行读取"><a href="#2-打开文件进行读取" class="headerlink" title="2. 打开文件进行读取"></a><strong>2. 打开文件进行读取</strong></h3><p>你的代码解析命令行参数后，会尝试打开这些文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">files := os.Args[<span class="number">1</span>:] <span class="comment">// 获取命令行参数列表（除程序本身外的部分）</span></span><br></pre></td></tr></table></figure><ul><li><code>files</code> 现在是一个切片：<code>[&quot;file1.txt&quot;, &quot;file2.txt&quot;]</code>。</li></ul><p>然后通过循环处理每个文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, arg := <span class="keyword">range</span> files &#123;</span><br><span class="line">    f, err := os.Open(arg) <span class="comment">// 打开文件</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Fprintf(os.Stderr, <span class="string">&quot;dup2: %v\n&quot;</span>, err) <span class="comment">// 错误处理</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> f.Close() <span class="comment">// 确保文件被正确关闭</span></span><br><span class="line">    countLines(f, counts)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中：</p><ol><li><p>**<code>os.Open(arg)</code>**：</p><ul><li>打开文件（如 <code>file1.txt</code>），返回一个文件指针 <code>*os.File</code>。</li><li>如果文件打开失败（文件不存在或权限问题），返回错误并跳过。</li></ul></li><li><p>**<code>countLines(f, counts)</code>**：</p><ul><li>将文件指针传递给 <code>countLines</code>，扫描文件的内容并统计每行的出现次数。</li></ul></li></ol><hr><h3 id="3-执行结果的输出"><a href="#3-执行结果的输出" class="headerlink" title="3. 执行结果的输出"></a><strong>3. 执行结果的输出</strong></h3><p>统计完成后，程序会输出所有出现次数大于 1 的行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> line, n := <span class="keyword">range</span> counts &#123;</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">1</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d\t%s\n&quot;</span>, n, line)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这会将文件中所有重复的行及其出现次数打印到控制台。</p><hr><h3 id="4-为什么能够读取多个文件"><a href="#4-为什么能够读取多个文件" class="headerlink" title="4. 为什么能够读取多个文件"></a><strong>4. 为什么能够读取多个文件</strong></h3><p>这是因为你的代码通过 <code>for _, arg := files</code> 遍历了 <code>os.Args[1:]</code> 中的所有文件，并依次处理它们。程序对每个文件重复以下流程：</p><ol><li>打开文件。</li><li>按行扫描内容，统计出现次数。</li><li>将结果合并到 <code>counts</code> 映射中。</li></ol><p>这样，即使你提供多个文件，程序依然可以逐个读取并处理它们。</p><hr><h3 id="运行流程示例"><a href="#运行流程示例" class="headerlink" title="运行流程示例"></a><strong>运行流程示例</strong></h3><p>假设有以下文件内容：</p><h4 id="file1-txt"><a href="#file1-txt" class="headerlink" title="file1.txt:"></a><code>file1.txt</code>:</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">world</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><h4 id="file2-txt"><a href="#file2-txt" class="headerlink" title="file2.txt:"></a><code>file2.txt</code>:</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">world</span><br><span class="line">hello</span><br><span class="line">go</span><br></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run main.go file1.txt file2.txt</span><br></pre></td></tr></table></figure><p>程序会：</p><ol><li>读取 <code>file1.txt</code>：<ul><li>统计结果：<code>&#123;&quot;hello&quot;: 2, &quot;world&quot;: 1&#125;</code>。</li></ul></li><li>读取 <code>file2.txt</code>，继续更新 <code>counts</code>：<ul><li>最终统计结果：<code>&#123;&quot;hello&quot;: 3, &quot;world&quot;: 2, &quot;go&quot;: 1&#125;</code>。</li></ul></li><li>打印重复行：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3   hello</span><br><span class="line">2   world</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>你可以读取多个文件是因为程序通过 <code>os.Args</code> 获取了命令行中的文件名列表，并通过循环逐个打开和读取文件的内容。这种设计使得你的程序能够动态处理任意数量的文件，而无需修改代码。</p><hr><h3 id="12-14-日-更考完4级"><a href="#12-14-日-更考完4级" class="headerlink" title="12.14 日 更考完4级"></a>12.14 日 更考完4级</h3><h4 id="一-Errors"><a href="#一-Errors" class="headerlink" title="一.Errors"></a>一.Errors</h4><ol><li>“errors” 包  使用给定的错误消息构造一个基本错误值。</li></ol><p>errors.New(“can’t work with 42”)</p><p>nil 表示没有错误</p><ol start="2"><li>哨兵错误是一个预先声明的变量，用于表示特定的错误情况。</li></ol><p>var ErrOutOfTea &#x3D; fmt.Errorf(“no more tea available”)<br>var ErrPower &#x3D; fmt.Errorf(“can’t boil water”)</p><ol start="3"><li>更高级别的错误来包装错误以添加上下文</li></ol><p>最简单的方法是使用 fmt.Errorf 中的 %w 动词。包装错误创建一个逻辑链（A 包装 B，B 包装 C 等），可以使用 error.Is 和 error.As 等函数进行查询。</p><p>return fmt.Errorf(“making tea: %w”, ErrPower)</p><ol start="4"><li>if 行中使用内联错误检查</li></ol><p>if r, e :&#x3D; f(i); e !&#x3D; nil {<br>fmt.Println(“f failed:”, e)<br>} else {<br>fmt.Println(“f worked:”, r)<br>}</p><ol start="5"><li>error.Is 检查给定错误（或其链中的任何错误）是否与特定错误值匹配。</li></ol><p>if errors.Is(err, ErrOutOfTea) {<br>fmt.Println(“We should buy new tea!”)<br>} else if errors.Is(err, ErrPower) {<br>fmt.Println(“Now it is dark.”)<br>} else {<br>fmt.Printf(“unknown error: %s\n”, err)<br>}</p><p>将err和我们自定义的哨兵错误或者特定错误做对比</p><p>二.自定义错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> argError <span class="keyword">struct</span> &#123;</span><br><span class="line">    arg     <span class="type">int</span></span><br><span class="line">    message <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *argError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%d - %s&quot;</span>, e.arg, e.message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Error 方法并没有直接调用，但 &amp;argError{arg, “can’t work with it”} 被返回为 error 类型时，Error 方法已经在幕后实现了对错误消息的封装。</p><p>error.As 是errors.Is 的更高级版本。它检查给定错误（或其链中的任何错误）是否与特定错误类型匹配，并转换为该类型的值，返回 true。如果没有匹配，则返回 false。</p><h4 id="Goroutines"><a href="#Goroutines" class="headerlink" title="Goroutines"></a>Goroutines</h4><p>轻量级的执行线程</p><p>go f(s)。这个新的 goroutine 将与调用的 goroutine 同时执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(from <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        fmt.Println(from, <span class="string">&quot;:&quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> f(<span class="string">&quot;goroutine&quot;</span>)</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>启动一个 goroutine 来进行匿名函数调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(msg <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">        fmt.Println(msg)</span><br><span class="line">    &#125;(<span class="string">&quot;going&quot;</span>)</span><br></pre></td></tr></table></figure><p>goroutine 是由 Go 运行时同时运行的。</p><h4 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h4><p>通道是连接并发 goroutine 的管道。您可以将值从一个 Goroutine 发送到通道，并将这些值接收到另一个 Goroutine。</p><p>messages :&#x3D; make(chan string)</p><p>通道 &lt;- 语法将值发送到通道</p><p>go func() { messages &lt;- “ping” }()</p><p>msg :&#x3D; &lt;-messages</p><p>&lt;-channel 语法从通道接收值。在这里，我们将收到上面发送的“ping”消息并将其打印出来。</p><p>发送和接收会阻塞，直到发送者和接收者都准备好为止。此属性允许我们在程序结束时等待“ping”消息，而无需使用任何其他同步。</p><p>通道缓冲：</p><p>messages :&#x3D; make(chan string, 2) 字符串通道，最多缓冲 2 个值 因此我们可以将这些值发送到通道中，而无需相应的并发接收。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> messages := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">messages &lt;- <span class="string">&quot;buffered&quot;</span></span><br><span class="line">messages &lt;- <span class="string">&quot;channel&quot;</span></span><br><span class="line"></span><br><span class="line"> fmt.Println(&lt;-messages)</span><br><span class="line"> fmt.Println(&lt;-messages)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="断言和switch用法"><a href="#断言和switch用法" class="headerlink" title="断言和switch用法:"></a>断言和switch用法:</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">t = functionOfSomeType()</span><br><span class="line"><span class="keyword">switch</span> t := t.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;unexpected type %T\n&quot;</span>, t)     <span class="comment">// %T prints whatever type t has</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;boolean %t\n&quot;</span>, t)             <span class="comment">// t has type bool</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;integer %d\n&quot;</span>, t)             <span class="comment">// t has type int</span></span><br><span class="line"><span class="keyword">case</span> *<span class="type">bool</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;pointer to boolean %t\n&quot;</span>, *t) <span class="comment">// t has type *bool</span></span><br><span class="line"><span class="keyword">case</span> *<span class="type">int</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;pointer to integer %d\n&quot;</span>, *t) <span class="comment">// t has type *int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型断言用于从接口类型值中提取其底层的具体类型。如果断言成功，程序可以安全地将该接口值转换为目标类型并使用。</p><p>value, ok :&#x3D; x.(T)</p><p>x 是一个接口类型的变量。<br>T 是目标类型（可以是具体类型或其他接口类型）。<br>如果 x 的动态类型是 T：<br>value 是 x 转换为 T 后的值。<br>ok 为 true。<br>如果 x 的动态类型不是 T：<br>value 是 T 的零值。<br>ok 为 false，表示断言失败。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; = <span class="number">42</span> <span class="comment">// 空接口存储了一个 int 值</span></span><br><span class="line"></span><br><span class="line">value, ok := x.(<span class="type">int</span>) <span class="comment">// 断言 x 是 int 类型</span></span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;x is an int, value: %d\n&quot;</span>, value)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;x is not an int&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空interface<br>空interface(interface{})不包含任何的method，正因为如此，所有的类型都实现了空interface。空interface对于描述起不到任何的作用(因为它不包含任何的method），但是空interface在我们需要存储任意类型的数值的时候相当有用，因为它可以存储任意类型的数值。它有点类似于C语言的void*类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义a为空接口</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span> = <span class="number">5</span></span><br><span class="line">s := <span class="string">&quot;Hello world&quot;</span></span><br><span class="line"><span class="comment">// a可以存储任意类型的数值</span></span><br><span class="line">a = i</span><br><span class="line">a = s</span><br></pre></td></tr></table></figure><p>一个函数把interface{}作为参数，那么他可以接受任意类型的值作为参数，如果一个函数返回interface{},那么也就可以返回任意类型的值。是不是很有用啊！</p><p>Go并发</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>小计划</title>
    <link href="https://whuichenggong.github.io/2024/12/02/study_plan/"/>
    <id>https://whuichenggong.github.io/2024/12/02/study_plan/</id>
    <published>2024-12-02T02:47:34.759Z</published>
    <updated>2024-12-19T14:02:27.389Z</updated>
    
    <content type="html"><![CDATA[<p>兄弟，你的想法很清晰，我非常理解你想深入学习、夯实基础，而不是走捷径的决心。我们可以针对你的目标和现状制定一个更加实践导向的计划，同时保持学习过程有趣且充实。以下是我的建议和方案：</p><hr><h3 id="总体目标"><a href="#总体目标" class="headerlink" title="总体目标"></a><strong>总体目标</strong></h3><ol><li><strong>短期（2025年3月前）</strong>：增强银行项目的实用性和技术深度，掌握后端开发的核心技能，为实习做好准备。</li><li><strong>中长期（未来两年）</strong>：夯实计算机基础，深入理解系统设计、分布式系统及核心算法，逐步具备独立设计和开发复杂项目的能力。</li></ol><hr><h3 id="学习模块规划"><a href="#学习模块规划" class="headerlink" title="学习模块规划"></a><strong>学习模块规划</strong></h3><h4 id="1-项目深度增强（每周一个主题，贯穿整个学习计划）"><a href="#1-项目深度增强（每周一个主题，贯穿整个学习计划）" class="headerlink" title="1. 项目深度增强（每周一个主题，贯穿整个学习计划）"></a><strong>1. 项目深度增强（每周一个主题，贯穿整个学习计划）</strong></h4><p>目标：将现有银行项目提升到更贴近实际业务需求的水平，增加亮点功能。</p><ul><li><p><strong>Week 1: 数据一致性与事务</strong></p><ul><li>学习事务隔离级别（ACID），在项目中实现更加复杂的转账操作（如跨账户冻结和解冻）。</li><li>使用 SQLC 或 GORM，优化数据库操作。</li></ul></li><li><p><strong>Week 2: 引入 Redis</strong></p><ul><li>学习 Redis 基础知识，理解其在缓存和分布式锁中的应用。</li><li>在项目中实现：<ul><li>用户信息缓存，优化频繁查询。</li><li>基于 Redis 的幂等性控制（防止转账操作重复）。</li></ul></li></ul></li><li><p><strong>Week 3: RESTful API 和 JWT 身份验证</strong></p><ul><li>深化对 RESTful API 的理解，优化项目 API 设计。</li><li>引入 JWT 实现用户登录认证和权限管理。</li></ul></li><li><p><strong>Week 4: 日志和监控</strong></p><ul><li>集成日志框架（如 Logrus&#x2F;Zap），记录系统操作。</li><li>学习 Prometheus 基础知识，为项目添加简单监控。</li></ul></li><li><p><strong>Week 5: Docker 和部署优化</strong></p><ul><li>使用 Docker Compose 部署完整项目，模拟生产环境。</li><li>学习 Nginx 基础知识，优化项目访问流程。</li></ul></li><li><p><strong>Week 6: 微服务化</strong></p><ul><li>学习 Go 微服务框架（如 Gin、gRPC）。</li><li>将项目拆分成两个服务（如用户服务和交易服务），理解微服务架构基础。</li></ul></li></ul><hr><h4 id="2-算法与数据结构（每天一题，逐渐深入）"><a href="#2-算法与数据结构（每天一题，逐渐深入）" class="headerlink" title="2. 算法与数据结构（每天一题，逐渐深入）"></a><strong>2. 算法与数据结构（每天一题，逐渐深入）</strong></h4><p>目标：构建扎实的算法基础，为今后面试和实际开发做准备。</p><ul><li><strong>题目选择顺序</strong>：简单 -&gt; 中等 -&gt; 困难，优先 BFS&#x2F;DFS、二分查找、动态规划等重要领域。</li><li><strong>周主题</strong>：<ul><li>Week 1-2: 栈、队列、链表</li><li>Week 3-4: 二叉树与递归</li><li>Week 5-6: 动态规划与分治算法</li><li>Week 7+: 高频面试题复盘（重点记录和总结常见套路）。</li></ul></li></ul><hr><h4 id="3-计算机基础与原理（每周一本书-主题）"><a href="#3-计算机基础与原理（每周一本书-主题）" class="headerlink" title="3. 计算机基础与原理（每周一本书&#x2F;主题）"></a><strong>3. 计算机基础与原理（每周一本书&#x2F;主题）</strong></h4><p>目标：夯实后端开发的计算机科学基础。</p><ul><li><p><strong>Week 1: 计算机网络</strong></p><ul><li>阅读《计算机网络：自顶向下方法》或《图解HTTP》。</li><li>重点学习 HTTP、HTTPS、TCP&#x2F;IP 的工作原理，并理解抓包工具（如 Wireshark）的使用。</li></ul></li><li><p><strong>Week 2: 操作系统</strong></p><ul><li>阅读《现代操作系统》。</li><li>理解线程、进程、同步机制，以及如何在 Go 中实现简单的并发处理。</li></ul></li><li><p><strong>Week 3-4: 数据库系统</strong></p><ul><li>阅读《数据库系统概念》。</li><li>理解索引、事务原理、查询优化等内容。</li></ul></li><li><p><strong>Week 5: 系统设计</strong></p><ul><li>阅读《系统设计入门》或相关博客。</li><li>学习常见系统设计模式（如限流、负载均衡）和架构决策。</li></ul></li></ul><hr><h3 id="具体每日安排（样例）"><a href="#具体每日安排（样例）" class="headerlink" title="具体每日安排（样例）"></a><strong>具体每日安排（样例）</strong></h3><ul><li><p><strong>上午</strong>：</p><ul><li>刷一道 LeetCode 算法题，阅读相关解析，整理题解。</li><li>学习书籍相关章节，完成1-2页的读书笔记。</li></ul></li><li><p><strong>下午</strong>：</p><ul><li>按周主题在银行项目中完成对应功能开发。</li><li>查看官方文档、博客或视频教程，记录学习中的关键点。</li></ul></li><li><p><strong>晚上</strong>：</p><ul><li>复习当天内容，整理代码和笔记。</li><li>自测项目功能，尝试优化代码。</li></ul></li></ul><hr><h3 id="可实践性建议"><a href="#可实践性建议" class="headerlink" title="可实践性建议"></a><strong>可实践性建议</strong></h3><ol><li><strong>建立个人技术博客</strong>：把每天的学习记录写成博客或日志，比如讲解项目中 Redis 的用法或总结某道算法题的思路。</li><li><strong>参与开源项目</strong>：找一个简单的 Go 开源项目，阅读代码，尝试修复 bug 或贡献文档。</li><li><strong>模拟面试</strong>：每两周自测一次，将银行项目作为核心，讲解架构设计和亮点功能。</li></ol><hr><h3 id="最终成果展示"><a href="#最终成果展示" class="headerlink" title="最终成果展示"></a><strong>最终成果展示</strong></h3><ul><li>一个高度完善的银行项目：<ul><li>支持分布式事务、JWT 身份验证、Redis 缓存与微服务架构。</li><li>提供完善的 Docker 部署文档。</li></ul></li><li>一个 LeetCode 高质量题解库（至少 50 道题）。</li><li>一份扎实的基础知识笔记，涵盖网络、操作系统和数据库。</li></ul><p>引入项目技术栈（2周）：在新项目中加入 SQLC 工具、中间件，理解每个技术的接入过程。</p><p>实现进阶功能（3周）：根据银行项目的转账逻辑，尝试自己独立实现一次。</p><p>重点学习 HTTP 和 RESTful API。 深入理解数据库  深入理解数据库 熟悉中间件的实现逻辑</p><p>Web开发</p><ol><li>Go by example</li><li>三本书</li><li>两个项目 Memos Apache Answer</li><li>算法</li><li>gin-gonic.com</li></ol><p>微服务进阶</p><p>  gRPC</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;兄弟，你的想法很清晰，我非常理解你想深入学习、夯实基础，而不是走捷径的决心。我们可以针对你的目标和现状制定一个更加实践导向的计划，同时保持学习过程有趣且充实。以下是我的建议和方案：&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;总体目标&quot;&gt;&lt;a href=&quot;#总体目标&quot; class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>11.26日字节直播总结</title>
    <link href="https://whuichenggong.github.io/2024/11/26/Dance_live2/"/>
    <id>https://whuichenggong.github.io/2024/11/26/Dance_live2/</id>
    <published>2024-11-26T12:20:49.917Z</published>
    <updated>2024-11-26T12:25:46.917Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字节结营直播答疑"><a href="#字节结营直播答疑" class="headerlink" title="字节结营直播答疑"></a>字节结营直播答疑</h1><p>revue 项目</p><p><img src="/about_Dance/1.png" alt="image-20241126190953519"></p><p><img src="/about_Dance/2.png" alt="image-20241126191031196"></p><p>性能优化     ci&#x2F;cd流程 （ star法则来描述一件事情)</p><p>准备找实习 写好简历</p><p><img src="/about_Dance/3.png" alt="image-20241126191500892"></p><p>zt：</p><p>服务端： 计算机基础知识（字节：计算机网络 tcp&#x2F;ip  腾讯：操作系统 阿里： 组成原理）</p><p>技术： （数据结构 高阶算法 链表 堆栈 树（面试重点））</p><p>leetcode 100 150 200</p><p>项目： 烂大街的（入门） 改进一些项目（做优化 项目存在的意义 解决了什么问题？ 带来了什么？ 项目亮点在哪里）</p><p>实习经历：（做了什么需求 需求是（谁给的 自己还是别人？）通过实现了什么？ 解决了什么？ 团队收益还是小组收益？）</p><p>专业能力： 小厂一门语言 ＋数据库存储 会就ok  大数据 架构数据 微服务层面</p><p><img src="/about_Dance/4.png" alt="image-20241126192005590"></p><p>八股扎实稳固 算法 中等难度题很快弄出来</p><p>项目亮点：能让面试官和你聊下去 如何提升亮点和竞争力  开源社区！</p><p>抄项目 然后手写 尝试自己理解      前端（vue）（react）</p><p><img src="/about_Dance/5.png" alt="image-20241126192541252"></p><p>数据结构 计算机基础知识  面试官想看你的亮点（你牛逼在哪里？）</p><p>做过什么会什么？</p><p>服务端是一些思维 而不是纠结你是用什么语言</p><p>从0-1 有没有调研 各行各业的优秀作业</p><p>合作项目</p><p>责任意识</p><p>技术探索：遇到什么问题 怎么解决的？</p><p>业务理解能力 项目受众是谁 项目模块 最重要是哪个模块 怎么优化这个模块</p><p><img src="/about_Dance/6.png" alt="image-20241126193100190"></p><p><img src="/about_Dance/7.png" alt="image-20241126193341747"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">“开源社区新手入门该参与什么内容，有哪些社区比较活跃”</span><br><span class="line">可以看看类似于开源之夏这类的活动往年都是做什么的</span><br></pre></td></tr></table></figure><p>多逛github</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">“在github中新手怎么找项目”</span><br><span class="line">，你用vue就去看VUE文档仓库，看看有没有错别字，有的话修一下</span><br></pre></td></tr></table></figure><p>项目的含金量 和自己从0-1实现</p><p>组件多 中间件多 新奇的做法等 可以被称为含金量（）</p><p>核心能力 技术深度 在广度的前提下 一定要有一个深度</p><p>项目一样 面试官能问什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">老哥们 大二第一次找实习的话一般要什么程度我正在跟着别人做一个项目 但是不知道什么时候才够格去投简历”</span><br><span class="line">看看面经别人被问了什么你能不能回答</span><br></pre></td></tr></table></figure><p><img src="/about_Dance/8.png" alt="image-20241126193803102"></p><p>平地起项目 是有条件的： 大厂实习 项目经历&gt;&#x3D;3 等经历 否则不要平地起</p><p>对于项目的理解一定是从头到尾的 对项目改造 新增功能 优化 才能体现你的亮点</p><p>思考 ： 多人协作是否有沟通 是否涉及复杂逻辑</p><p>新颖的想法！ 创造力！</p><p>投简历的方式</p><p>如何面对八股 算法</p><p>找开源项目：熟悉流程 寻找错别字熟悉流程哈哈哈 看issue bug（解决issue）</p><p>知乎 蔚来 比亚迪 从小厂到大厂 循序渐进</p><p><img src="/about_Dance/9.png" alt="image-20241126195807918"></p><p>字节  99%go</p><p>语言是基础无所谓</p><p>培养独立解决问题的能力 做出一个合格的项目 （不断回顾自己的项目 查找不足）</p><p>后端开发实习生（简历）</p><p>数据库的课（掘金的）</p><p>《Redis深度历险：核心原理和应用实践》</p><p>服务端开源： 不建议新手就去找开源 学习成本很大 2~3段实习之后尝试开源</p><p><img src="/about_Dance/10.png" alt="image-20241126200922693"></p><p>知名项目源码： 前提一定要熟悉使用这个项目的源码 项目的使用环境 如何启动它</p><p>例如：熟练使用docker ， kubernets istio了，再去看源码 i   <strong>写出一个对源码理解的文章</strong></p><p>对于源码：一步一步慢慢来 该学的东西就学 不要纠结没用的例如学历 没法改变就不去改变</p><p>.md .sh 依赖那些中间件 中间件是否具备？ 如何去不使用中间件如何启动这个项目 分析目录结构（单体 还是微服务）包的作用 模块之间的耦合关系  利用isue 项目常见报错解决方式</p><p>组队开发的群聊看看能不能找到</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;字节结营直播答疑&quot;&gt;&lt;a href=&quot;#字节结营直播答疑&quot; class=&quot;headerlink&quot; title=&quot;字节结营直播答疑&quot;&gt;&lt;/a&gt;字节结营直播答疑&lt;/h1&gt;&lt;p&gt;revue 项目&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/about_Dance/1.png&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>UDP socket的ack机制和丢包重传</title>
    <link href="https://whuichenggong.github.io/2024/11/23/UDP_socket/"/>
    <id>https://whuichenggong.github.io/2024/11/23/UDP_socket/</id>
    <published>2024-11-23T09:15:42.999Z</published>
    <updated>2024-12-15T12:37:16.302Z</updated>
    
    <content type="html"><![CDATA[<p>参考连接： <a href="https://juejin.cn/post/7263378772040122429">https://juejin.cn/post/7263378772040122429</a></p><h1 id="Go语言实现UDP-socket的ack机制和丢包重传"><a href="#Go语言实现UDP-socket的ack机制和丢包重传" class="headerlink" title="Go语言实现UDP socket的ack机制和丢包重传"></a>Go语言实现UDP socket的ack机制和丢包重传</h1><p>UDP 在通讯之前不需要建立连接 可以直接发送数据包 是一种无连接协议（常用于音视频传输）</p><p>但是在有些场景 即需要UDP传输也需要向TCP一样（TCP的可靠传输）</p><p>解决丢包问题：</p><p>1.添加 seq&#x2F;ack机制 确保数据发送到对端</p><p>什么是 seq&#x2F;ack机制</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在TCP（传输控制协议）中，序号（Sequence Number，简称seq）和确认应答号（Acknowledgment Number，简称ack）是协议头部非常关键的字段，它们共同确保了TCP的可靠性和数据按顺序传输的特性。</span><br><span class="line"></span><br><span class="line">** Sequence Number **</span><br><span class="line">含义：序号是指一个TCP报文段中第一个字节的数据序列标识。它表示在一个TCP连接中，该报文段所携带的数据的开始位置。序号是用来保证数据传输的顺序性和完整性的。</span><br><span class="line"></span><br><span class="line">作用：在TCP连接建立时，双方各自随机选择一个初始序列号（ISN）。随后传输的每个报文段的序号将基于这个初始值递增，其增量为该报文段所携带的数据量（字节数）。通过这种方式，接收方可以根据序号重组乱序到达的数据片段，确保数据的正确顺序和完整性。如果接收到的报文段不连续，接收方可以通过TCP的重传机制请求发送方重新发送缺失的数据。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**Acknowledgment Number**</span><br><span class="line">含义：确认应答号是接收方期望从发送方接收到的下一个报文段的序号。它实质上是接收方告诉发送方：“我已经成功接收到了哪个序号之前的所有数据，请从这个序号开始发送后续的数据。”</span><br><span class="line"></span><br><span class="line">作用：确认应答号用于实现可靠性传输。当一个报文段被接收方正确接收时，接收方会发送一个ACK报文，其中包含的确认应答号是接收到的数据加上1（即接收方期望接收的下一个数据的序号）。通过检查这个确认应答号，发送方能够知道其发送的数据是否已被接收方正确接收，并据此决定是否需要重传某些数据段。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ack和seq 保证了：</p><ul><li>确保数据的顺序性：即使数据片段在网络中的传输过程中顺序被打乱，接收方也能根据序号正确地重组这些数据。</li><li>检测丢包：如果发送方发送的数据长时间未被确认（即没有收到对应的ACK报文），它会判断这些数据可能已丢失，并将其重新发送。</li><li>实现流量控制和拥塞控制：通过调整发送未被确认数据的量（即控制窗口大小），TCP可以根据网络条件动态调整数据发送的速率，避免网络拥塞。</li></ul><h4 id="Golang的socket编程："><a href="#Golang的socket编程：" class="headerlink" title="Golang的socket编程："></a>Golang的socket编程：</h4><p>Go语言通过标准库中的<code>net</code>包来实现UDP和TCP的socket编程。<code>net</code>包提供了用于创建和管理网络连接的函数，以及用于进行数据传输的相关类型和方法，不同于C++需要手动设置和管理socket API，不论实现UDP还是TCP都可以直接使用封装好的方法进行操作，大大简化了socket编程：</p><h5 id="使用net包实现UDP通信"><a href="#使用net包实现UDP通信" class="headerlink" title="使用net包实现UDP通信"></a>使用net包实现UDP通信</h5><h6 id="1-client-go"><a href="#1-client-go" class="headerlink" title="1.client.go"></a>1.client.go</h6><p>1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;bufio&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;net&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">// 创建UDP连接到服务器的地址和端口号</span><br><span class="line">c, err := net.DialUDP(&quot;udp&quot;, nil, &amp;net.UDPAddr&#123;</span><br><span class="line">IP:   net.IPv4(127, 0, 0, 1),</span><br><span class="line">Port: 8282,</span><br><span class="line">&#125;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(&quot;dial err: %v\n&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">defer c.Close() // 将 defer 放在 if 语句外面</span><br><span class="line"></span><br><span class="line">// 从标准输入读取用户输入的数据</span><br><span class="line">input := bufio.NewReader(os.Stdin)</span><br><span class="line">for &#123;</span><br><span class="line">// 读取用户输入知道遇见换行符</span><br><span class="line">s, err := input.ReadString(&#x27;\n&#x27;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Printf(&quot;read from stdin failed, err: %v\n&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将用户输入的数据转换为字节数组并通过UDP连接发送给服务器</span><br><span class="line">_, err = c.Write([]byte(s))</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Printf(&quot;send to server failed, err: %v\n&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 接收来自服务器的数据</span><br><span class="line">var buf [1024]byte</span><br><span class="line">n, addr, err := c.ReadFromUDP(buf[:])</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Printf(&quot;recv from udp failed, err: %v\n&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 打印来自服务器的数据</span><br><span class="line">fmt.Printf(&quot;服务器 %v, 响应数据: %v\n&quot;, addr, string(buf[:n]))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="2-server-go"><a href="#2-server-go" class="headerlink" title="2.server.go"></a>2.server.go</h6><p>首先创建UDP监听器监听指定IP和端口，等待连接客户端，连接后会读取客户端发来的数据并打印收到的数据，并将接收的响应信息返回发送给客户端，使用死循环使其能够持续获取客户端数据，同样实现了UDP的数据接收和发送，实现了简单的UDP服务器；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;net&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// udp server</span><br><span class="line">func main() &#123;</span><br><span class="line">// 创建一个UDP监听器，监听本地IP地址的端口</span><br><span class="line">listen, err := net.ListenUDP(&quot;udp&quot;, &amp;net.UDPAddr&#123;</span><br><span class="line">IP:   net.IPv4(127, 0, 0, 1),</span><br><span class="line">Port: 8282,</span><br><span class="line">&#125;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Printf(&quot;listen failed,err:%v\n&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">defer listen.Close()</span><br><span class="line"></span><br><span class="line">for &#123;</span><br><span class="line">var buf [1024]byte</span><br><span class="line">// 从UDP连接中读取数据到buf中，n为读取到的字节数，addr为数据发送者的地址</span><br><span class="line">n, addr, err := listen.ReadFromUDP(buf[:])</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Printf(&quot;read from udp failed,err:%v\n&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 打印接收到的数据</span><br><span class="line">fmt.Println(&quot;接收到的数据：&quot;, string(buf[:n]))</span><br><span class="line"></span><br><span class="line">// 将接收到的数据原样发送回给数据发送者</span><br><span class="line">_, err = listen.WriteToUDP(buf[:n], addr)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Printf(&quot;write to %v failed,err:%v\n&quot;, addr, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>效果：（好有趣）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; go run client.go</span><br><span class="line">hello</span><br><span class="line">服务器 127.0.0.1:8282, 响应数据: hello</span><br><span class="line"></span><br><span class="line">world</span><br><span class="line">服务器 127.0.0.1:8282, 响应数据: world</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> go run server.go</span><br><span class="line">接收到的数据： hello</span><br><span class="line"></span><br><span class="line">接收到的数据： world</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="基于seq-apk"><a href="#基于seq-apk" class="headerlink" title="基于seq&#x2F;apk"></a>基于seq&#x2F;apk</h5><p>client</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">Seq <span class="type">int</span></span><br><span class="line">Msg <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c, err := net.DialUDP(<span class="string">&quot;udp&quot;</span>, <span class="literal">nil</span>, &amp;net.UDPAddr&#123;</span><br><span class="line">IP:   net.IPv4(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">Port: <span class="number">8282</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;dail err:%v\n&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> c.Close()</span><br><span class="line"></span><br><span class="line">input := []<span class="type">string</span>&#123;<span class="string">&quot;Message1&quot;</span>, <span class="string">&quot;Message2&quot;</span>, <span class="string">&quot;Message3&quot;</span>, <span class="string">&quot;Message4&quot;</span>, <span class="string">&quot;Message5&quot;</span>&#125;</span><br><span class="line">seq := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, msg := <span class="keyword">range</span> input &#123;</span><br><span class="line">seq++</span><br><span class="line">message := Message&#123;Seq: seq, Msg: msg&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Sending seq=%d: %s\n&quot;</span>, message.Seq, message.Msg)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送带有序列号的数据包</span></span><br><span class="line">_, err = c.Write(encodeMessage(message))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;send to server failed,err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等待ACK，设置超时时间</span></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">c.SetReadDeadline(time.Now().Add(<span class="number">5</span> * time.Second))</span><br><span class="line">n, _, err := c.ReadFromUDP(buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;ACK not received. Timeout or Error.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ack := decodeMessage(buf[:n])</span><br><span class="line"><span class="keyword">if</span> ack.Seq == seq+<span class="number">1</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;ACK = %d\n&quot;</span>, ack.Seq)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Invalid ACK received. Retry.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">encodeMessage</span><span class="params">(msg Message)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line"><span class="comment">// 将序列号和消息文本编码成字节数据</span></span><br><span class="line"><span class="keyword">return</span> []<span class="type">byte</span>(fmt.Sprintf(<span class="string">&quot;%d;%s&quot;</span>, msg.Seq, msg.Msg))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decodeMessage</span><span class="params">(data []<span class="type">byte</span>)</span></span> Message &#123;</span><br><span class="line"><span class="comment">// 解码收到的数据，提取序列号和消息文本</span></span><br><span class="line">parts := strings.Split(<span class="type">string</span>(data), <span class="string">&quot;;&quot;</span>)</span><br><span class="line">seq, _ := strconv.Atoi(parts[<span class="number">0</span>])</span><br><span class="line">msg := parts[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">return</span> Message&#123;Seq: seq, Msg: msg&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>server</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Message2 <span class="keyword">struct</span> &#123;</span><br><span class="line">Seq <span class="type">int</span></span><br><span class="line">Msg <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">listen, err := net.ListenUDP(<span class="string">&quot;udp&quot;</span>, &amp;net.UDPAddr&#123;</span><br><span class="line">IP:   net.IPv4(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">Port: <span class="number">8282</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;listen failed,err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> listen.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">var</span> buf [<span class="number">1024</span>]<span class="type">byte</span></span><br><span class="line">n, addr, err := listen.ReadFromUDP(buf[:])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;read from udp failed,err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理接收到的数据，提取序列号和消息文本</span></span><br><span class="line">message := decodeMessage1(buf[:n])</span><br><span class="line">fmt.Printf(<span class="string">&quot;Received seq=%d from %v: %s\n&quot;</span>, message.Seq, addr, message.Msg)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送ACK回复给客户端，ACK=Seq+1</span></span><br><span class="line">ack := Message2&#123;Seq: message.Seq + <span class="number">1</span>, Msg: <span class="string">&quot;ACK&quot;</span>&#125;</span><br><span class="line">_, err = listen.WriteToUDP(encodeMessage1(ack), addr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;write to %v failed,err:%v\n&quot;</span>, addr, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">encodeMessage1</span><span class="params">(msg Message2)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line"><span class="comment">// 将序列号和消息文本编码成字节数据</span></span><br><span class="line"><span class="keyword">return</span> []<span class="type">byte</span>(fmt.Sprintf(<span class="string">&quot;%d;%s&quot;</span>, msg.Seq, msg.Msg))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decodeMessage1</span><span class="params">(data []<span class="type">byte</span>)</span></span> Message2 &#123;</span><br><span class="line"><span class="comment">// 解码收到的数据，提取序列号和消息文本</span></span><br><span class="line">parts := strings.Split(<span class="type">string</span>(data), <span class="string">&quot;;&quot;</span>)</span><br><span class="line">seq, _ := strconv.Atoi(parts[<span class="number">0</span>])</span><br><span class="line">msg := parts[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">return</span> Message2&#123;Seq: seq, Msg: msg&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>问题核心：在同一文件夹内，Go 默认将所有文件视为同一包的一部分，可能导致重复定义或未定义的错误。<br>推荐解决方法：<br>分文件夹运行。<br>提取共享逻辑到单独的文件。<br>运行时显式指定所有 .go 文件。<br>额外改进：通过参数区分服务端和客户端运行模式，进一步优化程序结构。</p><p>，服务器监听的端口可能是某个固定端口（例如 12345），而客户端的UDP数据包来自 127.0.0.1:59653。这意味着：<br>UDP允许客户端选择任意可用的端口号作为源端口，并将数据包发送到服务器的监听端口。这也是为什么你看到不同的端口号。</p><hr><h5 id="4-实现超时重传"><a href="#4-实现超时重传" class="headerlink" title="4.实现超时重传"></a>4.实现超时重传</h5><p>最简单的方法就是当超时没有收到ack回复或者ack回复错误乱序时，阻塞后续发包，先进行重传，<br>把丢失的包重传后再继续发包，因此主要是在客户端更改一些发包的逻辑，服务端则没有变化；</p><p>client.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">Seq <span class="type">int</span></span><br><span class="line">Msg <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c, err := net.DialUDP(<span class="string">&quot;udp&quot;</span>, <span class="literal">nil</span>, &amp;net.UDPAddr&#123;</span><br><span class="line">IP:   net.IPv4(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">Port: <span class="number">8282</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;dial,err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> c.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例数据</span></span><br><span class="line">input := []<span class="type">string</span>&#123;<span class="string">&quot;Message 1&quot;</span>, <span class="string">&quot;Message 2&quot;</span>, <span class="string">&quot;Message 3&quot;</span>, <span class="string">&quot;Message 4&quot;</span>, <span class="string">&quot;Message 5&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> seq, msg := <span class="keyword">range</span> input &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">message := Message&#123;Seq: seq + <span class="number">1</span>, Msg: msg&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Sending seq=%d: %s\n&quot;</span>, message.Seq, message.Msg)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送带有序列号的数据包</span></span><br><span class="line">_, err := c.Write(encodeMessage(message))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;send to server failed,err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始等待ACK，设置超时时间</span></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">c.SetReadDeadline(time.Now().Add(<span class="number">5</span> * time.Second))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环等待ACK，直到收到正确的ACK或超时</span></span><br><span class="line">n, _, err := c.ReadFromUDP(buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 超时或发生错误，需要重传</span></span><br><span class="line">fmt.Println(<span class="string">&quot;ACK not received. Timeout or Error. Retrying...&quot;</span>)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//解码从服务器传来的ack</span></span><br><span class="line">ack := decodeMessage(buf[:n])</span><br><span class="line"><span class="keyword">if</span> ack.Seq == seq+<span class="number">2</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;ACK = %d\n&quot;</span>, ack.Seq)</span><br><span class="line"><span class="comment">// 收到正确的ACK，跳出内部循环，继续发送下一个消息</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 收到错误的ACK，继续等待，内部循环会重发相同的消息</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Invalid ACK received. Waiting for correct ACK...&quot;</span>)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">encodeMessage</span><span class="params">(msg Message)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line"><span class="comment">// 将序列号和消息文本编码成字节数据</span></span><br><span class="line"><span class="keyword">return</span> []<span class="type">byte</span>(fmt.Sprintf(<span class="string">&quot;%d;%s&quot;</span>, msg.Seq, msg.Msg))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decodeMessage</span><span class="params">(data []<span class="type">byte</span>)</span></span> Message &#123;</span><br><span class="line"><span class="comment">// 解码收到的数据，提取序列号和消息文本</span></span><br><span class="line">parts := strings.Split(<span class="type">string</span>(data), <span class="string">&quot;;&quot;</span>)</span><br><span class="line">seq, _ := strconv.Atoi(parts[<span class="number">0</span>])</span><br><span class="line">msg := parts[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">return</span> Message&#123;Seq: seq, Msg: msg&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>server.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math/rand&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">Seq <span class="type">int</span></span><br><span class="line">Msg <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">listen, err := net.ListenUDP(<span class="string">&quot;udp&quot;</span>, &amp;net.UDPAddr&#123;</span><br><span class="line">IP:   net.IPv4(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">Port: <span class="number">8282</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;listen failed,err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> listen.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">var</span> buf [<span class="number">1024</span>]<span class="type">byte</span></span><br><span class="line">n, addr, err := listen.ReadFromUDP(buf[:])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;read from udp failed,err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以20%的概率模拟丢包</span></span><br><span class="line"><span class="keyword">if</span> rand.Float32() &lt; <span class="number">0.2</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;From %v lost package\n&quot;</span>, addr)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理接收到的数据，解码字节流 提取序列号和消息文本</span></span><br><span class="line">message := decodeMessage(buf[:n])</span><br><span class="line">fmt.Printf(<span class="string">&quot;Received seq=%d from %v: %s\n&quot;</span>, message.Seq, addr, message.Msg)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送ACK回复给客户端，ACK=Seq+1</span></span><br><span class="line">ack := Message&#123;Seq: message.Seq + <span class="number">1</span>, Msg: <span class="string">&quot;ACK&quot;</span>&#125;</span><br><span class="line"><span class="comment">//写入ack向UDP连接中</span></span><br><span class="line">_, err = listen.WriteToUDP(encodeMessage(ack), addr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;write to %v failed,err:%v\n&quot;</span>, addr, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">encodeMessage</span><span class="params">(msg Message)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line"><span class="comment">// 将序列号和消息文本编码成字节数据</span></span><br><span class="line"><span class="keyword">return</span> []<span class="type">byte</span>(fmt.Sprintf(<span class="string">&quot;%d;%s&quot;</span>, msg.Seq, msg.Msg))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decodeMessage</span><span class="params">(data []<span class="type">byte</span>)</span></span> Message &#123;</span><br><span class="line"><span class="comment">// 解码收到的数据，提取序列号和消息文本</span></span><br><span class="line">parts := strings.Split(<span class="type">string</span>(data), <span class="string">&quot;;&quot;</span>)</span><br><span class="line">seq, _ := strconv.Atoi(parts[<span class="number">0</span>])</span><br><span class="line">msg := parts[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">return</span> Message&#123;Seq: seq, Msg: msg&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述方法实现的丢包重传虽然能够正常工作，但是发送端使用双层循环嵌套，并且每次丢包都阻塞了后续发包，这样会导致重传的效率很低，只适用于小宽带低延时的情况，而且超时重传容易产生误判，主要有以下两种情况：</p><p>对方收到了数据包，但是ack发送途中丢失，其实就是我服务器模拟丢包的情况，服务器可能收到了数据，但是因为某种原因ack没能正确发送；<br>ack在回传的途中，但是时间已经超过了发送端的ack等待时间即超过了一次RTO，这样也会导致接收端收到数据却仍然重传的问题。</p><p>学习 滑动窗口 拥塞控制 优化一些东西 深入理解seq&#x2F;ack的原理和超时重传的逻辑 Go语言进行socket编程的方法 UDP和TCP的一些知识</p><p>借鉴文章：<a href="https://blog.csdn.net/weixin_41500064/article/details/135119715">https://blog.csdn.net/weixin_41500064/article/details/135119715</a></p><h5 id="流量控制："><a href="#流量控制：" class="headerlink" title="流量控制："></a>流量控制：</h5><p>作用：为了解决发送方和接收方速度不同而导致的数据丢失问题,当发送方发送的太快,接收方来不及接受就会导致数据丢失；</p><p>方式：由接收端采用滑动窗口的形式，告知发送方允许&#x2F;停止发包解决TCP丢包问题。</p><h5 id="拥塞控制："><a href="#拥塞控制：" class="headerlink" title="拥塞控制："></a>拥塞控制：</h5><p>作用：为了解决过多的数据注入到网络导致网络崩溃和超负荷问题；</p><p>方式：由发送方采用拥塞窗口的形式去判断网络状态，从而采取不同算法执行TCP动态发包解决网络整体质量问题。</p><p>典型的场景如以太网场景中10G设备向1G设备发TCP包：<br>10G网卡 10Gbps 持续发送TCP包 交换机 以 1Gbps每秒接收TCP包<br>TCP 提供一种机制可以让发送端根据接收端的实际接收能力控制发送的数据量。这就是所谓的流控制。<br>接收端主机向发送端主机通知自已可以接收数据的大小；<br>是发送端会发送不超过这个限度的数据，该大小限度就被称作窗口大小。窗口大小的值由接收端主机决定，而在TCP 首部中，专门有一个字段用来通知窗口大小：<br>接收主机将自己可以接收的缓冲区大小放入这个字段中通知给发送端，这个字段的值越大，说明网络的吞吐量越高。<br>发送端主机会根据接收端主机的指示，对发送数据的量进行控制。这也就形成了一个完整的TCP流控制(流量控制)。<br>当Window&#x3D;0时，即告知发送方停止发送数据。</p><h5 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h5><p>发送方先探测网络拥塞程度，并不是一开始就发送大量的数据，发送方会根据拥塞程度增大拥塞窗口cwnd。<br>拥塞窗口cwnd值是几就能发送几个数据段</p><h5 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h5><p>继上图达到cwnd≥ssthresh后采用该算法用来控制拥塞窗口的增长速率。</p><p>计算方法：每经过一个传输轮次cwnd值加1，让cwnd值呈线性缓慢增大</p><h5 id="拥塞发生"><a href="#拥塞发生" class="headerlink" title="拥塞发生"></a>拥塞发生</h5><p>当网络发生拥塞丢包时（如图假定cwnd&#x3D;24），会有两种情况：</p><p>超时重传（1988年TCP Tahoe版本，已废弃不用）</p><p>更新后的 ssthresh 值变为 12(即为出现超时时的窗口数值 24 的一半)，拥窗口再重新设置为1<br>并执行慢开始算法。当cwnd &#x3D; ssthresh &#x3D; 12 时改为执行拥塞避免算法拥塞窗口按线性规律增长，<br>每经过一个往返时间增加一个MSS的大小。在TCP拥塞控制的文献中经常可看见“乘法减小”(Multiplicative Decrease)和“加法增大”(Additive Increase)这样的提法。<br>“乘法减小”是指不论在开始阶段还是拥塞避免阶段，只要出现超时(即很可能出现了网络拥塞)，就把慢开始门限值 ssthresh 减半，即设置为当前的拥塞窗口的一半(与此同时，执行慢开始算法)。<br>而“加法增大”是指执行拥塞避免算法后，使拥塞窗口缓慢增大，以防止网络过早出现拥塞。上面两种算法合起来常称为 AIMD算法(加法增大乘法减小)。</p><h5 id="快重传与快恢复"><a href="#快重传与快恢复" class="headerlink" title="快重传与快恢复"></a>快重传与快恢复</h5><p>超时重传算法直接把cwnd减小到1太过强烈，若还能收到连续3个ACK说明网络质量没那么差。同时采用快重传和快恢复算法，过程如下：</p><p>（1）当发送方连续收到3个重复确认时即执行“乘法减小”算法，把慢开始门限ssthresh 减半；</p><p>（2）由于发送方现在认为网络不那么差，于是把cwnd值设置为开始门限ssthresh 减半后的数值；</p><p>（3）开始执行拥塞避免算法 (“加法增大”)使拥塞窗口缓慢地线性增大。</p><hr><h4 id="12-25-日"><a href="#12-25-日" class="headerlink" title="12.25 日"></a>12.25 日</h4><p>根据计算机网络这本书，深入了解UDP套接字编程：</p><p>整体的一个过程： 进程间彼此通过向套接字发送报文来进行通信</p><p>一个主机-》多个进程 1个进程-》多个套接字</p><p>帮助记忆： 进程是一间房子 而 套接字是房子门 还需要一个 端口 来识别我具体要将信息发送到哪间房子，也就是具体的房间号（端口）</p><ol><li>客户从键盘键入数据，并向服务器发送数据（将数据编码成字节流），</li><li>服务器接收数据（接收字节流）-》并将其解码为原始客户端输入的数据 （并把小写转换为大写）</li><li>服务器将修改的数据（编码为字节流）发送回客户端</li><li>客户端接收数据后解码 并显示在屏幕上</li></ol><p>接收源地址（ip+端口号）和分组</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考连接： &lt;a href=&quot;https://juejin.cn/post/7263378772040122429&quot;&gt;https://juejin.cn/post/7263378772040122429&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Go语言实现UDP-socket的ac</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>操作系统学习</title>
    <link href="https://whuichenggong.github.io/2024/11/16/computer_operate/"/>
    <id>https://whuichenggong.github.io/2024/11/16/computer_operate/</id>
    <published>2024-11-16T13:26:55.040Z</published>
    <updated>2024-12-16T02:53:54.307Z</updated>
    
    <content type="html"><![CDATA[<hr><p>6.cs081os学习</p><p>感谢：</p><p>参考资料：</p><p><a href="https://www.geeksforgeeks.org/pipe-system-call/">https://www.geeksforgeeks.org/pipe-system-call/</a></p><p>很好的文章：</p><p><a href="https://swtch.com/~rsc/thread/">https://swtch.com/~rsc/thread/</a></p><p>同步机制：<a href="https://zybtree.github.io/2020/08/12/%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/">https://zybtree.github.io/2020/08/12/%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/</a></p><p>参考答案： <a href="https://github.com/relaxcn/xv6-labs-2022-solutions/blob/main/doc/utils.md">https://github.com/relaxcn/xv6-labs-2022-solutions/blob/main/doc/utils.md</a></p><p>学习链接： <a href="https://pdos.csail.mit.edu/6.828/2021/schedule.html">https://pdos.csail.mit.edu/6.828/2021/schedule.html</a></p><hr><p>直接从进程与线程入手</p><h4 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h4><p>单独的CPU变换成多个虚拟的CPU</p><h5 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h5><p>当网页请求进入的时候 先查看 网页是否在缓存中 如果不是<br>启动一个磁盘请求用来获取网页  磁盘请求会花费很多时间 等待的过程中会有更多的请求进入<br>每个进程有它自己的虚拟的CPU 真正的CPU在进程之间来回切换<br>需要一些方法例如多个磁盘 模拟控制并发 进程就能发挥作用<br>来回切换称： 多道程序设计</p><p>支持多进程的多道程序系统<br>一个核一次也只能运行一个进程</p><p><img src="/study_photo2/operater1.jpg" alt="internet.jpg"></p><hr><h4 id="12-1日"><a href="#12-1日" class="headerlink" title="12.1日"></a>12.1日</h4><h5 id="一-进程的并发执行"><a href="#一-进程的并发执行" class="headerlink" title="一.进程的并发执行"></a>一.进程的并发执行</h5><ol><li>并发</li></ol><ul><li>进程的执行是间断的</li></ul><p>每个进程的生命周期期间CPU执行 由于某种原因暂停 每个进程执行是间断性的</p><ul><li>进程的执行速度是不可预测的</li></ul><p>进程调度，有其他事件的发生，每个进程上cpu执行坑你一点时间听着再接着运行</p><ol start="2"><li>共享</li></ol><ul><li>进程线程之间的制约性<br>在一个并发环境下多个进程或者线程之间会共享某些资源，在这些资源的使用过程中会产生进程之间的一种制约性。<br>比如当一个进程享用打印机这个资源，另外一个进程在第一个进程没有释放这个资源的前提之下就得不到这个资源，那就得等待。</li></ul><ol start="3"><li>不确定性</li></ol><ul><li>进程执行的结果与其执行的相对速度有关</li></ul><p>进程执行的结果和它的相对执行速度是有关系的，因此在不同的执行顺序的情况下，进程的执行结果也是不确定的。</p><h5 id="二-进程互斥"><a href="#二-进程互斥" class="headerlink" title="二.进程互斥"></a>二.进程互斥</h5><p>由于各进程要求使用共享资源(变量、文件等)， 而这些资源需要排他性使用，<br>各进程之间竞争使用这些资源，这一关系称为进程互斥。</p><ul><li>临界资源<br>系统中某些资源一次只允许一个进程使用，称这样的资源为临界资源或互斥资源或共享变量。<br>这些程序片段，分散在不同的进程里，它们的共同的特点是对同一个共享变量进行一些操作<br>这一段代码，和另外一个进程的这一段代码互为临界区，互为互斥区</li></ul><p><img src="/study_photo2/operater2.jpg" alt="internet.jpg"></p><h4 id="冯诺依曼模型"><a href="#冯诺依曼模型" class="headerlink" title="冯诺依曼模型"></a>冯诺依曼模型</h4><p>计算机基本结构：运算器 控制器 存储器 输入设备 输出设备</p><h5 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h5><p>程序和数据都是存储在内存，存储区域是线性的</p><p>存储数据的基本单位是 字节 每一个字节对应一个内存地址</p><p>最后一个地址为内存总字节数 -1 结构就像数序中的数据</p><h5 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h5><p>也就是cpu：<br>32位cpu一次可以计算4个字节<br>64位cpu一次可以计算8个字节 位数也就是cpu的位宽 代表cpu一次可以计算的数据量</p><p>8 位的 CPU，那么一次只能计算 1 个字节也就是0~255 范围内的数值 那么 32位也就是一次可以计算出 2的32次方这么大的数值<br>cpu内部组件：寄存器，控制单元和逻辑运算单元</p><p>为什么有了内存还需要寄存器？</p><p>寄存器种类（通用寄存器）（程序计数器）（指令寄存器）</p><p>因为： 内存离 CPU 太远了，而寄存器就在 CPU 里，紧挨着控制单元和逻辑运算单元，自然计算时速度会很快。</p><h6 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h6><p>总线用于cpu和内存以及其他设备之前的通信</p><p>（地址总线）：指定CPU将要操作的内存地址</p><p>（数据总线）：用于读写内存的数据</p><p>（控制总线）： 发送和接收信号，比如中断，设备复位等信号</p><p>CPU 要读写内存数据的时候：</p><ul><li>首先要通过「地址总线」来指定内存的地址；</li><li>然后通过「控制总线」控制是读或写命令；</li><li>最后通过「数据总线」来传输数据；</li></ul><h5 id="输入输出设备"><a href="#输入输出设备" class="headerlink" title="输入输出设备"></a>输入输出设备</h5><p>输入设备向计算机输入数据，计算机经过计算后，把数据输出给输出设备。<br>如果输入设备是键盘，按下按键时是需要和 CPU 进行交互的，这时就需要用到控制总线了。</p><h5 id="线路位宽与CPU位宽"><a href="#线路位宽与CPU位宽" class="headerlink" title="线路位宽与CPU位宽"></a>线路位宽与CPU位宽</h5><p>数据是如何通过线路传输的呢<br>操作电压，低电压表示 0，高压电压则表示 1</p><p>101 二进制数据，十进制则表示 5，如果只有一条线路，就意味着每次只能传递 1 bit 的数据， 那么传输 101 这个数据，就需要 3 次才能传输完成，这样的效率非常低。</p><p>增加线路，数据并行传输</p><p>CPU 想要操作「内存地址」就需要「地址总线」：</p><p>地址总线只有 1 条，那每次只能表示 「0 或 1」这两种地址  最大数量为 2（2^1）个</p><p>如果地址总线有 2 条，那么能表示 00、01、10、11 这四种地址  最大数量为 4（2^2）个</p><p>CPU 操作 4G 大的内存，那么就需要 32 条地址总线，因为 2 ^ 32 &#x3D; 4G</p><p>CPU位宽最好不要小于线路位宽</p><h5 id="a-little-operater-systerm"><a href="#a-little-operater-systerm" class="headerlink" title="a little operater systerm"></a>a little operater systerm</h5><p>链接 ： <a href="https://lwn.net/Articles/250967/">https://lwn.net/Articles/250967/</a></p><p><img src="/study_photo2/cpumemory.4.png" alt="internet.jpg"></p><p>所有 CPU（前面的示例中为两个，但可以有更多）都通过公共总线（前端总线，FSB）连接到北桥。除其他外，北桥还包含内存控制器，<br>其实现决定了计算机使用的 RAM 芯片的类型。不同类型的 RAM，例如 DRAM、Rambus 和 SDRAM，需要不同的内存控制器。</p><p>要访问所有其他系统设备，北桥必须与南桥进行通信。南桥通常称为 I&#x2F;O 桥，通过各种不同的总线处理与设备的通信。如今，PCI、PCI Express、SATA 和 USB 总线最为重要，但南桥也支持 PATA、IEEE 1394、串行和并行端口。<br>较旧的系统具有连接到北桥的 AGP 插槽。这样做是出于与北桥和南桥之间的连接速度不够快相关的性能原因。然而，如今 PCI-E 插槽全部连接到南桥。</p><hr><h2 id="让终端显示出自己说的话"><a href="#让终端显示出自己说的话" class="headerlink" title="让终端显示出自己说的话"></a>让终端显示出自己说的话<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">root@xiaoxinxiaohao:~# vim .bashrc</span><br><span class="line">root@xiaoxinxiaohao:~# source ~/.bashrc</span><br><span class="line">赵忠鹤闪亮登场</span><br><span class="line">Today is: Fri Dec  6 05:12:09 PM CST 2024</span><br><span class="line">今天也要充满活力哇咔咔</span><br><span class="line"></span><br></pre></td></tr></table></figure></h2><p>听从了一些学习的建议，带着问题去读书，想学什么，去书中学，带着问题去读书</p><hr><p>12.16日</p><h4 id="看到了b站的一个关于Go并发设计"><a href="#看到了b站的一个关于Go并发设计" class="headerlink" title="看到了b站的一个关于Go并发设计"></a>看到了b站的一个关于Go并发设计</h4><p>了解协程： 协程是一种用户级的轻量级线程。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈</p><p>主流语言基本上都选择了多线程作为并发设施</p><p>线程相关的概念就是抢占式多任务（Preemptive multitasking），而与协程相关的是协作式多任务</p><p>多线程编程是比较困难的， 因为调度程序任何时候都能中断线程， 必须记住保留锁， 去保护程序中重要部分， 防止多线程在执行的过程中断 协程默认会做好全方位保护， 以防止中断</p><h5 id="协程相比于多线程的优点"><a href="#协程相比于多线程的优点" class="headerlink" title="协程相比于多线程的优点"></a>协程相比于多线程的优点</h5><p>无需系统内核的上下文切换，减小开销； 因为：协程它不像线程和进程那样，需要进行系统内核上的上下文切换，协程的上下文切换是由开发人员决定的</p><p>无需原子操作锁定及同步的开销，不用担心资源共享的问题</p><p>单线程即可实现高并发，单核 CPU 即便支持上万的协程都不是问题，所以很适合用于高并发处理，尤其是在应用在网络爬虫中</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol><li>无法使用 CPU 的多核 因为： 协程的本质是个单线程</li><li>写协程就意味着你要一值写一些非阻塞的代码，使用各种异步版本的库，比如后面的异步爬虫教程中用的 aiohttp</li><li><strong>协程的概念最核心的点其实就是函数或者一段程序能够被挂起（说暂停其实也没啥问题），待会儿再恢复</strong></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;6.cs081os学习&lt;/p&gt;
&lt;p&gt;感谢：&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geeksforgeeks.org/pipe-system-call/&quot;&gt;https://www.geeksforgeeks.org/p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>20岁生日</title>
    <link href="https://whuichenggong.github.io/2024/11/16/live/"/>
    <id>https://whuichenggong.github.io/2024/11/16/live/</id>
    <published>2024-11-16T12:06:31.864Z</published>
    <updated>2024-11-16T12:24:16.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="生活的意义就是在于享受每一天，有开心，有难过，有惊喜！-享受它，生活就是这样！"><a href="#生活的意义就是在于享受每一天，有开心，有难过，有惊喜！-享受它，生活就是这样！" class="headerlink" title="生活的意义就是在于享受每一天，有开心，有难过，有惊喜！ 享受它，生活就是这样！"></a>生活的意义就是在于享受每一天，有开心，有难过，有惊喜！ 享受它，生活就是这样！</h2><p>有了博客可以让时间更具象化，留住每一刻，想看的时候翻一翻 感受真的不一样！</p><p>本来不想过生日的，但还是被寝室的兄弟们发现了哈哈哈哈好开心呢上大学的两年都收到了寝室5个兄弟给我送的蛋糕<br>感谢你们啦，尽管离开了家还是有人陪你过生日，非常开心，还是你们陪我走完大学四年<br>上高中的时候也没怎么正经过过生日，到了大学是你们让我的今天变得过呢更有意义，尽管在生活中有磕碰，但那是难以避免的！希望你们每个人以后路越来越好</p><p>也是收到家里人的好多红包啊哈哈啊哈好开心！ 感谢家人时刻牵挂着我！</p><h3 id="2023年的今天"><a href="#2023年的今天" class="headerlink" title="2023年的今天"></a>2023年的今天</h3><p><img src="/live/birsday.jpg" alt="生日"></p><h3 id="2024年的今天"><a href="#2024年的今天" class="headerlink" title="2024年的今天"></a>2024年的今天</h3><p><img src="/live/cake.jpg" alt="蛋糕"></p><hr><p>每年的生日许愿都是很广泛的 我姐说那是没有意义的哈哈哈一定要为自己许个愿望在新的一年实现它！</p><h3 id="小彩蛋"><a href="#小彩蛋" class="headerlink" title="小彩蛋"></a>小彩蛋</h3><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="/live/birsday.mp4" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><pre><code>11.16日</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;生活的意义就是在于享受每一天，有开心，有难过，有惊喜！-享受它，生活就是这样！&quot;&gt;&lt;a href=&quot;#生活的意义就是在于享受每一天，有开心，有难过，有惊喜！-享受它，生活就是这样！&quot; class=&quot;headerlink&quot; title=&quot;生活的意义就是在于享受每一天</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>7_days_golang学习</title>
    <link href="https://whuichenggong.github.io/2024/11/16/Goalng_Framework/"/>
    <id>https://whuichenggong.github.io/2024/11/16/Goalng_Framework/</id>
    <published>2024-11-16T11:46:47.251Z</published>
    <updated>2024-11-27T12:47:04.152Z</updated>
    
    <content type="html"><![CDATA[<h2 id="通过学习项目-7-days-golang搭建各种自己的框架了解一些网络工作原理和知识"><a href="#通过学习项目-7-days-golang搭建各种自己的框架了解一些网络工作原理和知识" class="headerlink" title="通过学习项目 7_days_golang搭建各种自己的框架了解一些网络工作原理和知识"></a>通过学习项目 7_days_golang搭建各种自己的框架了解一些网络工作原理和知识</h2><p>学习geektutu源代码：<a href="https://github.com/geektutu/7days-golang">https://github.com/geektutu/7days-golang</a></p><p>跟着学习的项目代码已经放在: <a href="https://github.com/Whuichenggong/Study_Go">https://github.com/Whuichenggong/Study_Go</a></p><h3 id="1-gee-go"><a href="#1-gee-go" class="headerlink" title="1.gee.go"></a>1.gee.go</h3><p>关键代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gee</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//首先定义了类型HandlerFunc，这是提供给框架用户的，用来定义路由映射的处理方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(http.ResponseWriter, *http.Request)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Engine中，添加了一张路由映射表router</span></span><br><span class="line"><span class="comment">// key 由请求方法和静态路由地址构成，例如GET-/、GET-/hello、POST-/hello</span></span><br><span class="line"><span class="comment">// 如果请求方法不同,可以映射不同的处理方法(Handler)，value 是用户映射的处理方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">router <span class="keyword">map</span>[<span class="type">string</span>]HandlerFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New is the constructor of gee.Engine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span></span> *Engine &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Engine&#123;router: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]HandlerFunc)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> addRoute(method <span class="type">string</span>, pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">key := method + pattern</span><br><span class="line">engine.router[key] = handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户调用(*Engine).GET()方法时，会将路由和处理方法注册到映射表 router 中，(*Engine).Run()方法，是 ListenAndServe 的包装。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> GET(pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">engine.addRoute(<span class="string">&quot;GET&quot;</span>, pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> POST(pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">engine.addRoute(<span class="string">&quot;POST&quot;</span>, pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> Run(addr <span class="type">string</span>) (err <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> http.ListenAndServe(addr, engine)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Engine实现的 ServeHTTP 方法的作用就是，解析请求的路径，查找路由映射表，如果查到，就执行注册的处理方法。如果查不到，就返回 404 NOT FOUND 。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">key := req.URL.Path</span><br><span class="line"><span class="keyword">if</span> handler, ok := engine.router[key]; ok &#123;</span><br><span class="line">handler(w, req)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;404 Not Found: %s\n&quot;</span>, req.URL)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-go-mod代码"><a href="#2-go-mod代码" class="headerlink" title="2.go.mod代码"></a>2.go.mod代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module github.com/Whuichenggong</span><br><span class="line"></span><br><span class="line">go 1.22.1</span><br><span class="line"></span><br><span class="line">require gee v0.0.0</span><br><span class="line"></span><br><span class="line">replace gee =&gt; ./gee</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>replace gee &#x3D;&gt; .&#x2F;gee</p><p>这是一个替换指令，它告诉 Go 工具链用本地相对路径 .&#x2F;gee 中的 gee 包替换远程需要的 gee 包。<br>这意味着，尽管 require 指令可能指向一个特定的远程版本或分支，<br>这个 replace 指令实际上将使用当前目录下的 gee 文件夹中的代码。</p><h4 id="2-1初始化-Go-模块："><a href="#2-1初始化-Go-模块：" class="headerlink" title="2.1初始化 Go 模块："></a>2.1初始化 Go 模块：</h4><p>如果你的项目还没有被初始化为 Go 模块，你需要先在项目的根目录下运行以下命令来初始化它：</p><p><code>go mod init &lt;module-name&gt;</code></p><p>替换 <module-name> 为你的模块名称。例如，如果你的项目名称是 example，你会运行：</p><p><code>go mod init example</code></p><h3 id="3-main-go"><a href="#3-main-go" class="headerlink" title="3.main.go"></a>3.main.go</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line"></span><br><span class="line">&quot;gee&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">r := gee.New()</span><br><span class="line">r.GET(&quot;/&quot;, func(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">fmt.Fprintf(w, &quot;URL.Path = %q\n&quot;, req.URL.Path)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.GET(&quot;/hello&quot;, func(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">for k, v := range req.Header &#123;</span><br><span class="line">fmt.Fprintf(w, &quot;Header[%q] = %q\n&quot;, k, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.Run(&quot;:9999&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="新增："><a href="#新增：" class="headerlink" title="新增："></a>新增：</h5><p>测试 POST 请求<br>启动服务器后，测试 POST 请求可以使用以下工具：</p><p>方法 1: 使用 curl<br>执行以下命令发送 POST 请求：</p><p>curl -X POST <a href="http://localhost:8080/submit">http://localhost:8080/submit</a></p><hr><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(http.ResponseWriter, *http.Request)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">router <span class="keyword">map</span>[<span class="type">string</span>]HandlerFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span></span> *Engine &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Engine&#123;router: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]HandlerFunc)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> addRoute(method <span class="type">string</span>, pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">key := method + pattern</span><br><span class="line">engine.router[key] = handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> POST(pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">engine.addRoute(<span class="string">&quot;POST&quot;</span>, pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> Run(addr <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">return</span> http.ListenAndServe(addr, engine)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">key := req.Method + req.URL.Path</span><br><span class="line"><span class="keyword">if</span> handler, ok := engine.router[key]; ok &#123;</span><br><span class="line">handler(w, req)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">http.NotFound(w, req)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>func main() {<br>engine :&#x3D; New()</p><pre><code>// 注册一个 POST 路由engine.POST(&quot;/submit&quot;, func(w http.ResponseWriter, req *http.Request) &#123;    // 读取请求体数据    body, err := ioutil.ReadAll(req.Body)    if err != nil &#123;        http.Error(w, &quot;Failed to read request body&quot;, http.StatusInternalServerError)        return    &#125;    // 响应请求体内容    fmt.Fprintf(w, &quot;Received: %s&quot;, string(body))&#125;)// 启动服务器engine.Run(&quot;:8080&quot;)</code></pre><p>}<br>测试：<br>启动程序后，用 curl 发送 POST 请求并附带数据：</p><p>b<br>curl -X POST -d “data&#x3D;HelloWorld” <a href="http://localhost:8080/submit">http://localhost:8080/submit</a><br>服务器返回：</p><p>kotlin</p><p>Received: data&#x3D;HelloWorld</p><h4 id="ServeHTTP好像有点问题"><a href="#ServeHTTP好像有点问题" class="headerlink" title="ServeHTTP好像有点问题"></a>ServeHTTP好像有点问题</h4><p>main.go<br>附带了对代码的理解</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gee</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//首先定义了类型HandlerFunc，这是提供给框架用户的，用来定义路由映射的处理方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(http.ResponseWriter, *http.Request)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Engine中，添加了一张路由映射表router</span></span><br><span class="line"><span class="comment">// key 由请求方法和静态路由地址构成，例如GET-/、GET-/hello、POST-/hello</span></span><br><span class="line"><span class="comment">// 如果请求方法不同,可以映射不同的处理方法(Handler)，value 是用户映射的处理方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">router <span class="keyword">map</span>[<span class="type">string</span>]HandlerFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New is the constructor of gee.Engine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span></span> *Engine &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Engine&#123;router: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]HandlerFunc)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这段代码的作用将HTTP请求的路由和对应的处理函数注册到路由表中的核心方法</span></span><br><span class="line"><span class="comment">// pattern路由路径</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> addRoute(method <span class="type">string</span>, pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line"><span class="comment">//将HTTp方法和路径拼接成唯一一个键 作为路由表的router的键</span></span><br><span class="line">key := method + pattern</span><br><span class="line"><span class="comment">//将处理函数 handler 存入路由表中，关联到对应的路由键。</span></span><br><span class="line">engine.router[key] = handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户调用 addRoute(&quot;GET&quot;, &quot;/home&quot;, someHandlerFunc) 在 engine.router 映射表中，会存储一个键值对：</span></span><br><span class="line"><span class="comment">// 调用engine.GET(&quot;/home&quot;, someHandlerFunc)： 实际是 等价 engine.addRoute(&quot;GET&quot;, &quot;/home&quot;, someHandlerFunc)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> GET(pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">engine.addRoute(<span class="string">&quot;GET&quot;</span>, pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> POST(pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">engine.addRoute(<span class="string">&quot;POST&quot;</span>, pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这段代码隐藏了调用ServeHTTP</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> Run(addr <span class="type">string</span>) (err <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> http.ListenAndServe(addr, engine)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Engine实现的 ServeHTTP 方法的作用就是，解析请求的路径，查找路由映射表，如果查到，就执行注册的处理方法。如果查不到，就返回 404 NOT FOUND 。</span></span><br><span class="line"><span class="comment">// 不需要显式调用 ServeHTTP</span></span><br><span class="line"><span class="comment">// 在 Go 的 HTTP 框架中，ServeHTTP 是 http.Handler 接口的约定方法。当你把 Engine 作为服务器的处理器传递时，它会被 ListenAndServe 自动调用。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">key := req.URL.Path</span><br><span class="line"><span class="keyword">if</span> handler, ok := engine.router[key]; ok &#123;</span><br><span class="line">handler(w, req)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;404 Not Found: %s\n&quot;</span>, req.URL)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>在 ServeHTTP 中，当前只从 req.URL.Path 获取路径，<br>而没有结合 req.Method，会导致不同的 HTTP 方法（如 GET 和 POST）冲突或无法正确匹配。<br>addRoute 方法仅使用了路径（pattern）和方法（method）拼接为路由键，例如：GET&#x2F;home。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> addRoute(method <span class="type">string</span>, pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">    key := method + <span class="string">&quot;-&quot;</span> + pattern <span class="comment">// 区分 HTTP 方法和路径</span></span><br><span class="line">    engine.router[key] = handler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改的这段代码<br>原来只使用了路径（req.URL.Path）作为路由键。例如：</p><p>请求路径 &#x2F;hello 的键为 &#x2F;hello。<br>不区分 GET &#x2F;hello 和 POST &#x2F;hello，它们会共用同一个路由键 &#x2F;hello。<br>建议的代码<br>使用 HTTP 方法和路径 拼接成路由键。例如：</p><p>GET &#x2F;hello 的键为 GET-&#x2F;hello。<br>POST &#x2F;hello 的键为 POST-&#x2F;hello。<br>这样可以区分不同方法对应的路由处理函数。</p><p>与gin框架启动很相似</p><hr><p>对Web服务来说，无非是根据请求*http.Request，构造响应http.ResponseWriter。<br>但是这两个对象提供的接口粒度太细，比如我们要构造一个完整的响应，需要考虑消息头(Header)和消息体(Body)，而 Header 包含了状态码(StatusCode)，<br>消息类型(ContentType)等几乎每次请求都需要设置的信息。因此，如果不进行有效的封装， 那么框架的用户将需要写大量重复，繁杂的代码<br>且容易出错。针对常用场景，能够高效地构造出 HTTP 响应是一个好的框架必须考虑的点。</p><p>代码要学会封装 否则代码整洁度看起来还是会差很多的 对于别人理解一会更方便</p><p>为什么要添加context  对于框架来说，还需要支撑额外的功能。例如，将来解析动态路由&#x2F;hello&#x2F;:name，参数:name的值放在哪呢？<br>再比如，框架需要支持中间件，那中间件产生的信息放在哪呢？</p><p>contxet保留了你想寻找的一些东西<br>拓展性和复杂性留在内部<br>对外简化了接口。</p><p>Context 的作用是为每个 HTTP 请求提供一个上下文对象，<br>方便操作请求和响应，并提供了一些简化开发的工具方法。<br>通过 Context 统一管理 HTTP 请求和响应的逻辑。</p><p>可以把 Context 看作是：</p><p>一个请求的容器： 它封装了与 HTTP 请求相关的所有信息，并提供了一些方法让你更轻松地操作这些信息。</p><p>开发者和 HTTP 请求的桥梁： 开发者通过 Context 与客户端通信，包括读取请求信息和发送响应。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(c *Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 获取查询参数</span></span><br><span class="line">name := c.Query(<span class="string">&quot;name&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造 JSON 响应</span></span><br><span class="line">    <span class="keyword">if</span> name != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        c.JSON(http.StatusOK, H&#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello &quot;</span> + name&#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        c.String(http.StatusBadRequest, <span class="string">&quot;Name is required&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>深入框架原理：<br>阅读 Gin、Echo 等框架的源码，了解它们如何设计和扩展 Context。</li></ol><p>尝试扩展功能：<br>在 Context 上添加自定义方法，比如记录日志、追踪请求 ID 等。</p><ol start="2"><li>http.ResponseWriter 和 *http.Request 的实际意义<br>http.ResponseWriter</li></ol><p>作用：<br>代表服务端用来写入 HTTP 响应的接口。开发者通过它向客户端返回数据（如响应头、响应状态码、响应体等）。<br>实际应用：<br>在服务端，http.ResponseWriter 将生成的 HTTP 响应数据写入 TCP 连接的输出流，客户端会接收到这些数据并解析呈现。<br>*http.Request</p><p>作用：<br>表示客户端发来的 HTTP 请求，包含了所有请求相关的信息（如 URL、方法、头部、表单数据、Cookie、Body 等）。<br>实际应用：<br>服务端根据 *http.Request 的内容（路径、方法等），判断客户端的需求并生成相应的响应。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line"><span class="comment">// 设置响应头</span></span><br><span class="line">w.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/plain&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置状态码</span></span><br><span class="line">w.WriteHeader(http.StatusOK)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入响应体</span></span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;Hello, %s!\n&quot;</span>, req.URL.Query().Get(<span class="string">&quot;name&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/&quot;</span>, handler)</span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端请求示例：</p><p>浏览器访问 <a href="http://localhost:8080/?name=zhaozhonghe">http://localhost:8080/?name=zhaozhonghe</a></p><p>服务端响应：</p><p>HTTP&#x2F;1.1 200 OK &#x2F;&#x2F;设置的状态码 200<br>Content-Type: text&#x2F;plain &#x2F;&#x2F;设置的请求头 响应过来了 并且返回到了 客户端页面<br>Content-Length: 12</p><p>Hello, zhaozhonghe! &#x2F;&#x2F; 读取 HTTP 请求 将数据写入响应体，通过 w 发送给客户端。</p><hr><h3 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h3><h4 id="1-添加context"><a href="#1-添加context" class="headerlink" title="1.添加context"></a>1.添加context</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gee</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//对Web服务来说，无非是根据请求*http.Request，构造响应http.ResponseWriter</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给map[string]interface&#123;&#125;起了一个别名gee.H，构建JSON数据时，显得更简洁。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> H <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Context目前只包含了http.ResponseWriter和*http.Request，另外提供了对 Method 和 Path 这两个常用属性的直接访问。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line">Writer http.ResponseWriter</span><br><span class="line">Req    *http.Request</span><br><span class="line"></span><br><span class="line">Path   <span class="type">string</span></span><br><span class="line">Method <span class="type">string</span></span><br><span class="line"></span><br><span class="line">StatusCode <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newContext</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> *Context &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Context&#123;</span><br><span class="line">Writer: w,</span><br><span class="line">Req:    req,</span><br><span class="line">Path:   req.URL.Path,</span><br><span class="line">Method: req.Method,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供了访问Query和PostForm参数的方法。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> PostForm(key <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.Req.FormValue(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> Query(key <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.Req.URL.Query().Get(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> Status(code <span class="type">int</span>) &#123;</span><br><span class="line">c.StatusCode = code</span><br><span class="line">c.Writer.WriteHeader(code)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> SetHeader(key <span class="type">string</span>, value <span class="type">string</span>) &#123;</span><br><span class="line">c.Writer.Header().Set(key, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供了快速构造String/Data/JSON/HTML响应的方法。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> String(code <span class="type">int</span>, format <span class="type">string</span>, values ...<span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">c.SetHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/plain&quot;</span>)</span><br><span class="line">c.Status(code)</span><br><span class="line">c.Writer.Write([]<span class="type">byte</span>(fmt.Sprintf(format, values...)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> JSON(code <span class="type">int</span>, obj <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">c.SetHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">c.Status(code)</span><br><span class="line">encoder := json.NewEncoder(c.Writer)</span><br><span class="line"><span class="keyword">if</span> err := encoder.Encode(obj); err != <span class="literal">nil</span> &#123;</span><br><span class="line">http.Error(c.Writer, err.Error(), <span class="number">500</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> Data(code <span class="type">int</span>, data []<span class="type">byte</span>) &#123;</span><br><span class="line">c.Status(code)</span><br><span class="line">c.Writer.Write(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> HTML(code <span class="type">int</span>, html <span class="type">string</span>) &#123;</span><br><span class="line">c.SetHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/html&quot;</span>)</span><br><span class="line">c.Status(code)</span><br><span class="line">c.Writer.Write([]<span class="type">byte</span>(html))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-添加router"><a href="#2-添加router" class="headerlink" title="2.添加router"></a>2.添加router</h4><p>想 路由需要的参数 路径 方法 处理函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gee</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> router <span class="keyword">struct</span> &#123;</span><br><span class="line">handlers <span class="keyword">map</span>[<span class="type">string</span>]HandlerFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newRouter</span><span class="params">()</span></span> *router &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;router&#123;handlers: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]HandlerFunc)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *router)</span></span> addRoute(method <span class="type">string</span>, pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Route %4s - %s&quot;</span>, method, pattern)</span><br><span class="line">key := method + <span class="string">&quot;-&quot;</span> + pattern</span><br><span class="line">r.handlers[key] = handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *router)</span></span> handle(c *Context) &#123;</span><br><span class="line">key := c.Method + <span class="string">&quot;-&quot;</span> + c.Path</span><br><span class="line"><span class="keyword">if</span> handler, ok := r.handlers[key]; ok &#123;</span><br><span class="line">handler(c)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.String(http.StatusNotFound, <span class="string">&quot;404 NOT FOUND: %s\n&quot;</span>, c.Path)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>r.handlers[key] &#x3D; handler 这段代码将key也就是路径 和 处理函数关连到了一起</p><p>post用终端请求<br>1.<br>Invoke-WebRequest -Uri “<a href="http://localhost:9999/login">http://localhost:9999/login</a>“ -Method POST -Body “username&#x3D;zhaozhonghe&amp;password&#x3D;zzh123456”</p><ol start="2"><li>curl.exe -X POST -d “username&#x3D;zhaozhonghe&amp;password&#x3D;zzh123456” <a href="http://localhost:9999/login">http://localhost:9999/login</a><br>返回结果<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;password&quot;:&quot;zzh123456&quot;,&quot;username&quot;:&quot;zhaozhonghe&quot;&#125;</span><br></pre></td></tr></table></figure></li></ol><p>测试第二天的gee<br>第一种返回结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">StatusCode        : 200</span><br><span class="line">StatusDescription : OK</span><br><span class="line">Content           : &#123;&quot;password&quot;:&quot;zzh123456&quot;,&quot;username&quot;:&quot;zhaozhonghe&quot;&#125;</span><br><span class="line"></span><br><span class="line">RawContent        : HTTP/1.1 200 OK</span><br><span class="line">Content-Length: 50</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Date: Tue, 26 Nov 2024 13:43:37 GMT</span><br><span class="line"></span><br><span class="line">                    &#123;&quot;password&quot;:&quot;zzh123456&quot;,&quot;username&quot;:&quot;zhaozhonghe&quot;&#125;</span><br><span class="line"></span><br><span class="line">Forms             : &#123;&#125;</span><br><span class="line">Headers           : &#123;[Content-Length, 50], [Content-Type, application/json], [Date, Tue, 26 Nov 2024 13:43:37 GMT]&#125;</span><br><span class="line">Images            : &#123;&#125;</span><br><span class="line">InputFields       : &#123;&#125;</span><br><span class="line">Links             : &#123;&#125;</span><br><span class="line">ParsedHtml        : mshtml.HTMLDocumentClass</span><br><span class="line">RawContentLength  : 50</span><br></pre></td></tr></table></figure><h4 id="gee-go"><a href="#gee-go" class="headerlink" title="gee.go"></a>gee.go</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gee</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HandlerFunc defines the request handler used by gee</span></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(*Context)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Engine implement the interface of ServeHTTP</span></span><br><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">router *router</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New is the constructor of gee.Engine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span></span> *Engine &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Engine&#123;router: newRouter()&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> addRoute(method <span class="type">string</span>, pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">engine.router.addRoute(method, pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GET defines the method to add GET request</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> GET(pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">engine.addRoute(<span class="string">&quot;GET&quot;</span>, pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// POST defines the method to add POST request</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> POST(pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">engine.addRoute(<span class="string">&quot;POST&quot;</span>, pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run defines the method to start a http server</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> Run(addr <span class="type">string</span>) (err <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> http.ListenAndServe(addr, engine)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">c := newContext(w, req)</span><br><span class="line">engine.router.handle(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h2><p>我们用了一个非常简单的map结构存储了路由表，使用map存储键值对，索引非常高效，但是有一个弊端，键值对的存储的方式，只能用来索引静态路由。<br>那如果我们想支持类似于&#x2F;hello&#x2F;:name这样的动态路由怎么办呢？<br>所谓动态路由，即一条路由规则可以匹配某一类型而非某一条固定的路由。<br>例如&#x2F;hello&#x2F;:name，可以匹配&#x2F;hello&#x2F;geektutu、hello&#x2F;jack等。<br>请等待~~~</p><p>11.21日看到了字节的课 是关于动态路由的设计 前缀匹配树</p><h4 id="router-go"><a href="#router-go" class="headerlink" title="router.go"></a>router.go</h4><p>前缀树路由： 重点学习这个数据结构</p><p>bilibili: <a href="https://www.bilibili.com/video/BV1wT4y1x7xm?t=45.6">https://www.bilibili.com/video/BV1wT4y1x7xm?t=45.6</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gee</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> router <span class="keyword">struct</span> &#123;</span><br><span class="line">roots    <span class="keyword">map</span>[<span class="type">string</span>]*node <span class="comment">//增加的</span></span><br><span class="line">handlers <span class="keyword">map</span>[<span class="type">string</span>]HandlerFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newRouter</span><span class="params">()</span></span> *router &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;router&#123;</span><br><span class="line">roots:    <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*node),</span><br><span class="line">handlers: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]HandlerFunc),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Only one * is allowed</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parsePattern</span><span class="params">(pattern <span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">vs := strings.Split(pattern, <span class="string">&quot;/&quot;</span>)</span><br><span class="line"></span><br><span class="line">parts := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> vs &#123;</span><br><span class="line"><span class="keyword">if</span> item != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">parts = <span class="built_in">append</span>(parts, item)</span><br><span class="line"><span class="keyword">if</span> item[<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> parts</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *router)</span></span> addRoute(method <span class="type">string</span>, pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">parts := parsePattern(pattern)</span><br><span class="line"></span><br><span class="line">key := method + <span class="string">&quot;-&quot;</span> + pattern</span><br><span class="line">_, ok := r.roots[method]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">r.roots[method] = &amp;node&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">r.roots[method].insert(pattern, parts, <span class="number">0</span>)</span><br><span class="line">r.handlers[key] = handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *router)</span></span> getRoute(method <span class="type">string</span>, path <span class="type">string</span>) (*node, <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>) &#123;</span><br><span class="line">searchParts := parsePattern(path)</span><br><span class="line">params := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">root, ok := r.roots[method]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n := root.search(searchParts, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> n != <span class="literal">nil</span> &#123;</span><br><span class="line">parts := parsePattern(n.pattern)</span><br><span class="line"><span class="keyword">for</span> index, part := <span class="keyword">range</span> parts &#123;</span><br><span class="line"><span class="keyword">if</span> part[<span class="number">0</span>] == <span class="string">&#x27;:&#x27;</span> &#123;</span><br><span class="line">params[part[<span class="number">1</span>:]] = searchParts[index]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> part[<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; <span class="built_in">len</span>(part) &gt; <span class="number">1</span> &#123;</span><br><span class="line">params[part[<span class="number">1</span>:]] = strings.Join(searchParts[index:], <span class="string">&quot;/&quot;</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n, params</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *router)</span></span> getRoutes(method <span class="type">string</span>) []*node &#123;</span><br><span class="line">root, ok := r.roots[method]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">nodes := <span class="built_in">make</span>([]*node, <span class="number">0</span>)</span><br><span class="line">root.travel(&amp;nodes)</span><br><span class="line"><span class="keyword">return</span> nodes</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *router)</span></span> handle(c *Context) &#123;</span><br><span class="line">n, params := r.getRoute(c.Method, c.Path)</span><br><span class="line"><span class="keyword">if</span> n != <span class="literal">nil</span> &#123;</span><br><span class="line">c.Params = params</span><br><span class="line">key := c.Method + <span class="string">&quot;-&quot;</span> + n.pattern</span><br><span class="line">r.handlers[key](c)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.String(http.StatusNotFound, <span class="string">&quot;404 NOT FOUND: %s\n&quot;</span>, c.Path)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>parsePattern 函数的作用是解析路由路径，将路径按 &#x2F; 分隔成各个部分。比如 &#x2F;user&#x2F;:id 会被分解成 [“user”, “:id”]。<br>如果路径中出现了 *（通常用于匹配任意多的路径部分），解析会在遇到 * 时停止。比如 &#x2F;files&#x2F;*filepath 会解析成 [“files”, “*filepath”]。<br>parts 数组存储了路由路径的各个部分（如静态部分、动态部分、通配符部分）</p><h5 id="tire-go"><a href="#tire-go" class="headerlink" title="tire.go"></a>tire.go</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gee</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">pattern  <span class="type">string</span></span><br><span class="line">part     <span class="type">string</span></span><br><span class="line">children []*node</span><br><span class="line">isWild   <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;node&#123;pattern=%s, part=%s, isWild=%t&#125;&quot;</span>, n.pattern, n.part, n.isWild)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span></span> insert(pattern <span class="type">string</span>, parts []<span class="type">string</span>, height <span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(parts) == height &#123;</span><br><span class="line">n.pattern = pattern</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">part := parts[height]</span><br><span class="line">children := n.matchChildren(part)</span><br><span class="line"><span class="keyword">var</span> child *node</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(children) == <span class="number">0</span> &#123;</span><br><span class="line">child = &amp;node&#123;part: part, isWild: part[<span class="number">0</span>] == <span class="string">&#x27;:&#x27;</span> || part[<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span>&#125;</span><br><span class="line">n.children = <span class="built_in">append</span>(n.children, child)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">child = children[<span class="number">0</span>] <span class="comment">// 假设我们总是取第一个匹配的子节点</span></span><br><span class="line">&#125;</span><br><span class="line">child.insert(pattern, parts, height+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span></span> search(parts []<span class="type">string</span>, height <span class="type">int</span>) *node &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(parts) == height || strings.HasPrefix(n.part, <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> n.pattern == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">part := parts[height]</span><br><span class="line">children := n.matchChildren(part)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, child := <span class="keyword">range</span> children &#123;</span><br><span class="line">result := child.search(parts, height+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> result != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span></span> travel(list *([]*node)) &#123;</span><br><span class="line"><span class="keyword">if</span> n.pattern != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">*list = <span class="built_in">append</span>(*list, n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, child := <span class="keyword">range</span> n.children &#123;</span><br><span class="line">child.travel(list)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span></span> matchChild(part <span class="type">string</span>) *node &#123;</span><br><span class="line"><span class="keyword">for</span> _, child := <span class="keyword">range</span> n.children &#123;</span><br><span class="line"><span class="keyword">if</span> child.part == part || child.isWild &#123;</span><br><span class="line"><span class="keyword">return</span> child</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span></span> matchChildren(part <span class="type">string</span>) []*node &#123;</span><br><span class="line">nodes := <span class="built_in">make</span>([]*node, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> _, child := <span class="keyword">range</span> n.children &#123;</span><br><span class="line"><span class="keyword">if</span> child.part == part || child.isWild &#123;</span><br><span class="line">nodes = <span class="built_in">append</span>(nodes, child)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nodes</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先学习一下前缀树</p><h5 id="定义树结点结构体"><a href="#定义树结点结构体" class="headerlink" title="定义树结点结构体"></a>定义树结点结构体</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> trieNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    nexts [<span class="number">26</span>]*trieNode</span><br><span class="line">    PassCnt <span class="type">int</span> <span class="comment">//用来记录中途是否有途径某个节点的个数</span></span><br><span class="line">    end <span class="type">bool</span> <span class="comment">//匹配某个单词是否是结尾 比如seat的结尾是t</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>树</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Trie <span class="keyword">struct</span> &#123;</span><br><span class="line">    root *trieNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Newtrie</span> *<span class="title">Trie</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Trie&#123;</span><br><span class="line">    root: &amp;trieNode&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> Search(word <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">//查找目标节点，使根节点开始抵达目标节点沿路跟字符串恰好等于word</span></span><br><span class="line">    node := t.search(word)</span><br><span class="line">    <span class="keyword">return</span> node != <span class="literal">nil</span> &amp;&amp; node.end</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Tire-search-方法源码"><a href="#Tire-search-方法源码" class="headerlink" title="Tire.search 方法源码"></a>Tire.search 方法源码</h5><p>字符➖a<br>如果返回的单词是 前缀树中的别的单词的前缀判断</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span>search(target <span class="type">string</span>)*trieNode&#123;</span><br><span class="line"><span class="comment">//移动指针从根节点出发</span></span><br><span class="line">move :t.root</span><br><span class="line">/依次追历target中的每个字符</span><br><span class="line">for_, ch:<span class="keyword">range</span> target&#123;</span><br><span class="line"><span class="comment">//倘若nexts中不存在对应于这个字符的节点，说明该单词没插入过，返回ni1</span></span><br><span class="line"><span class="keyword">if</span> move.nexts[ch-<span class="string">&#x27;a&#x27;</span>]==<span class="literal">nil</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指针向着子节点移动</span></span><br><span class="line">movemove.nexts [ch-<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//来到末尾，说明已经完全匹配好单词，直接返回这个节点</span></span><br><span class="line"><span class="comment">//需要注意，找到目标节点不一定代表单词存在，因为该节点的end标识未必为true</span></span><br><span class="line"><span class="comment">//比如我们之前往trie中插入了apple这个单词，但是查找app这个单词时，预期的返回</span></span><br><span class="line"><span class="keyword">return</span> move</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="前缀匹配"><a href="#前缀匹配" class="headerlink" title="前缀匹配"></a>前缀匹配</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前缀树做前缀匹配很简单</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> StartWith(prefix(<span class="type">string</span>)) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.search(prefix) != <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="前缀统计"><a href="#前缀统计" class="headerlink" title="前缀统计"></a>前缀统计</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> PassCnt(prefix <span class="type">string</span>) <span class="type">int</span>&#123;</span><br><span class="line">    node := t.search(prefix)</span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>  </span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> node.PassCnt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="插入单词"><a href="#插入单词" class="headerlink" title="插入单词"></a>插入单词</h5><p>例子： 要插入apple 树中app可以复用<br>    则插入 l e</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> Insert(word <span class="type">string</span>) &#123;</span><br><span class="line"><span class="comment">//如果单词存在直接返回</span></span><br><span class="line">    <span class="keyword">if</span> t.Search(word)&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">        move := t.root</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _,ch := <span class="keyword">range</span> word &#123;</span><br><span class="line"><span class="comment">//如果不存在创建出来</span></span><br><span class="line">    <span class="keyword">if</span> move.nexts[ch-<span class="string">&#x27;a&#x27;</span>] == <span class="literal">nil</span> &#123;</span><br><span class="line">    move.nexts[ch-<span class="string">&#x27;a&#x27;</span>] = &amp;trieNode&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">    move.nexts[ch-<span class="string">&#x27;a&#x27;</span>].passCnt++</span><br><span class="line">    move = move.nexts[ch-<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"></span><br><span class="line">move.end =<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="删除流程"><a href="#删除流程" class="headerlink" title="删除流程"></a>删除流程</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> Erase(word <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !t.Search(word)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">  move := t.root</span><br><span class="line">    <span class="keyword">for</span> _, ch := <span class="keyword">range</span> word &#123;</span><br><span class="line">    move.nexts[ch-<span class="string">&#x27;a&#x27;</span>].passCnt --</span><br><span class="line"><span class="keyword">if</span> move.nexts[ch-<span class="string">&#x27;a&#x27;</span>].passCnt == <span class="number">0</span> &#123;</span><br><span class="line">    move.nexts[ch-<span class="string">&#x27;a&#x27;</span>] = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">    move = move.nexts[ch-<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    move.end = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>整段代码下来还是有点看不懂啊呜呜</p><p>11.25日<br>拖了几天<br>感谢tutu</p><h4 id="分组控制"><a href="#分组控制" class="headerlink" title="分组控制"></a>分组控制</h4><p>分组控制是Web框架的基础功能之一，路由的分组，往往某一组路由需要相似的处理</p><p>以&#x2F;post开头的路由匿名可访问。<br>以&#x2F;admin开头的路由需要鉴权。<br>以&#x2F;api开头的路由是 RESTful 接口，可以对接第三方平台，需要三方平台鉴权。</p><p>&#x2F;post是一个分组<br>&#x2F;post&#x2F;a和&#x2F;post&#x2F;b可以是该分组下的子分组<br>作用在&#x2F;post分组上的中间件(middleware)，也都会作用在子分组，子分组还可以应用自己特有的中间件。</p><p>中间件可以给框架提供无限的扩展能力<br>用在分组上的效果也更明显<br>&#x2F;admin的分组，可以应用鉴权中间件；&#x2F;分组应用日志中间件，<br>&#x2F;是默认的最顶层的分组，也就意味着给所有的路由，即整个框架增加了记录日志的能力。</p><p>一个 Group 对象需要具备哪些属性呢？首先是前缀(prefix)，<br>比如&#x2F;，或者&#x2F;api；要支持分组嵌套，那么需要知道当前分组的父亲(parent)是谁；<br>中间件是应用在分组上的，那还需要存储应用在该分组上的中间件(middlewares)。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r := gee.New()</span><br><span class="line">v1 := r.Group(<span class="string">&quot;/v1&quot;</span>)</span><br><span class="line">v1.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gee.Context)</span></span> &#123;</span><br><span class="line">c.HTML(http.StatusOK, <span class="string">&quot;&lt;h1&gt;Hello Gee&lt;/h1&gt;&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>好好看看仓库中的代码 梳理思路 感觉好有意思但是看不懂哈哈哈哈</p><p>11.26日 回看前三天的代码 增加一些自己的理解和修改 再继续向下学习！ </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;通过学习项目-7-days-golang搭建各种自己的框架了解一些网络工作原理和知识&quot;&gt;&lt;a href=&quot;#通过学习项目-7-days-golang搭建各种自己的框架了解一些网络工作原理和知识&quot; class=&quot;headerlink&quot; title=&quot;通过学习项目 7</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>计算机网络持续学习中~</title>
    <link href="https://whuichenggong.github.io/2024/11/14/computer_network/"/>
    <id>https://whuichenggong.github.io/2024/11/14/computer_network/</id>
    <published>2024-11-14T12:05:18.911Z</published>
    <updated>2024-12-18T09:06:52.759Z</updated>
    
    <content type="html"><![CDATA[<h2 id="记录一下自己在黑皮书中的学习记录下有用的部分"><a href="#记录一下自己在黑皮书中的学习记录下有用的部分" class="headerlink" title="记录一下自己在黑皮书中的学习记录下有用的部分"></a>记录一下自己在黑皮书中的学习记录下有用的部分</h2><hr><p>非常好的学习HTTP RESTFUL API 链接<br>链接1： <a href="https://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html">https://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html</a></p><p>链接2： <a href="https://www.ruanyifeng.com/blog/2016/08/http.html">https://www.ruanyifeng.com/blog/2016/08/http.html</a></p><h2 id="链接3：-https-florimond-dev-en-posts-2018-08-restful-api-design-13-best-practices-to-make-your-users-happy"><a href="#链接3：-https-florimond-dev-en-posts-2018-08-restful-api-design-13-best-practices-to-make-your-users-happy" class="headerlink" title="链接3： https://florimond.dev/en/posts/2018/08/restful-api-design-13-best-practices-to-make-your-users-happy"></a>链接3： <a href="https://florimond.dev/en/posts/2018/08/restful-api-design-13-best-practices-to-make-your-users-happy">https://florimond.dev/en/posts/2018/08/restful-api-design-13-best-practices-to-make-your-users-happy</a></h2><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="2-1应用层协议原理："><a href="#2-1应用层协议原理：" class="headerlink" title="2.1应用层协议原理："></a>2.1应用层协议原理：</h3><p>Web应用程序中两个互相通讯的不同程序：</p><ol><li>运行在用户主机上浏览器程序</li><li>运行在Web服务器主机上</li></ol><p>网络上的核心设备并不在应用层起作用， 这将应用软件限制在了端系统，这促进了大量网络应用程序的迅速研发与部署</p><h4 id="2-1-1网络应用程序体系结构"><a href="#2-1-1网络应用程序体系结构" class="headerlink" title="2.1.1网络应用程序体系结构"></a>2.1.1网络应用程序体系结构</h4><p>应用层的体系结构 明显 不同于网络的体系结构（网络的体系结构是固定的，提供了特定的服务集合）</p><p>应用层体系结构（大体两个）：</p><ol><li>客户-服务器体系结构</li><li>p2p体系结构</li></ol><h5 id="1-客户-服务器体系结构："><a href="#1-客户-服务器体系结构：" class="headerlink" title="1.客户-服务器体系结构："></a>1.客户-服务器体系结构：</h5><p>有一个总打开的主机被称为：服务器（它服务于许多其他称为客户的主机请求）</p><p>例子：</p><p>Web应用服务器：（Web服务器服务于浏览器（运行在客户机）的请求）</p><p>在这个体系结构中 客户之间并不直接通信 而是 客户通过向该服务器的ip地址发送分组 用来取得联系</p><p>著名的Web应用：</p><p>Web FTP Telent 电子邮箱</p><p>在这个体系中 如果只有一台服务器 在某些情况（大量的所有请i去）会导致服务器变得不堪重负，因此-配备大量主机的 <strong>数据中心</strong></p><p>流行的因特网服务：</p><p>搜索引擎（Google，bing，百度）等 应用了一个或多个数据中心（1个数据中心 可以有数十万台服务器）</p><h5 id="2-p2p体系结构"><a href="#2-p2p体系结构" class="headerlink" title="2. p2p体系结构"></a>2. p2p体系结构</h5><p>主机对之间使用直接通信（对等方），引人入胜的特性（自扩展性），</p><p>面临挑战： 高度非集中式，面临安全性，性能和可靠性等挑战</p><p>应用：</p><p>文件共享，对等方协助下载器（迅雷）因特网电话和视频会议 </p><p>有的应用具有两种的混合体系： 服务器被用来跟踪用户的ip地址 但 用户到用户的报文在用户到主机之间 直接发送</p><h4 id="2-1-2进程通信"><a href="#2-1-2进程通信" class="headerlink" title="2.1.2进程通信"></a>2.1.2进程通信</h4><p>运行在多个端系统上的程序如何互相通信，进行通信实际上是<strong>进程</strong>而不是程序<br><strong>进程</strong>可以被认为是运行在端系统的一个程序。 多个进程运行在相同的端系统时<strong>使用进程间通信机制互相通信（通信规则由  _端系统上的操作系统制定_）</strong></p><h2 id="关注的是-运行在不同端系统上的进程间的通信"><a href="#关注的是-运行在不同端系统上的进程间的通信" class="headerlink" title="关注的是 运行在不同端系统上的进程间的通信"></a>关注的是 运行在不同端系统上的进程间的通信</h2><p>在不同的端系统上的进程 通过 跨越进程通过网络互相发送<strong>报文</strong></p><p>发送进程 生成并 向网络中 发送报文 -》接收进程接收报文并通过回送报文响应</p><h5 id="1-客户和服务器进程"><a href="#1-客户和服务器进程" class="headerlink" title="1.客户和服务器进程"></a>1.客户和服务器进程</h5><p>网络应用程序由 成对的进程组成 进程之间 通过网路互相发送报文 </p><p>例子：</p><p>客户浏览器进程 与 Web服务器进程交换报文 在p2p中： 文件从一个对等方中的进程 传输到 另一个对等放进程 其中一个进程被表示为<strong>客户</strong> 另一个进程被标记为<strong>服务器</strong></p><h5 id="2-进程与计算机网络之间的接口（api）"><a href="#2-进程与计算机网络之间的接口（api）" class="headerlink" title="2.进程与计算机网络之间的接口（api）"></a>2.进程与计算机网络之间的接口（api）</h5><p>进程 通过一个称为<strong>套接字（socket）</strong> 的软件接口 向网络发送报文和从网络接收报文</p><p><strong>套接字</strong>： 是同一台主机被<strong>应用层与传输层之间</strong>的接口 套接字被称为 应用进程 和 网络之间的（api）</p><p>我们可以控制套接字在应用端的一切 但是 对运输层几乎没有控制权 仅限于：选择运输层协议 也能设定几个运输层协议（最大缓存，最大报文长度）</p><h5 id="3-进程寻址"><a href="#3-进程寻址" class="headerlink" title="3.进程寻址"></a>3.进程寻址</h5><p>主机由<strong>ip地址</strong>标识， ip地址： 是32比特的量它能够标识该主机 </p><p><strong>端口号</strong>： 众所周知的端口号列表： <a href="http://www.iana.org/">http://www.iana.org</a></p><p><img src="/study_photo/internet2.jpg" alt="image-20241107112953295"></p><h4 id="2-1-3-可供应用程序使用的运输服务"><a href="#2-1-3-可供应用程序使用的运输服务" class="headerlink" title="2.1.3 可供应用程序使用的运输服务"></a>2.1.3 可供应用程序使用的运输服务</h4><p>运输层协议负责从接收进程的套接字得到该报文 开发应用时还要选择根基情况 选择合适的协议 选择服务</p><p>服务： 可靠数据传输 吞吐量 定时 安全性</p><h5 id="1-可靠数据传输"><a href="#1-可靠数据传输" class="headerlink" title="1.可靠数据传输"></a>1.可靠数据传输</h5><p>因为 分组可能在计算机网络中丢失，</p><p>例子：</p><p>分组能够使路由器中的缓存溢出， 分组中的某些比特损坏后可能被丢弃 在某些特定情况下： 电子邮件，文件传输，远程主机访问<br>如果数据丢失可能会造成灾难性的损失，</p><p>因此 当运输层协议提供一种可靠传输， 发送进程只需要将数据传递到套接字中 就可以完全相信数据无差别的到达接收进程<br>但是也有一些东西可以容忍数据的丢失（不适用可靠数据传输时） 音频&#x2F;视频</p><h5 id="2-吞吐量"><a href="#2-吞吐量" class="headerlink" title="2.吞吐量"></a>2.吞吐量</h5><p>吞吐量就是发送进程能够向接收进程交付比特的速率 会话 将共享沿着网络路径的带宽 运输层协议能够确保可用吞吐量为至少r&#x2F;bit&#x2F;s当（应用程序请求r&#x2F;bit&#x2F;s）</p><p>示例：<br>电话需要固定的bit进行编码 如果不能提供这中吞吐量或者较小 造成放弃发送（因为接收一半可能是没用的）<br>弹性应用：可以根据 可用的宽带或多或少来利用可供使用的吞吐量<br>当然 吞吐量越高越好哈哈哈</p><h5 id="3-定时"><a href="#3-定时" class="headerlink" title="3.定时"></a>3.定时</h5><p>运输层协议也能提供定时保证 因为在特定情况下 电话，虚拟环境 多方游戏（对时间有严格的限制） 否则会造成停顿， 较长的时延<br>但 端到端的时延没有严格的约束</p><h5 id="4，安全性"><a href="#4，安全性" class="headerlink" title="4，安全性"></a>4，安全性</h5><p>运输协议为应用提供 一种或多种安全性服务 能加密发送进程传输的所有数据 防止数据以某种方式 在两个进程之间被观察</p><h4 id="2-1-4-因特网提供的运输服务"><a href="#2-1-4-因特网提供的运输服务" class="headerlink" title="2.1.4 因特网提供的运输服务"></a>2.1.4 因特网提供的运输服务</h4><p>因特网（TCp&#x2F;IP网络）为应用程序提供两个运输层协议（TCP&#x2F;UDP）</p><h5 id="1-TCP服务"><a href="#1-TCP服务" class="headerlink" title="1.TCP服务"></a>1.TCP服务</h5><p>特点： <strong>面向连接服务</strong>和<strong>可靠数据传输服务</strong></p><p><img src="/study_photo/internet.jpg" alt="image-20241107112953295"></p><p><strong>面向连接：</strong> 在应用层数据报文开始流动之前， TCP使 客户 和 服务器 之前相互交换 运输层控制信息（握手过程） 让它们提前做好准备<br>握手之后 <strong>TCP连接就建立了</strong>  连接时双工的： 双方可以连接上 同时进行报文的收发  当收发结束后 必须拆除连接</p><p><strong>可靠的数据传送服务：</strong> 通信进程依靠TCP 无差错的按照顺序交付所有的发送数据 当一方将字节流传入套接字时 依靠TCP将相同的<br>字节流交付给接收方的套接字 没有字节的丢失和冗余 </p><p>TCP具有拥塞控制机制  当发送方和接收方之间网络出现问题堵塞 TCP的机制可以抑制发送进程 也试图限制每个TCP连接 达到公平共享网络宽带目的</p><hr><p>原文链接： <a href="https://github.com/wolverinn/Waking-Up/blob/master/Computertree-way-handshake">https://github.com/wolverinn/Waking-Up/blob/master/Computertree-way-handshake</a></p><p>简单理解：</p><h6 id="三次握手（三报文握手）"><a href="#三次握手（三报文握手）" class="headerlink" title="三次握手（三报文握手）"></a>三次握手（三报文握手）</h6><p>第一次握手：Client将SYN置1，随机产生一个初始序列号seq发送给Server，进入SYN_SENT状态；<br>第二次握手：Server收到Client的SYN&#x3D;1之后，知道客户端请求建立连接，将自己的SYN置1，ACK置1，产生一个acknowledge number&#x3D;sequence number+1，并随机产生一个自己的初始序列号，发送给客户端；进入SYN_RCVD状态；<br>第三次握手：客户端检查acknowledge number是否为序列号+1，ACK是否为1，检查正确之后将自己的ACK置为1，产生一个acknowledge number&#x3D;服务器发的序列号+1，发送给服务器；进入ESTABLISHED状态；服务器检查ACK为1和acknowledge number为序列号+1之后，也进入ESTABLISHED状态；完成三次握手，连接建立。</p><p>目的： 建立 TCP连接</p><h6 id="两次握手呢？"><a href="#两次握手呢？" class="headerlink" title="两次握手呢？"></a>两次握手呢？</h6><p>只发送前两次报文 不会有 最后一次的客户端同步状态报文<br>这就会导致超时重传<br>把问题想象成发送报文就好理解了：<br>一段时间后，之前滞留在网络中的那个失效的TCP连接请求报文段到达了TCP服务器进程，TCP 服务器进程会误认为这是TCP客户进程又发起了一个新的TCP连接请求，于是给TCP客户进程发送TCP连接请求确认报文段并进入连接已建立状态。<br>该报文段到达TCP客户进程，由于TCP客户进程并没有发起新的TCP连接请求，并且处于关闭状态，因此不会理会该报文段。</p><p>不可以！</p><p>如果不是用三次握手 那么只要client发出确认报文段， server发出确认新的连接就建立了<br>因为第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了延误到连接释放以后的某个时间才到达<br>但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。</p><h6 id="四次握手？"><a href="#四次握手？" class="headerlink" title="四次握手？"></a>四次握手？</h6><p>可以。但是会降低传输的效率。</p><p>四次握手是指：第二次握手：Server只发送ACK和acknowledge number；而Server的SYN和初始序列号在第三次握手时发送；<br>原来协议中的第三次握手变为第四次握手。出于优化目的，四次握手中的二、三可以合并。</p><p>了解名词ACK acknowledge number SYN 初始序列号</p><p>参考链接： <a href="https://juejin.cn/post/7028003193502040072">https://juejin.cn/post/7028003193502040072</a></p><p><strong>确认标志位ACK：</strong> 取值为1时确认号字段才有效；取值为0时确认号字段无效。TCP规定，在连接建立后所有传送的TCP报文段都必须把ACK置1。</p><p>源端口：16bit 目的端口： 16bit<br>序号：32bit</p><p><strong>同步标志位SYN：</strong> 在TCP连接建立时用来同步序号。终止标志位FIN： 用来释放TCP连接。复位标志位RST： 用来复位TCP连接。</p><p><strong>推送标志位PSH：</strong> 接收方的TCP收到该标志位为1的报文段会尽快上交应用进程，而不必等到接收缓存都填满后再向上交付。</p><p>TCP建立需要解决的问题：</p><p>1、使TCP双方能够确知对方的存在 。</p><p>2、使TCP双方能够协商一些参数（ 最大窗口值是否使用窗口扩大选项和时间戳选项，以及服务质量等）。</p><p>3、使TCP双方能够对运输实体资源（例如缓存大小连接表中的项目等）进行分配。</p><p>TCP规定SYN被设置为1的报文段不能携带数据但要消耗掉一个序号。</p><p>TCP服务器进程收到TCP连接请求报文段后，如果同意建立连接，则向TCP客户进程发送TCP连接请求确认报文段，并进入同步已接收状态</p><p><strong>总结：</strong><br>如果没有第三次握手告诉服务器客户端能否收到服务器传输的数据的话，<br>服务器端的端口就会一直开着，等到客户端因超时重新发出请求时，服务器就会重新开启一个端口连接。长此以往， 这样的端口越来越多，就会造成服务器开销的浪费。</p><p>探测报文检测 确认客户端是否出现故障 然后关闭连接</p><h6 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h6><p>第一次挥手：Client将FIN置为1，发送一个序列号seq给Server；进入FIN_WAIT_1状态；<br>第二次挥手：Server收到FIN之后，发送一个ACK&#x3D;1，acknowledge number&#x3D;收到的序列号+1；进入CLOSE_WAIT状态。此时客户端已经没有要发送的数据了，但仍可以接受服务器发来的数据。<br>第三次挥手：Server将FIN置1，发送一个序列号给Client；进入LAST_ACK状态；<br>第四次挥手：Client收到服务器的FIN后，进入TIME_WAIT状态；接着将ACK置1，发送一个acknowledge number&#x3D;序列号+1给服务器；服务器收到后，确认acknowledge number后，变为CLOSED状态，不再向客户端发送数据。客户端等待2*MSL（报文段最长寿命）时间后，也进入CLOSED状态。完成四次挥手。</p><p>还有些不太理解学习一下这些名字之后再来理解</p><hr><h5 id="2-UDP服务"><a href="#2-UDP服务" class="headerlink" title="2.UDP服务"></a>2.UDP服务</h5><p>UDP是 轻量级运输协议仅提供最小服务 状态：无连接的，两个进程通信没有握手过程， 提供：不可靠传输协议：不保证报文到达接收进程<br>报文也可能是乱序到达  也没有拥塞控制机制</p><h5 id="因特网运输协议所不提供的服务"><a href="#因特网运输协议所不提供的服务" class="headerlink" title="因特网运输协议所不提供的服务"></a>因特网运输协议所不提供的服务</h5><p>TCP在应用层 用SSL加强提供安全服务 漏掉了 吞吐量，和定时保证</p><h4 id="2-1-5-应用层协议"><a href="#2-1-5-应用层协议" class="headerlink" title="2.1.5 应用层协议"></a>2.1.5 应用层协议</h4><p>定义了：</p><ol><li>交换的报文类型 如：请求报文，响应报文</li><li>报文类型语法 如：报文字段是如何描述的</li><li>字段的语义 就是信息含义</li><li>确定进程何时发送报文</li></ol><p>Web的应用层协议是HTTP： </p><p>因特网电子邮件应用：包括 电子邮件报文结构的标准 以及 定义报文如何在服务器之间以及如何在服务器与邮件客户程序之间传递的应用层协议</p><h3 id="2-2Web和HTTP"><a href="#2-2Web和HTTP" class="headerlink" title="2.2Web和HTTP"></a>2.2Web和HTTP</h3><h4 id="2-2-1HTTP概况"><a href="#2-2-1HTTP概况" class="headerlink" title="2.2.1HTTP概况"></a>2.2.1HTTP概况</h4><p>Web层应用层协议是超文本传输协议 HTTP由两个程序实现（客户程序）（服务器程序） 通过交换HTTP报文进行会话</p><p><strong>Web界面</strong><br>它是由文档组成的也就是（对象）： 一个对象是一个文件 例如： HTML文件 JPEG图形</p><p>例如： 如果一个HTML文件＋五个图片 也就是 Web页面有6个对象</p><p>URL地址两部分组成：服务器主机名 和 对象 URL：<a href="http://www/someSchool.edu/someDepartment/picture.gif">http://www/someSchool.edu/someDepartment/picture.gif</a> 到edu是主机名<br>后面是路径名</p><p>Web服务器 实现了HTTP服务器端 用于存储Web对象 流行的Web服务器：Apache等</p><p><img src="/study_photo/internet3.jpg" alt="image-20241107112953295"></p><h4 id="2-2-2非持续连接和持续链接"><a href="#2-2-2非持续连接和持续链接" class="headerlink" title="2.2.2非持续连接和持续链接"></a>2.2.2非持续连接和持续链接</h4><p>两个问题：</p><p>每个请求&#x2F;响应是 经 一个单独的TCP连接： 这称为（非持续连接）<br>还是 经相同的TCP连接发送： 这称为（持续链接）</p><h5 id="1-采用非持续连接的HTTP"><a href="#1-采用非持续连接的HTTP" class="headerlink" title="1.采用非持续连接的HTTP"></a>1.采用非持续连接的HTTP</h5><p>过程：<br><img src="/study_photo/internet4.jpg" alt="image-20241107112953295"></p><p>每个TCP只传输一个请求报文和一个响应报文</p><p>串行TCP：</p><p>并行TCP：</p><p>浏览器可以设置并行数 如果设为1 那么就会变化串行连接 并行连接可以减少响应时间</p><p><strong>往返时间（RTT）</strong></p><p>RTT包括： 分组传播时延 分组在（中间路由器）（交换机）的排队时延 分组时延</p><p><strong>三次握手过程</strong></p><ol><li>客户向服务器发送小TCP报文</li><li>服务器用小TCP报文做出确认和响应</li><li>客户向服务器返回确认</li></ol><p>这三次握手中 前两部分花费 一个RTT<br>握手后向该TCP连接发送HTTP请求报文 一旦请求报文到达服务器 服务器就在TCP连接上发送HTML文件<br>该HTTP的请求和响应用了一个HTTP  服务器传输HTML花费了时间<br>一共为 2RTT+传输时间</p><h5 id="2-采用持续连接的HTTP"><a href="#2-采用持续连接的HTTP" class="headerlink" title="2.采用持续连接的HTTP"></a>2.采用持续连接的HTTP</h5><p> 非持续链接的缺点： 每次连接都需要： 分配TCP缓存区和保持TCP变量 这给Web服务器造成了很大的负担<br> 每一个对象都会造成上面的时延时间</p><p>HTTP1.1 在服务器响应后 保持TCP打开 用单个TCP进行传送 在一定的时间间隔没有被使用HTTP服务器再关闭连接<br>HTTP2  它允许再相同连接中多个请求和回答错误 增加了连接中优化HTTP报文请i去和回答机制</p><h4 id="2-2-3-HTTP请求报文格式"><a href="#2-2-3-HTTP请求报文格式" class="headerlink" title="2.2.3 HTTP请求报文格式"></a>2.2.3 HTTP请求报文格式</h4><h5 id="1-HTTP-请求报文"><a href="#1-HTTP-请求报文" class="headerlink" title="1.HTTP 请求报文"></a>1.HTTP 请求报文</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /somedir/page.html HTTP/1.1</span><br><span class="line">HOST: www.someschool.edu</span><br><span class="line">Connection: close</span><br><span class="line">User-agent: Mozilla/5.0</span><br><span class="line">Accept-language: fr</span><br></pre></td></tr></table></figure><p>第一行：请求行<br>后继行：首部行</p><p><img src="/study_photo2/internet.jpg" alt="internet.jpg"></p><h5 id="2-HTTP-响应报文"><a href="#2-HTTP-响应报文" class="headerlink" title="2.HTTP 响应报文"></a>2.HTTP 响应报文</h5><p>真实的HTTP响应报文：<br>用Telnet 登录到喜欢的Web服务器上 请求报文请求放在该服务器上的某些对象</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">telnet gaia.cs.umass.edu 80</span><br><span class="line"></span><br><span class="line">Trying 128.119.245.12...</span><br><span class="line">Connected to gaia.cs.umass.edu.</span><br><span class="line">Escape character is &#x27;^]&#x27;.</span><br><span class="line">GET /kurose_ross/interactive/index.php HTTP/1.1</span><br><span class="line">Host: gaia.cs.umass.edu</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Wed, 27 Nov 2024 13:06:02 GMT</span><br><span class="line">Server: Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips PHP/7.4.33 mod_perl/2.0.11 Perl/v5.16.3</span><br><span class="line">X-Powered-By: PHP/7.4.33</span><br><span class="line">Set-Cookie: DevMode=0</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br></pre></td></tr></table></figure><p>这里的<br>GET &#x2F;kurose_ross&#x2F;interactive&#x2F;index.php HTTP&#x2F;1.1<br>Host: gaia.cs.umass.edu<br>格式很重要 回车必不可少</p><p>只想看HTTP协议的报文行 用HEAD代替GET<br>上述简短的两行代码 打开了主机 .edu的80端口的TCP连接 发送了一个HTTP请求报文</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">telnet gaia.cs.umass.edu 80</span><br><span class="line">Trying 128.119.245.12...</span><br><span class="line">Connected to gaia.cs.umass.edu.</span><br><span class="line">Escape character is &#x27;^]&#x27;.</span><br><span class="line">HEAD /kurose_ross/interactive/index.php HTTP/1.1</span><br><span class="line">Host: gaia.cs.umass.edu</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Wed, 27 Nov 2024 13:11:35 GMT</span><br><span class="line">Server: Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips PHP/7.4.33 mod_perl/2.0.11 Perl/v5.16.3</span><br><span class="line">X-Powered-By: PHP/7.4.33</span><br><span class="line">Set-Cookie: DevMode=0</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>GT方法就是安全且幂等的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，<br>且每次的结果都是相同的。所以，可以对GET请求的数据做缓存，这个缓存可以做到浏览器本身上<br>(彻底避免浏览器发请求)，也可以做到代理上（如gix)，而且在浏览器中GET请求可以保存为书<br>签。</p><p>POST因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据<br>就会创建多个资源，所以不是幂等的。所以，浏览器一般不会缓存POST请求，也不能把POST请求保<br>存为书签。</p><h5 id="减少HTTP请求次数"><a href="#减少HTTP请求次数" class="headerlink" title="减少HTTP请求次数"></a>减少HTTP请求次数</h5><p>1.减少重定向请求次数</p><p>重定向请求越多，那么客户端就要多次发起 HTTP 请求 每一次的 HTTP 请求都得经过网络，这无疑会越降低网络性能</p><p>重定向的工作交由代理服务器完成，就能减少 HTTP 请求次数了<br>代理服务器知晓了重定向规则后，可以进一步减少消息传递次数</p><hr><h4 id="2-2-4用户与服务器的交互-cookie"><a href="#2-2-4用户与服务器的交互-cookie" class="headerlink" title="2.2.4用户与服务器的交互 cookie"></a>2.2.4用户与服务器的交互 cookie</h4><p>HTTP服务器是无状态的 不需要验证。但是站点是希望能够标识用户， 因为服务器可能需要限制用户的访问，这就需要把内容和用户关联到一起<br>HTTP使用了 <strong>cookie</strong> </p><p><strong>cookie的四个组件</strong></p><ol><li>HTTP响应报文的一个cookie首部行</li><li>HTTP请求报文的一个cookie首部行</li><li>用户端系统保留一个cookie文件浏览器进行管理</li><li>位于WEB站点的后端数据库</li></ol><p><img src="/study_photo2/internet2.jpg" alt="internet.jpg"></p><p>这样当Susan再次访问一个站点的时候 浏览器放入首部行  就不用再输入一些信息了<br>实行了”点击购物“</p><h4 id="2-2-5-Web缓存"><a href="#2-2-5-Web缓存" class="headerlink" title="2.2.5 Web缓存"></a>2.2.5 Web缓存</h4><p><img src="/study_photo2/internet3.jpg" alt="internet.jpg"></p><p>还需要 深入理解缓存器带来的好处</p><p><img src="/study_photo2/internet4.jpg" alt="internet.jpg"></p><p>HTTP中的 强制缓存和协商缓存</p><h5 id="强制缓存定义："><a href="#强制缓存定义：" class="headerlink" title="强制缓存定义："></a>强制缓存定义：</h5><p>强制缓存是指客户端直接使用本地缓存的数据，而不会向服务器发送请求验证数据的有效性。</p><p>工作方式：</p><p>HTTP 头部中：<br>使用 Cache-Control 指定缓存策略（例如 max-age）。<br>或使用 Expires（HTTP&#x2F;1.0，已逐步被 Cache-Control 替代）指定缓存失效时间。<br>如果缓存未过期，浏览器会直接从本地缓存读取数据，而不会与服务器通信。<br>特点：</p><p>节约资源：不需要请求服务器。<br>时效性：受 max-age 或 Expires 的约束，可能存在缓存失效时间的误差。</p><h5 id="协商缓存-Conditional-Cache"><a href="#协商缓存-Conditional-Cache" class="headerlink" title="协商缓存 (Conditional Cache)"></a>协商缓存 (Conditional Cache)</h5><p>定义： 协商缓存是指客户端向服务器发送请求，验证本地缓存是否有效。如果有效，服务器返回一个状态码（如 304 Not Modified），客户端可以继续使用本地缓存的数据；否则，服务器返回最新的数据。</p><p>工作方式：</p><p>HTTP 头部中：<br>请求头：使用 If-Modified-Since 或 If-None-Match。<br>响应头：服务器返回 Last-Modified（表示资源最后修改时间）或 ETag（资源的唯一标识符）。<br>客户端会将缓存中记录的 ETag 或 Last-Modified 发送到服务器进行验证：<br>如果验证通过（服务器认为缓存未修改），返回 304。<br>如果验证失败（资源已更新），返回新的资源数据（200 OK）。<br>特点：</p><p>相对准确：确保缓存数据的有效性。<br>需要通信：每次都需要向服务器发送请求进行验证。</p><p>缓存命中率<br>内容分发网络（CDN）：多个共享CDN 专用CDN</p><h4 id="条件GET方法"><a href="#条件GET方法" class="headerlink" title="条件GET方法"></a>条件GET方法</h4><p>问题： 存放在混村其中的对象副本是旧的，或者再保存到服务器中的对象再缓存到客户上之后 就被修改了<br><strong>HTTP协议机制</strong>： 允许缓存器证实它的对象是最新的 也就是（<strong>条件GET</strong>）</p><p><code>If-modified-since: Wed, 9 Sep 2015 09:23:24</code></p><p>”If-Modified-Since“首部行 这个请求报文就是条件GET请求报文</p><p>缓存器在存储对象的同时也存储了最后的修改日期 缓存器通过一个条件GET执行最新查询<br>这条语句告诉服务器 仅当指定日期后该对象被修改过 才发送对象 </p><p>如果没有修改过 则相应的时候没有body 因为再次返回一样的body会浪费宽带</p><hr><p>插入</p><h4 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h4><p>在实践中，客户端指定数据流的优先级通常是在使用 HTTP&#x2F;2 时实现的。HTTP&#x2F;2 引入了<strong>流优先级（Stream Priority）</strong>机制，允许客户端为每个流指定一个优先级值，这个值会影响服务器在资源争用时对请求的处理顺序。</p><p>流优先级机制<br>优先级参数：每个 HTTP&#x2F;2 流都可以有一个权重值（weight），范围是 1 到 256，数字越大，优先级越高。<br>依赖关系：每个流还可以声明依赖于另一个流（dependency）。如果一个流依赖于另一个流，服务器会优先完成被依赖的流。<br>服务器根据这些参数决定如何分配带宽和计算资源。</p><p>实现流优先级的例子<br>客户端的实现（使用 cURL）<br>我们可以用支持 HTTP&#x2F;2 的工具，如 curl，来演示流优先级的使用。</p><p>发送两个并发请求（模拟流）</p><p>curl –http2 -o output1.html <a href="https://example.com/slow-response">https://example.com/slow-response</a> &amp;<br>curl –http2 -o output2.html <a href="https://example.com/fast-response">https://example.com/fast-response</a> &amp;<br>wait<br>默认情况下，这两个流的优先级相同，服务器会尽力均匀分配资源来处理它们。</p><p>设置优先级 使用 –http2-prioritize 选项来设置优先级。例如：</p><p>curl –http2 –http2-prioritize-weight 256 -o fast.html <a href="https://example.com/fast-response">https://example.com/fast-response</a> &amp;<br>curl –http2 –http2-prioritize-weight 1 -o slow.html <a href="https://example.com/slow-response">https://example.com/slow-response</a> &amp;<br>wait<br>这里：</p><p>fast-response 的优先级为 256（最高）。<br>slow-response 的优先级为 1（最低）。<br>服务器会优先响应 fast-response 流。</p><hr><h4 id="2-3-因特网中的电子邮件"><a href="#2-3-因特网中的电子邮件" class="headerlink" title="2.3 因特网中的电子邮件"></a>2.3 因特网中的电子邮件</h4><p>3个主体组成部分 <strong>用户代理</strong> <strong>邮件服务器</strong> <strong>简单邮件传输协议</strong></p><p><img src="/study_photo2/internet5.jpg" alt="internet.jpg"></p><p>SMTP： 应用层协议 使用TCP可靠数据传输 每台邮件服务器上：既运行SMTP的客户端也运行SMTP的服务器端<br>因为：</p><p>SMTP发送邮件的时候 表现为： 客户端</p><p>SMTP接收邮件的时候 表现为： 服务器端</p><p>使用7bit ASCII标识</p><h5 id="2-3-1-SMTP"><a href="#2-3-1-SMTP" class="headerlink" title="2.3.1 SMTP"></a>2.3.1 SMTP</h5><p><img src="/study_photo2/internet6.jpg" alt="internet.jpg"></p><hr><p>12.18 日</p><p>套接字编程： </p><ol><li><p>UDP套接字：</p></li><li><p>TCP套接字</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;记录一下自己在黑皮书中的学习记录下有用的部分&quot;&gt;&lt;a href=&quot;#记录一下自己在黑皮书中的学习记录下有用的部分&quot; class=&quot;headerlink&quot; title=&quot;记录一下自己在黑皮书中的学习记录下有用的部分&quot;&gt;&lt;/a&gt;记录一下自己在黑皮书中的学习记录下有用的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>一些找工作或实习的渠道</title>
    <link href="https://whuichenggong.github.io/2024/11/13/job/"/>
    <id>https://whuichenggong.github.io/2024/11/13/job/</id>
    <published>2024-11-13T12:16:59.041Z</published>
    <updated>2024-11-13T12:18:18.023Z</updated>
    
    <content type="html"><![CDATA[<p>Boss直聘</p><p>offershow</p><p>github上查找</p><p>linkedin</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Boss直聘&lt;/p&gt;
&lt;p&gt;offershow&lt;/p&gt;
&lt;p&gt;github上查找&lt;/p&gt;
&lt;p&gt;linkedin&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>青训营直播总结</title>
    <link href="https://whuichenggong.github.io/2024/11/13/Dance_live/"/>
    <id>https://whuichenggong.github.io/2024/11/13/Dance_live/</id>
    <published>2024-11-13T12:05:27.817Z</published>
    <updated>2024-11-13T12:15:17.824Z</updated>
    
    <content type="html"><![CDATA[<p>听了前端文杰老哥分享</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>计算机基础很重要必须要持续学习： 例如：计算机原理，操作系统等，在工作中有些人问题你需要定位到它的问题出在了那里，这个问题的对应着是哪个方面的问题<br>学习ai提示词，提高学习效率，练好基本功，多写代码，多用大模型 前期多学习如何编码而不是太多关于工程化的问题</p><h3 id="建议："><a href="#建议：" class="headerlink" title="建议："></a>建议：</h3><p>解决问题:事实是，就业环境中大概率没人把你当学生般保护着，别人没有义务要解决你的问题(不合理，不科学)，请务必提升自己解决问题的能力。</p><p>学习:工作中，很难找到手把手教你做事的团队，多数时候都是靠自学，没有课本，没有老师，没有标准答案，全凭自己，所以务必提升独立学习能力;</p><p>二极化:世界不是非黑即白，代码也是，职业也是，接受、包容多样性吧，多从不同角度思考问题，从不同渠道了解解决问题的方法，学会更体系化地思考;</p><p>LLM:非常值得花很多时间学习，用好这个工具，提升你个人效率;但它不是魔法，不要幻想着学会了就能怎么这么样; (目前只停留在问题的复制粘贴 效率很低)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;听了前端文杰老哥分享&lt;/p&gt;
&lt;h3 id=&quot;总结：&quot;&gt;&lt;a href=&quot;#总结：&quot; class=&quot;headerlink&quot; title=&quot;总结：&quot;&gt;&lt;/a&gt;总结：&lt;/h3&gt;&lt;p&gt;计算机基础很重要必须要持续学习： 例如：计算机原理，操作系统等，在工作中有些人问题你需要定位到它</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Go语言进阶</title>
    <link href="https://whuichenggong.github.io/2024/11/11/Go_Advanced/"/>
    <id>https://whuichenggong.github.io/2024/11/11/Go_Advanced/</id>
    <published>2024-11-11T11:47:00.753Z</published>
    <updated>2024-11-27T12:09:15.291Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字节青训营学习"><a href="#字节青训营学习" class="headerlink" title="字节青训营学习"></a>字节青训营学习</h1><h3 id="一-入门篇学习"><a href="#一-入门篇学习" class="headerlink" title="一.入门篇学习"></a>一.入门篇学习</h3><p>实战篇：</p><h4 id="1-猜数字游戏"><a href="#1-猜数字游戏" class="headerlink" title="1.猜数字游戏"></a>1.猜数字游戏</h4><p>运用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">”math/rand“</span><br><span class="line"></span><br><span class="line">maxNum := 100</span><br><span class="line">调用 Intn（maxNum）</span><br><span class="line">//注意这并不能使每一次都用都产生不同的值</span><br><span class="line"></span><br><span class="line">需要加 时间戳 才能每次产生不同的值</span><br><span class="line">应该是：</span><br><span class="line">maxNum := 100</span><br><span class="line">ran.Seed(time.Now().UnixNano())</span><br><span class="line">然后调用</span><br><span class="line"> ran.Intn（maxNum）</span><br><span class="line"> </span><br><span class="line"> 用 &quot;bufio&quot;</span><br><span class="line"> 这个特别的包以后可以用到</span><br><span class="line"> </span><br><span class="line"> 这里读取一行输入用的是</span><br><span class="line"> reader := bufo.NewReader(os.Stdin)//调用这个可以更加灵活</span><br><span class="line"> input， err := reader.ReadString(&#x27;\n&#x27;)</span><br><span class="line"> if err != nil&#123;...&#125;</span><br><span class="line"> </span><br><span class="line"> input = strings.TrimSuffix(intput,&quot;\n&quot;)//去掉换行符</span><br><span class="line"> </span><br><span class="line"> guess,err := strconv.Atoi(input)//转换成数字</span><br><span class="line"> </span><br><span class="line"> 菜值逻辑 </span><br></pre></td></tr></table></figure><h4 id="2-在线词典介绍"><a href="#2-在线词典介绍" class="headerlink" title="2.在线词典介绍"></a>2.在线词典介绍</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">go run simpledict/v4/main.go hello</span><br><span class="line">//意思是查询hello这个功能</span><br><span class="line">//会输出以下内容</span><br><span class="line">hello UK:[&#x27;he&#x27;lau]US:[ha&#x27;lo]</span><br><span class="line">int.喂；哈罗</span><br><span class="line">n.引人注意的呼声</span><br><span class="line">V.向人呼（喂</span><br><span class="line"></span><br><span class="line">调用第三方api</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>生成请求</p><p><a href="https://curlconverter.com/">https://curlconverter.com/</a></p><p>写入curl 自动生成代码</p><p>示例：</p><p><img src="/study_photo/39.png" alt="image-20241104201754858"></p><p>会输出一些列bilibili的东西</p><p>json序列化</p><p><img src="/study_photo/40.png" alt="image-20241104202957339"></p><p>衍生出以下</p><p><img src="/study_photo/41.png" alt="image-20241104203014855"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结构体</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">request ：= DicRequest&#123;Trans Type：&quot;en2zh&quot;,Source:&quot;good&quot;&#125;</span><br><span class="line">buf, err := json.Marshal(request)//序列化request 变成byte数组</span><br><span class="line">if~~~</span><br><span class="line">var data = bytes.NewReader(buf) //因为buf返回的是bytes数组所以我们应该 bytes.NewReader</span><br></pre></td></tr></table></figure><p>解析response 进行反序列化</p><p>json转golang 结构体</p><p><a href="https://oktools.net/json2go">https://oktools.net/json2go</a></p><p>反序列化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">err = json.Unmarshal(bodytext,&amp;dictResponse)//传入结构体</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;%#v&quot;,dicResponse)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Go进阶"><a href="#Go进阶" class="headerlink" title="Go进阶"></a>Go进阶</h3><h4 id="1-并发编程"><a href="#1-并发编程" class="headerlink" title="1.并发编程"></a>1.并发编程</h4><p>并发：多线程在一个核运行 时间碎片</p><p>并行： 多核</p><p><img src="/study_photo/42.png" alt="image-20241109132249854"></p><p>并行是并发的手段</p><h4 id="2-协程"><a href="#2-协程" class="headerlink" title="2.协程"></a>2.协程</h4><p><img src="/study_photo/43.png" alt="image-20241109132406297"></p><p>协程：轻量级线程 线程本身重量级 Goroutine：可以实现上万个携程</p><p>例子:协程</p><p><img src="/study_photo/44.png" alt="image-20241109132554426"></p><p>go关键字开启协程</p><p>通过通信来共享内存</p><p><img src="/study_photo/45.png" alt="image-20241109132746410"></p><p>channel</p><p>make创建channel</p><p><img src="/study_photo/46.png" alt="image-20241109132925436"></p><p>有缓冲：</p><p>无缓冲：进行通信时（两个goroutine同步）也称同步通道</p><p>示例：</p><p><img src="/study_photo/47.png" alt="image-20241109133236164"></p><p>先make创建通道 把数字放入第一个通道里</p><p>然后b把src做平方运算</p><p>并发安全 Lock</p><p><img src="/study_photo/48.png" alt="image-20241109134052647"></p><p>Lock（）临界区</p><p><img src="/study_photo/49.png" alt="image-20241109134621688"></p><h4 id="3-依赖管理"><a href="#3-依赖管理" class="headerlink" title="3.依赖管理"></a>3.依赖管理</h4><p>1.GOPATH</p><p>bin pkg src（项目源码）</p><p>无法实现package 的多版本控制</p><p>2.vendor存放依赖副本 也有弊端</p><p>3.go module 管理 解决了问题</p><p><img src="/study_photo/51.png" alt="image-20241109135629389"></p><p>indirect关键词</p><p><img src="/study_photo/52.png" alt="image-20241109140344112"></p><p>b（选择最低兼容版本）</p><h4 id="4-依赖分发"><a href="#4-依赖分发" class="headerlink" title="4.依赖分发"></a>4.依赖分发</h4><p>Github         SVN               …</p><p>​          Developer</p><p>无法保证构建稳定性</p><p>无法保证依赖可用性</p><p>增加第三方压力</p><p>Go proxy （）缓存内容版本 从proxy拉取依赖 减少第三方压力</p><p>Proxy1 -》 proxy2 -》 Direct  依次进行</p><h4 id="5-工具-go-get"><a href="#5-工具-go-get" class="headerlink" title="5.工具 go get"></a>5.工具 go get</h4><p>go mod       <strong>init tidy download</strong></p><h4 id="6-测试"><a href="#6-测试" class="headerlink" title="6.测试"></a>6.测试</h4><p>事故：</p><p><img src="/study_photo/59.png" alt="image-20241111092419264"></p><p>测试的重要性：避免事故的最后一道屏障</p><p>单元测试 mock测试   回归测试 集成测试</p><h5 id="1-单元测试"><a href="#1-单元测试" class="headerlink" title="1.单元测试"></a>1.单元测试</h5><p><img src="/study_photo/60.png" alt="image-20241111092633595"></p><p>保证代码整体覆盖率</p><p>提升效率</p><h5 id="2-规则"><a href="#2-规则" class="headerlink" title="2. 规则"></a>2. 规则</h5><p><img src="/study_photo/61.png" alt="image-20241111092852792"></p><h5 id="3例子："><a href="#3例子：" class="headerlink" title="3例子："></a>3例子：</h5><p><img src="/study_photo/62.png" alt="image-20241111093035601"></p><p>go test 【flags】 【packages】</p><h5 id="4-assert"><a href="#4-assert" class="headerlink" title="4.assert"></a>4.assert</h5><p><img src="/study_photo/63.png" alt="image-20241111093202556"></p><h5 id="5-覆盖率"><a href="#5-覆盖率" class="headerlink" title="5.覆盖率"></a>5.覆盖率</h5><p><img src="/study_photo/64.png" alt="image-20241111093237237"></p><p><img src="/study_photo/65.png" alt="image-20241111093252039"></p><p>提升覆盖率</p><p><img src="/study_photo/66.png" alt="image-20241111093436343"></p><p>对各个分支测试 使函数代码都经过完备的测试 提升覆盖率 减少事故</p><p><img src="/study_photo/67.png" alt="image-20241111093526971"></p><h5 id="6-依赖"><a href="#6-依赖" class="headerlink" title="6.依赖"></a>6.依赖</h5><p><img src="/study_photo/68.png" alt="image-20241111093723869"></p><h5 id="7-文件处理"><a href="#7-文件处理" class="headerlink" title="7.文件处理"></a>7.文件处理</h5><p><img src="/study_photo/69.png" alt="image-20241111093855592"></p><p>一旦文件被别人篡改 在特定场景下就无法运行！</p><h5 id="8-Mock"><a href="#8-Mock" class="headerlink" title="8.Mock"></a>8.Mock</h5><p><img src="/study_photo/70.png" alt="image-20241111094015817"></p><p>replacement 打桩函数</p><p><img src="/study_photo/71.png" alt="image-20241111094459861"></p><p>通过mock 不对 文件有强依&#x2F;study_photo&#x2F;70.png</p><p><img src="/study_photo/72.png" alt="image-20241111094758462"></p><p>优化：</p><p><img src="/study_photo/73.png" alt="image-20241111094944759"></p><p>fastrand</p><h4 id="10-项目实践"><a href="#10-项目实践" class="headerlink" title="10.项目实践"></a>10.项目实践</h4><p><img src="/study_photo/75.png" alt="image-20241111095222107"></p><p><img src="/study_photo/76.png" alt="image-20241111095416063"></p><p><img src="/study_photo/77.png" alt="image-20241111095526585"></p><p><img src="/study_photo/78.png" alt="image-20241111100016448"></p><p>话题id -》 获取所有post</p><p><img src="/study_photo/79.png" alt="image-20241111100134049"></p><p><img src="/study_photo/80.png" alt="image-20241111100208797"></p><p>初始化话题内存索引</p><p><img src="/study_photo/81.png" alt="image-20241111100306256"></p><hr><p>逻辑层：</p><p><img src="/study_photo/82.png" alt="image-20241111100415573"></p><p><img src="/study_photo/83.png" alt="image-20241111121526603"></p><p><img src="/study_photo/83.png" alt="image-20241111121719613"></p><p>并行处理</p><p><img src="/study_photo/84.png" alt="image-20241111121901723"></p><p><img src="/study_photo/85.png" alt="image-20241111122045428"></p><h3 id="三-高质量编程与实践"><a href="#三-高质量编程与实践" class="headerlink" title="三.高质量编程与实践"></a>三.高质量编程与实践</h3><p>如何编写更简洁和跟清晰的代码</p><p>熟悉GO程序性能分析工具</p><p>常用Go语言程序优化手段</p><p>了解工程性能优化的原则和流程</p><p>:性能调优    性能分析工具     性能调优案例</p><p>算法效率</p><h4 id="1-高质量编程"><a href="#1-高质量编程" class="headerlink" title="1.高质量编程"></a>1.高质量编程</h4><p>正确可靠 简洁清晰</p><p>各种边界条件是否考虑完备</p><p>异常情况处理 稳定性保证</p><p>易读易维护</p><p>团队合作保证容易读 维护 使其增加和调整更加快速 更加清晰</p><p>主要是给人看 让人可以看懂  对已有的功能改善 优化 容易添加功能</p><h4 id="2-编码规范"><a href="#2-编码规范" class="headerlink" title="2.编码规范"></a>2.编码规范</h4><p>代码格式</p><p>注释</p><p>命名规范</p><p>控制流程</p><p>错误和异常处理</p><p><img src="/study_photo/87.png" alt="image-20241112171014037"></p><p>不需要注释实现接口的方法 这种注释可以删除</p><p><img src="/study_photo/88.png" alt="image-20241112171126665"></p><h5 id="1-gofmt"><a href="#1-gofmt" class="headerlink" title="1.gofmt"></a>1.gofmt</h5><p>推荐使用gofmt 自动格式化代码为官方统一风格</p><h5 id="2-注释"><a href="#2-注释" class="headerlink" title="2.注释"></a>2.注释</h5><p>注释应该解释代码的作用</p><p>注释应该解释代码如何做的</p><p>注释应该解释代码实现的原因</p><p>注释应该解释代码什么情况会错</p><p><img src="/study_photo/89.png" alt="image-20241112171511567"></p><p>下面的根本不需要注释没有什么必要 函数名字已经说明了</p><p><img src="/study_photo/90.png" alt="image-20241112171655993"></p><p>最后一条语句是很难理解的  如果没有注释   一定要会看英文呵呵</p><p><img src="/study_photo/91.png" alt="image-20241112171909248"></p><p><img src="/study_photo/92.png" alt="image-20241112172349471"></p><p><img src="/study_photo/93.png" alt="image-20241112172623038"></p><p><img src="/study_photo/94.png" alt="image-20241112172638016"></p><p>此时的t就减少了很多东西</p><p><img src="/study_photo/95.png" alt="image-20241112172953450"></p><p>例如http中调用 Server 是 http.Server</p><p>若用 ServerHTTP   http.ServerHTTP这样感觉就变得冗余了没有必要</p><p><img src="/study_photo/96.png" alt="image-20241112173231246"></p><p>避免if else嵌套 包含同样语句可以去掉 重复语句</p><p><img src="/study_photo/97.png" alt="image-20241112173423686"></p><p>这样看起来比较复杂</p><p><img src="/study_photo/98.png" alt="image-20241112173532576"></p><p>调整后：</p><p><img src="/study_photo/99.png" alt="image-20241112173605956"></p><p>控制流程 ： 线性原理 尽量走直线 避免复杂的嵌套分支</p><h5 id="3-错误和异常处理"><a href="#3-错误和异常处理" class="headerlink" title="3.错误和异常处理"></a>3.错误和异常处理</h5><p><img src="/study_photo/100.png" alt="image-20241112173840011"></p><p><img src="/study_photo/101.png" alt="image-20241112173902743"></p><p><img src="/study_photo/102.png" alt="image-20241112174134842"></p><h4 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h4><h5 id="原则："><a href="#原则：" class="headerlink" title="原则："></a>原则：</h5><p>1.依靠数据而不是猜测<br>2.定位到最大瓶颈（也就是影响最大的部分），<br>3.不要过早优化<br>4.不要过度优化</p><h5 id="性能调优工具：pprof"><a href="#性能调优工具：pprof" class="headerlink" title="性能调优工具：pprof"></a>性能调优工具：pprof</h5><h5 id="pprof：可视化和性能分析数据的工具"><a href="#pprof：可视化和性能分析数据的工具" class="headerlink" title="pprof：可视化和性能分析数据的工具"></a>pprof：可视化和性能分析数据的工具</h5><p><img src="/study_photo/103.png" alt="image-20241112174134842"></p><h6 id="pprof实战项目："><a href="#pprof实战项目：" class="headerlink" title="pprof实战项目："></a>pprof实战项目：</h6><p>下载项目 并且运行：</p><p>GIthub：<a href="https://github.com/wolfogre/go-pprof-practice">https://github.com/wolfogre/go-pprof-practice</a></p><p><code>go run main.go</code></p><p>等待编译 等待一段时间</p><p>输入：<a href="http://localhost:6060/debug/pprof/">http://localhost:6060/debug/pprof/</a> 在浏览器中</p><p><img src="/study_photo/104.png" alt="image-20241112174134842"></p><p>此时的cpu 内存状态：</p><p><img src="/study_photo/111.png" alt="image-20241112174134842"></p><p><img src="/study_photo/112.png" alt="image-20241112174134842"></p><p><img src="/study_photo/113.png" alt="image-20241112174134842"></p><p>以下输出：<br><img src="/study_photo/114.png" alt="image-20241112174134842"></p><p><img src="/study_photo/115.png" alt="image-20241112174134842"></p><p>思考： 什么情况下 Flat &#x3D;&#x3D; Cum Flat&#x3D;&#x3D;0</p><p>分别为1. 函数中没有调用其他函数 都是本函数使用的时间<br>2. 函数中只有其他函数调用并且时间占用也很少可以忽略不计</p><p>在查看到tiger中有一部分占用了很大的时间 把相关的代码注释后</p><p>内存方面并没有解决什么</p><p>Heap：堆内存分析：</p><p>在终端使用这个指令<br><code>go tool pprof -http=:8080 &quot;http://localhost:6060/debug/pprof/heap&quot;</code><br>…没有下载工具先放一下</p><p>先截屏</p><p>锁：<br><code>go tool pprof -http=:8080 &quot;http://localhost:6060/debug/pprof/mutex&quot;</code></p><h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><h5 id="GO语言优化"><a href="#GO语言优化" class="headerlink" title="GO语言优化"></a>GO语言优化</h5><p>内存管理优化</p><p>编译器优化</p><p>什么是性能优化 ，为什么要做性能优化？</p><p>：提升软件系统处理能力，减少不必要的消耗</p><p>：用户体验，让用户刷抖音不卡顿</p><p>：资源高效利用，成低成本，提高效率</p><p>业务代码：处理用户请i去</p><p>SDK：go的SDK</p><p>基础库：</p><p>这两部分提供抽象逻辑（数据结构 网络库 io库）</p><p>语言运行时： gc 调度器（go语言）</p><p>OS</p><p>性能分析工具：pprof</p><p>依靠数据而非猜测</p><p>优化最大瓶颈</p><p>Go的SDK</p><p>接口 命令 APIs</p><p>测试 来 驱动开发</p><p>隔离： 通过选择控制是否开启优化</p><p>可观测：</p><p>静态分析：</p><h5 id="自动内存管理"><a href="#自动内存管理" class="headerlink" title="自动内存管理"></a>自动内存管理</h5><p>基于追踪的垃圾回收</p><p>GC</p><p>动态内存 malloc</p><p>自动内存回收： 避免手动内存管理 专注于实现业务逻辑</p><p>保证内存使用的正确性和安全性</p><p>为新对象分配空间</p><p>偷懒了：实在不知道怎么记了 留着以后学的更深入一些再看吧</p><p><img src="/study_photo/149.png" alt="image-20241112174134842"></p><p><img src="/study_photo/150.png" alt="image-20241112174134842"></p><p><img src="/study_photo/151.png" alt="image-20241112174134842"></p><p><img src="/study_photo/152.png" alt="image-20241112174134842"></p><p><img src="/study_photo/153.png" alt="image-20241112174134842"></p><p><img src="/study_photo/154.png" alt="image-20241112174134842"></p><p><img src="/study_photo/155.png" alt="image-20241112174134842"></p><p><img src="/study_photo/156.png" alt="image-20241112174134842"></p><p><img src="/study_photo/157.png" alt="image-20241112174134842"></p><p><img src="/study_photo/158.png" alt="image-20241112174134842"></p><p><img src="/study_photo/159.png" alt="image-20241112174134842"></p><h4 id="四-数据库"><a href="#四-数据库" class="headerlink" title="四.数据库"></a>四.数据库</h4><h5 id="数据库database-sql"><a href="#数据库database-sql" class="headerlink" title="数据库database&#x2F;sql"></a>数据库database&#x2F;sql</h5><p><img src="/study_photo/160.png" alt="image-20241112174134842"></p><p><img src="/study_photo/161.png" alt="image-20241112174134842"></p><p>GORM ： 业务需求驱动开发</p><p><img src="/study_photo/162.png" alt="image-20241112174134842"></p><p><strong>基本用法</strong></p><p><img src="/study_photo/163.png" alt="image-20241112174134842"></p><p><img src="/study_photo/164.png" alt="image-20241112174134842"></p><p><strong>规定</strong></p><p><img src="/study_photo/165.png" alt="image-20241112174134842"></p><p>数据库约束</p><p>Select实现级联删除</p><h4 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h4><h5 id="1-经典排序算法"><a href="#1-经典排序算法" class="headerlink" title="1.经典排序算法"></a>1.经典排序算法</h5><p>为什么要用数据结构和算法：</p><p><img src="/study_photo/img_7.png" alt="image-20241112173840011"></p><p>最快的排序算法：<br>Go ： introsort </p><p>1.19的默认排序算法：如何设计的 生产环境和课本上的排序算法有什么区别</p><h6 id="1-插入排序：（洗牌）"><a href="#1-插入排序：（洗牌）" class="headerlink" title="1.插入排序：（洗牌）"></a>1.插入排序：（洗牌）</h6><p><img src="/study_photo/img_8.png" alt="image-20241112173840011"></p><p>时间复杂度：最好O（n）有序 平均O（n^2） 最坏 （n^2）</p><p>缺点：太慢 优点：最好</p><h6 id="2。快速排序："><a href="#2。快速排序：" class="headerlink" title="2。快速排序："></a>2。快速排序：</h6><p><img src="/study_photo/img_9.png" alt="image-20241112173840011"></p><p>时间复杂度；最好 O（n<em>logn） 平均O（n</em>logn）最坏O（n^2）</p><p>缺点 最坏太慢 优点 平均的挺好</p><h5 id="3-堆排序"><a href="#3-堆排序" class="headerlink" title="3.堆排序"></a>3.堆排序</h5><p><img src="/study_photo/img_10.png" alt="image-20241112173840011"></p><p><img src="/study_photo/img_11.png" alt="image-20241112173840011"></p><h4 id="网络与部署"><a href="#网络与部署" class="headerlink" title="网络与部署"></a>网络与部署</h4><p>《负载均衡 高并发网关原理与实践》</p><p>协议基础</p><p>协议分析（自学）</p><p>熟悉tcp&#x2F;ip 熟悉计算机网络</p><p>抖音视频 加载出来 会有什么交互（网络是如何交互的）（为什么刷抖音又快又稳）（计算机网络要解决什么问题 发现什么问题）</p><p>应用层：  域名解析（DNS） 图片下载 视频下载（HTTP）评论API&#x2F;HTTP</p><p>网络接入 网络传输</p><p>手机要先访问抖音服务器</p><p><img src="/study_photo/116.png" alt="image-20241116152733233"></p><p>终端（pc pad） 通过 4g &#x2F;wifi 通过有线网络 接入 四大运营商网络 -》 接通抖音的机房（服务器） 还用通过光缆（海底） 接通 美国网络</p><h5 id="网络接入-（路由）"><a href="#网络接入-（路由）" class="headerlink" title="网络接入 （路由）"></a>网络接入 （路由）</h5><p>交换机&#x2F;逻辑交换机&#x2F;网络虚拟化</p><p>路由一定对称吗？</p><p>路由是工作在哪一层协议？</p><p>路由协议（ip层） 本身不是ip层 动态路由协议（传输层协议bgp）（基于tcp udp）可能 不是很简单</p><p>路由改的是ip地址吗？</p><p>不是改ip地址 而是mac地址 路由是为了找到目标ip</p><p>怎么找下一跳（网络中间节点）的MAC 通过 ARP协议 跨网段 不能发送ARP</p><p>同网段可以发送ARP 否则需要一级一级的发送  免费ARP：（）新加入机器（向其中发送免费ARP ： 防止ip冲突 在同一局域网里有两个同一个ip ）</p><p>ARP：本质是查找下一跳MAC 而不是目标请求地址</p><p>ARP 代理： 中间设备抢先应答 （）</p><p><img src="/study_photo/117.png" alt="image-20241116154311845"></p><p><img src="/study_photo/118.png" alt="image-20241116154131510"></p><p>IP协议</p><p>唯一标识</p><p>为什么Mac（2层）（以太网） 地址不能代替ip协议 ： IP协议把MAC地址问题 解决了</p><p>ipv4不够用 怎么解决：如果不支持ipv6 ， 用NAT（原理 内部用户 通过NAT）</p><p><img src="/study_photo/119.png" alt="image-20241116155224812"></p><p>问题2 ： （NAT ip＋端口）一起改变 解决第二个问题</p><h4 id="网络打通视频怎么下载"><a href="#网络打通视频怎么下载" class="headerlink" title="网络打通视频怎么下载"></a>网络打通视频怎么下载</h4><p><img src="/study_photo/120.png" alt="image-20241116155401344"></p><p><img src="/study_photo/121.png" alt="image-20241116155543012"></p><p>也就是服务的封装与拆解</p><p>如何把域名映射到ip （DNS基于UDP协议（端口＋校验））</p><p><img src="/study_photo/122.png" alt="image-20241116155905523"></p><p>避免分片</p><p>丢包丢了UDP也不知道</p><h4 id="TCP连接-三次握手"><a href="#TCP连接-三次握手" class="headerlink" title="TCP连接 三次握手"></a>TCP连接 三次握手</h4><p>TCP连接状态</p><p>如果拔了网线，连接会断吗（没有什么关系）</p><p>keep-alive ：保活机制（不会一定断开在一定场景下）</p><h4 id="TCP传输"><a href="#TCP传输" class="headerlink" title="TCP传输"></a>TCP传输</h4><p><img src="/study_photo/123.png" alt="image-20241116160324196"></p><p>很复杂的协议</p><p>Timewait？（） 状态复杂</p><p>TCP丢包</p><p>滑动窗口</p><p>流量控制</p><h4 id="网络传输-HTTP-HTTP1-1"><a href="#网络传输-HTTP-HTTP1-1" class="headerlink" title="网络传输 HTTP&#x2F;HTTP1.1"></a>网络传输 HTTP&#x2F;HTTP1.1</h4><p><img src="/study_photo/124.png" alt="image-20241116161839691"></p><p>HTTPS 解密 出来仍然是HTTP</p><p>防止中间者偷听一些东西  加密之后中间人听不懂</p><p>SSL&#x2F;TLS握手 非对称加密 对称加密</p><p><img src="/study_photo/125.png" alt="image-20241116162211539"></p><h5 id="网络架构"><a href="#网络架构" class="headerlink" title="网络架构"></a>网络架构</h5><p>网络提速</p><p>HTTP 2.0 （多路复用） 并行下载 并行访问</p><p>一次性加载了多个图片 （并行请求 一次性发送了）</p><p><img src="/study_photo/126.png" alt="image-20241117194455726"></p><p>多路复用：</p><p><img src="/study_photo/127.png" alt="image-20241117194604452"></p><p>TCP （丢包 其他包等待（对头阻塞））</p><p><img src="/study_photo/128.png" alt="image-20241117194853572"></p><p><strong>协议优化：</strong></p><p>TCP本身协议不可插拔</p><p>UDP（基于UDP扩展）</p><p>kernel （windows mac 安卓 ios ）是否都要去实现呢？</p><p>Google实现在了用户态（方便）</p><p>RTT</p><p>QUIC（实现了UDP的扩展）(弱网优势) （解决了队头堵塞）（优化了HTTp2.0的多路复用）</p><p><strong>路径优化</strong></p><p><img src="/study_photo/129.png" alt="image-20241117195324763"></p><p>服务器集合（数据中心）</p><p>POP接入（核心机房） 边缘机房（靠近用户（上海电信 上海移动……））</p><p><strong>同运营商访问</strong> （访问客户端ip  电信 解析到 电信）</p><p>电信 访问 电信</p><p>移动 访问 移动</p><p>若要使两者跨网访问（丢包率较高）</p><p>路径优化（CDN） 网络提速-静态资源 （边缘机房（缓存）直接从缓存中取出资源 如果找不到 -》 核心机房）</p><p>动态API （播放 &#x2F; 评论接口）（因为信息不一样）</p><p><img src="/study_photo/130.png" alt="image-20241117195852655"></p><p>DSA（路径优化算法） 直连最快</p><p>机房延迟探测 （做成表（通过算法 找到最优路径））</p><h5 id="网络提速的优化之路"><a href="#网络提速的优化之路" class="headerlink" title="网络提速的优化之路"></a>网络提速的优化之路</h5><p>几天就挂了怎么办？？</p><p>抖音稳定性如何调高？</p><p><img src="/study_photo/131.png" alt="image-20241117200255063"></p><p><img src="/study_photo/132.png" alt="image-20241117200401223"></p><p>专线： 内部字节机房-》没有走外部internet（如果走internet 如果从北京 访问 上海 可能会造成中间去到江苏再回到上海这样会很慢 并且丢包等）-》自己拉线连接两个机房（通过交换机等）（这样速度更快）</p><p>b -》 c  外网：机房内部专线以外的网络通过internet连接 （如果专线挂了）需要走外网容灾 微服务可能跨机房</p><p><img src="/study_photo/133.png" alt="image-20241117200824142"></p><p>全局容灾系统 ：  A机房不可用了 （自动容灾） 探测机房b的容量可以承载 a机房的容量</p><p>自动降级&#x2F;容灾</p><p>云到端 SDK告诉端，不要访问，崩了的A机房   云控   什么场景云控控制不到（Web服务器 字节搜索&#x2F;百度搜索 ）</p><p>故障明确</p><p>沟通： 明确是什么业务 什么接口故障</p><p>故障体现在哪？ 其他目标是否访问正常（业务A有故障 接口A有问题 其他的是否有问题？）</p><p>是否是修改导致的异常？（如果是就回退）</p><p>如果你上传导致的错误（找是谁 ）</p><p>先止损 再 排查（debug）</p><p>如何止损</p><p>分段排查</p><p><img src="/study_photo/134.png" alt="image-20241117202312571"></p><h5 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h5><p><img src="/study_photo/135.png" alt="image-20241117202359378"></p><p>最后一个是抓包工具</p><p>误判断 摘除了 好的服务器</p><p>线上debug（p0级别事故）</p><p><img src="/study_photo/136.png" alt="image-20241117202838541"></p><p>抓包：</p><p>快速发包（路由对称）实际路由并不是对称的（找下一跳） 故障预防真的很重要</p><h5 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h5><p><img src="/study_photo/137.png" alt="image-20241117203250586"></p><p><img src="/study_photo/138.png" alt="image-20241117203354461"></p><h4 id="企业级"><a href="#企业级" class="headerlink" title="企业级"></a>企业级</h4><p>输入网页到内容加载出来 中间都经历了什么 （TCP握手 SSL 域名解析）</p><p>浏览器抓包</p><p>看第一条请求了什么</p><p><img src="/study_photo/139.png" alt="image-20241118125748346"></p><p>网络卡 还是服务器满 还是什么？</p><p>企业接入：</p><p>域名系统 自建DNS服务器 HTTPS 接入全站加速 四层负载均衡 七层负载均衡</p><p>example公司  Host -》 ip映射</p><p>问题： 流量和负载 名称冲突 时效性（）</p><h5 id="使用域名系统"><a href="#使用域名系统" class="headerlink" title="使用域名系统"></a>使用域名系统</h5><p>使用域名系统 替换hosts</p><p><img src="/study_photo/140.png" alt="image-20241118130222229"></p><p>域名购买  购买二级域名 example.com  域名备案防止从事非法运动</p><p>建设外部网站：</p><p><img src="/study_photo/141.png" alt="image-20241118130420184"></p><p>自建DNS：</p><p>取代云厂商</p><p><img src="/study_photo/142.png" alt="image-20241118130700240"></p><p>先访问 本地DNS服务器 -》 根 -》 顶级 -》权威-》本地缓存</p><h5 id="DNS查询过程"><a href="#DNS查询过程" class="headerlink" title="DNS查询过程"></a>DNS查询过程</h5><p><img src="/study_photo/143.png" alt="image-20241118130854468"></p><h5 id="权威DNS系统架构"><a href="#权威DNS系统架构" class="headerlink" title="权威DNS系统架构"></a>权威DNS系统架构</h5><p><img src="/study_photo/144.png" alt="image-20241118131553232"></p><h5 id="接入HTTPS协议"><a href="#接入HTTPS协议" class="headerlink" title="接入HTTPS协议"></a>接入HTTPS协议</h5><p>HTTP明文传输 被抓去后 信息很容易被暴露出来</p><p>加密算法：</p><p>对称加密： 一份密钥</p><p>非对称加密 ： 公钥和私钥 （公钥加密私钥解密 或者  对调）（锁头和钥匙）</p><p>SSL 通信过程：</p><p><img src="/study_photo/145.png" alt="image-20241118174903171"></p><p>证书链：</p><p>公钥是不是可信的 会不会被劫持？</p><p>数字签名</p><p>外网访问站点一定是一帆风顺的吗：</p><p>1.源站（网站） 容量第 可承载的并发请求数低 容易打跨</p><p>2.报文经过的网络设备越多 出问题概率越大 丢包 劫持</p><p>3.自主选择网络链路长 时延高</p><p>整体看来：就是响应慢 卡顿</p><p>优化：</p><p>增加后端机器扩容 静态内容</p><p>全站加速：</p><p>静态加速：CDN</p><p>cpu访问 （缓存）</p><p>动态加速：</p><p><img src="/study_photo/146.png" alt="image-20241118175913629"></p><p>DCDN原理 ：</p><p>RTT： 用户到核心</p><p>用户到边缘</p><p>边缘到汇聚</p><p>汇聚到核心</p><h5 id="全站加速"><a href="#全站加速" class="headerlink" title="全站加速"></a>全站加速</h5><p><img src="/study_photo/147.png" alt="image-20241118180340066"></p><p><img src="/study_photo/148.png" alt="image-20241118180356658"></p><h4 id="消息队列-kafka"><a href="#消息队列-kafka" class="headerlink" title="消息队列 kafka"></a>消息队列 kafka</h4><p>用户行为： 搜索 点赞 评论 收藏</p><p>使用场景： 搜索服务， 直播服务 订单服务 支付服务</p><p>如何使用Kafka： 创建集群 新增topic 编写生产者逻辑 编写消费之逻辑</p><p><img src="/study_photo/196.png" alt="image-20241125172137241"></p><p><img src="/study_photo/197.png" alt="image-20241125172850441"></p><p>Kafka架构：</p><p>Zookeeper</p><p>Producer 批量发送</p><pre><code>      数据压缩</code></pre><p>Broker 数据存储 消息文件结构</p><p>磁盘结构</p><p>​操作系统：</p><p><img src="/study_photo/198.png" alt="image-20241125174036284"></p><p>顺序写： 提高写入效率</p><p><img src="/study_photo/199.png" alt="image-20241125174650570"></p><p>Broker 偏移量索引文件</p><p>二分查找</p><p><img src="/study_photo/200.png" alt="image-20241125174726467"></p><p>Broker 时间戳索引文件</p><p>传统数据拷贝：</p><p>操作系统层面： 数据的内存拷贝（开销很大）</p><p><img src="/study_photo/201.png" alt="image-20241125175012153"></p><p>Broker零拷贝</p><p><img src="/study_photo/202.png" alt="image-20241125175137912"></p><p>Consumer-消息接收端</p><p><img src="/study_photo/203.png" alt="image-20241125175549378"></p><p>通过手动分配 哪一个Consumer消费哪一个Partition 完全由业务决定</p><p>缺点</p><p>不能自动容灾</p><p>优点：</p><p>快</p><p>自动分配 High-level</p><p><img src="/study_photo/204.png" alt="image-20241125180033073"></p><p><img src="/study_photo/205.png" alt="image-20241125180233648"></p><h4 id="存储与数据库"><a href="#存储与数据库" class="headerlink" title="存储与数据库"></a>存储与数据库</h4><p>数据的持久化</p><p>1.校验数据的合法行</p><p>（名字是否存在） （修改内存 用高效的数据结构组织数据）（写入存储介质 以寿命 性能友好写入硬件）（）</p><p><img src="/study_photo/206.png" alt="image-20241126175430987"></p><p>什么是存储系统？</p><p>一个提供了 读写 控制类接口 能够安全有效的 把 数据持久化的软件 称为 存储系统</p><p>user Medium Memory Network(把原有的单机 升级到分布式系统) 还可能与这些有关</p><p>特点：</p><p>性能敏感 容易受硬件影响  代码既简单又复杂（考虑到多种异常情况）</p><p>存储器层级结构：</p><p>Persistent Memory</p><p>数据怎么从应用到存储介质</p><p><img src="/study_photo/207.png" alt="image-20241126180440273"></p><p>数据拷贝 消耗cpu 如果cpu全部用来拷贝 软件性能就会降低（减少拷贝的使用） Disk（）</p><p>RAID技术： 单机存储怎么做到 高性能&#x2F;高性价比&#x2F;高可靠性</p><p>背景： 大容量磁盘价格》 多块小容量磁盘</p><p>单块磁盘的写入性能 《 多块磁盘的并发写入性能</p><p>RAID0</p><p>多块磁盘的简单组合</p><p>数据条带化存储 调高磁盘带宽</p><p>没有额外的容错设计</p><p>RAID1</p><p>一块磁盘对应一块额外镜像盘</p><p>真是空间利用率50%</p><p>容错能力强</p><p>上面是两个极端</p><p>RAID 0 + 1</p><p>RAID 0 和 RAID 1</p><h5 id="数据库和存储系统不一样吗？"><a href="#数据库和存储系统不一样吗？" class="headerlink" title="数据库和存储系统不一样吗？"></a>数据库和存储系统不一样吗？</h5><p>关系型数据库（是存储系统）</p><p>非关系型数据库</p><p>关系是什么： 关系模型（EFCodd）&#x3D; 集合 反映了事务间的关系</p><p>关系代数 &#x3D; 运算的抽象查询语句</p><p>SQL &#x3D; 一种DSL （方便人类阅读的 关系代数表达式）</p><p>关系型数据库：结构化数据友好 支持事务（ACID）支持复杂的查询语言（sql 全集 子集）</p><p>非关系型数据库（也是存储系统）： 半结构化数据友好 可能支持事务（ACID） 可能支持复杂查询语言</p><p>数据库 vs 经典存储 - 结构化数据管理</p><p><img src="/study_photo/208.png" alt="image-20241126181756913"></p><h5 id="事务能力："><a href="#事务能力：" class="headerlink" title="事务能力："></a>事务能力：</h5><p>要么全做 要么全不做</p><p>数据状态是一致的</p><p>可以隔离多个并发事务 避免影响</p><p>事务一旦提交成功 数据保持持久性</p><h5 id="复杂查询能力："><a href="#复杂查询能力：" class="headerlink" title="复杂查询能力："></a>复杂查询能力：</h5><p>复杂查询： 请查询出以xiao开头 密码提示问题小于10个字的人 并按照性别分组统计人数</p><p><img src="/study_photo/209.png" alt="image-20241126182318775"></p><p>左边灵活简介 右边复杂</p><h4 id="支流产品剖析"><a href="#支流产品剖析" class="headerlink" title="支流产品剖析"></a>支流产品剖析</h4><h5 id="单机存储系统"><a href="#单机存储系统" class="headerlink" title="单机存储系统"></a>单机存储系统</h5><p>单个计算机节点上的存储软件系统 一般不涉及网络交互</p><p>key-value存储 本地文件系统</p><p>本地文件系统</p><p>一切皆文件：</p><p>文件系统管理单元： 文件</p><p>文件系统接口： 文件系统繁多 Ext2 遵循VFS统一抽象接口</p><p>linux 文件系统的两大数据结构 ：Index Node   Directory Entry</p><ol><li>innode 记录文件元数据 如id 大小 权限 磁盘位置</li><li>innode 是一个文件的唯一标识  会被存储到磁盘上</li><li>innode总数在格式化文件系统时就固定了</li></ol><p>​1：1</p><p>1.Directory Entry</p><p>记录文件名 innode指针 层级关系</p><p>dentry时内存结构 与innode 关系时N：1</p><p>key-value存储</p><p><img src="/study_photo/210.png" alt="image-20241126183518576"></p><p>put(k,v) get(k)</p><p>LSM-Tree 某种程度上牺牲读性能 追求写入性能（）</p><p>拳头产品： RocksDB</p><p>分布式存储：</p><p>在单机存储基础上实现了分布式协议，实际大量网络交互</p><p>分布式文件系统  分布式对象存储系统</p><p>HDFS ：</p><p>核心：</p><p>支持海量数据存储（使用普通硬件堆叠）</p><p>高容错性</p><p>弱POSIX语义</p><p>使用普通x86服务器-极高性价比高</p><p>DataNode</p><p>Ceph- （分布式存储）开源分布式存储系统里的【万金油】 里面的算法很好</p><p>一切皆对象；</p><p>数据写入采用主备复制模型</p><p>数据分布模型采用CRUSH算法</p><p>单机数据库</p><p>单个计算机节点上的数据库系统</p><p>事务在单机内执行 通过网络交互实现分布式事务</p><p>关系数据库</p><p>商业产品Oracle</p><p>开源产品 MySQL PostgreSQL</p><p><img src="/study_photo2/1.png" alt="image-20241127101722363"></p><p><img src="/study_photo2/2.png" alt="image-20241127101919309"></p><p>Page  <em>Redo Log</em>  临时文件</p><p>内存 与 磁盘之间的交互</p><p><img src="/study_photo2/3.png" alt="image-20241127102206620"></p><p>非关系型数据库 没有准则 交互方式各不相同</p><p>schema相对灵活</p><p>SQL查询语言的统治地位很重视</p><p><img src="/study_photo2/4.png" alt="image-20241127102716222"></p><p>模糊搜索</p><p><img src="/study_photo2/5.png" alt="image-20241127102924660"></p><p>Query： match 编程语言 好 难度  模糊匹配到小明的帖子 ES天然能够做 模糊搜索 还能自动算出关联程度 传统关系型无法做到这一点</p><p>分布式数据库（引入分布式架构）：</p><p>容量 弹性 性价比 解决单机时代遇到的问题</p><p>解决容量问题：</p><p><img src="/study_photo2/6.png" alt="image-20241127103344147"></p><p>存储池 动态扩缩容</p><p>弹性问题：</p><p><img src="/study_photo2/7.png" alt="image-20241127103713521"></p><p>随着业务的变化而变化 1t如何搬到200g？</p><p>池化！</p><p>性价比问题</p><p><img src="/study_photo2/8.png" alt="image-20241127103908948"></p><p>硬件disk不需要怎么准备 什么不够用Storge Pool 分布式存储池来解决这个问题</p><p>磁盘池化 内存池化（降低成本）</p><p>单写vs多写     从磁盘弹性到内存弹性    分布式事务优化</p><h5 id="新技术演进"><a href="#新技术演进" class="headerlink" title="新技术演进"></a>新技术演进</h5><p>软件架构变更（依赖于操作系统内核） AI增强（智能存储格式转换） 新硬件革命（存储介质变更 计算单元变更 网络硬件变更）</p><p><img src="/study_photo2/9.png" alt="image-20241127104445468"></p><p>cpu中断 使性能降低 与之替换的是用轮询替换</p><p><img src="/study_photo2/10.png" alt="image-20241127104706603"></p><p>数据存储格式的转换 左边是二维表由 多个行与列 行存 列存 （优势 劣势）</p><p>ai决策-》行列混存（动态性强）</p><p><img src="/study_photo2/11.png" alt="image-20241127104909837"></p><p><img src="/study_photo2/12.png" alt="image-20241127105517074"></p><p>硬件反推软件变革</p><h5 id="课后作业-1"><a href="#课后作业-1" class="headerlink" title="课后作业"></a>课后作业</h5><p><img src="/study_photo2/13.png" alt="image-20241127105647523"></p><p>材料引用</p><p><img src="/study_photo2/14.png" alt="image-20241127105742332"></p><h4 id="深入理解RDBMS（关系型数据库）"><a href="#深入理解RDBMS（关系型数据库）" class="headerlink" title="深入理解RDBMS（关系型数据库）"></a>深入理解RDBMS（关系型数据库）</h4><p>存储系统:</p><p>块存储 文件存储 对象存储 key-value存储</p><p>数据库系统：</p><p>大型关系数据库 非关系型数据库</p><p>抖音红包雨</p><p>从抖音账号扣除1个亿</p><p><img src="/study_photo2/15.png" alt="image-20241127110101367"></p><p>事务ACID</p><p><img src="/study_photo2/16.png" alt="image-20241127110324168"></p><p>红包雨与ACID</p><p><img src="/study_photo2/17.png" alt="image-20241127110453611"></p><p>事务要同时成功与同时失败</p><p>账户的钱不能为复数</p><p><img src="/study_photo2/18.png" alt="image-20241127110554045"></p><p>操作一定要是合法的</p><p>隔离性问题 ： 两个操作同时进行 有相互影响的关系</p><p><img src="/study_photo2/19.png" alt="image-20241127110756892"></p><p>刚开始抢了一个亿（成功） 但是服务器挂了</p><p><img src="/study_photo2/20.png" alt="image-20241127111019483"></p><p><strong>高并发</strong></p><p>10亿人 同时抢红包 一定 数据要有处理高并发的能力 每秒处理事务的请求</p><p><strong>高可靠</strong></p><p>在关键时间和结点上 保证后台服务可靠</p><p>从 纸 到 磁盘文件</p><p>第一个数据库 网状数据库（W.Bachman）</p><p>​             Collage</p><p>English   computer  Maths</p><p>多对多</p><p>没有交叉</p><p>结点 网络结构 父节点可以有多个子节点</p><p>层次模型（IBM）</p><p>用树形结构描述实体 与 网状结构相似 但是并不交叉树状</p><p>每个子节点只有一个父节点</p><p>（1对多）</p><p>关系模型（IBM）（EFCodd博士）</p><p><img src="/study_photo2/21.png" alt="image-20241127113215926"></p><h5 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h5><p>一条SQL的一生 ：</p><p>解析SQL（语法解析器） 语法树AST  优化器 Plan Executor（执行器） 写入数据 写入日志</p><p><img src="/study_photo2/22.png" alt="image-20241127150742531"></p><p>分析</p><p><img src="/study_photo2/23.png" alt="image-20241127151110898"></p><p>为什么还要优化器？（Optimizer）  类比于 （高德地图路线优化） 快 慢 红绿灯</p><p>基于规则的优化</p><p>条件简化……</p><p>Scan优化</p><p><img src="/study_photo2/24.png" alt="image-20241127151708954"></p><p>基于代价优化：</p><p>时间是代价 最少时间到目的地</p><p>io cpu NET MEM也是代价</p><p>火山模型：</p><p><img src="/study_photo2/25.png" alt="image-20241127152543557"></p><p>向量化：</p><p>每次返回是一批数据 而不是一行数据</p><p>优点：</p><p>函数调用次数降低为1&#x2F;N</p><p>CPU cache命中率更高</p><p>可以利用CPU提供SIMD机制 一次加法（可以操作多个数据）</p><p>编译执行：</p><h5 id="存储引擎-InnoDB"><a href="#存储引擎-InnoDB" class="headerlink" title="存储引擎-InnoDB"></a>存储引擎-InnoDB</h5><p>内存态（做一点内存缓存）</p><p><img src="/study_photo2/26.png" alt="image-20241127153304028"></p><p>存储引擎-Buffer Pool</p><p>instance0</p><p>instance1</p><p>HashMap管理</p><p>LRU 算法</p><p>保留最近最常使用的保存在内存 其他的 淘汰</p><p>内存放不下？ 放磁盘  从磁盘访问数据</p><p><img src="/study_photo2/27.png" alt="image-20241127153706131"></p><p>存储引擎-Page</p><p>B+Tree索引 B树的扩展（二分查找树）</p><p><img src="/study_photo2/28.png" alt="image-20241127154133896"></p><h5 id="事务引擎："><a href="#事务引擎：" class="headerlink" title="事务引擎："></a>事务引擎：</h5><p>原子性   与   Undo Log</p><p>同步失败或成功</p><p>如何将数据库回退到修改之前的状态？</p><p>Undo日志：</p><p>逻辑日志 进行事务回滚 保证原子性</p><p><img src="/study_photo2/29.png" alt="image-20241127154501380"></p><p>isolation 与 锁</p><p>如果两个操作同时发生 发生冲突怎么办</p><p>锁机制</p><p>Share Lock 共享锁 读读 两个人都有共享锁</p><p>Exclusice Lock 写锁 读写 一个有写锁另一个不能有</p><p>读写   -》  MVCC数据的多版本</p><p><img src="/study_photo2/30.png" alt="image-20241127154917696"></p><p>一致性：</p><p>对数据的修改 永久保存</p><p>方案一 事务提交前页面写盘</p><p>随机io 写放大</p><p>方案二 WAL</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;字节青训营学习&quot;&gt;&lt;a href=&quot;#字节青训营学习&quot; class=&quot;headerlink&quot; title=&quot;字节青训营学习&quot;&gt;&lt;/a&gt;字节青训营学习&lt;/h1&gt;&lt;h3 id=&quot;一-入门篇学习&quot;&gt;&lt;a href=&quot;#一-入门篇学习&quot; class=&quot;headerlink</summary>
      
    
    
    
    
  </entry>
  
</feed>
