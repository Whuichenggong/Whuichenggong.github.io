<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>字节课程学习总结</title>
      <link href="/2024/11/08/Dance_Byte/"/>
      <url>/2024/11/08/Dance_Byte/</url>
      
        <content type="html"><![CDATA[<h1 id="字节内部课程学习"><a href="#字节内部课程学习" class="headerlink" title="字节内部课程学习"></a>字节内部课程学习</h1><h3 id="一-走进RPC框架"><a href="#一-走进RPC框架" class="headerlink" title="一.走进RPC框架"></a>一.走进RPC框架</h3><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h4><p>本地函数调用 压栈弹出</p><p>RPC调用  网上购物 {（付款操作）</p><p>远程调用 中间隔着网路  不能用函数指针了 是两个进程 机器id找到函数运行</p><p>解决问题 1. 函数映射</p><ol start="2"><li>数据转换成字节流 （客户端转换成字节流 传送给 服务端）</li><li>网络传输（高效稳定传输数据）</li></ol><p>}</p><p><img src="/study_photo/1.png" alt="示例图片"></p><p><strong>过程</strong>：User本地调用 打包参数 -》 RPC -》 对端-》解压-》调用真正业务逻辑 然后在返回 整个流程</p><p>IDL文件（接口描述文件）</p><p><img src="/study_photo/2.png" alt="image-20241107104049573"></p><p>Caller（调用段）和 生成代码 -》 encoder编码 -》字节流 -》打包传送给对端</p><p><strong>好处</strong></p><p><img src="/study_photo/3.png" alt="image-20241107104333574"></p><p><img src="/study_photo/4.png" alt="image-20241107111602308"></p><p><img src="/study_photo/5.png" alt="image-20241107111758336"></p><h4 id="2-编解码层："><a href="#2-编解码层：" class="headerlink" title="2.编解码层："></a>2.编解码层：</h4><p><img src="/study_photo/6.png" alt="image-20241107111909320"></p><p>编解码层：</p><p><img src="/study_photo/7.png" alt="image-20241107111950413"></p><p>二进制编码</p><p><img src="/study_photo/8.png" alt="image-20241107112146078"></p><p>左侧是IDL中写的统一的 -》字节流 有额外的内存开销</p><p><img src="/study_photo/10.png" alt="image-20241107112827203"></p><p><img src="/study_photo/11.png" alt="image-20241107112953295"></p><p><strong>多路复用</strong>：同一个链接内 可以有多个请求流通过</p><p>协议解析：</p><p><img src="/study_photo/12.png" alt="image-20241107113245207"></p><h4 id="4-网络通信层："><a href="#4-网络通信层：" class="headerlink" title="4.网络通信层："></a>4.网络通信层：</h4><p><img src="/study_photo/13.png" alt="image-20241107113347859"></p><p>SCOEKT API   （ip+端口）</p><p>一端关闭套接字    如果另一端如果尝试去读 可能就会返回（End Of File）也就是 EOF 在项目中我好像遇到过这个问题 用postman测试的时候返回了EOF错误和nil</p><p>网络库</p><p><img src="/study_photo/14.png" alt="image-20241107113810046"></p><h3 id="二-RPC关键指标分析与企业实践"><a href="#二-RPC关键指标分析与企业实践" class="headerlink" title="二.RPC关键指标分析与企业实践"></a>二.RPC关键指标分析与企业实践</h3><p>稳定性 易用性 扩展性 观测性 高性能</p><p>稳定性：</p><p><img src="/study_photo/15.png" alt="image-20241107114134948"></p><p><strong>过程：</strong>a调用b b调用c c如果响应慢 b就会一直等待 a也就超时了 a就会频繁调用b b堆积大量请求就会宕机</p><p>熔断起保护作用</p><p>稳定性：请求成功了率</p><p><img src="/study_photo/16.png" alt="image-20241107114404973"></p><p>1.均匀调用服务的每个节点</p><ol start="2"><li>重试几次</li></ol><p><img src="/study_photo/17.png" alt="image-20241107114611581"></p><p>备份请求： 左侧正常 1失败  2是重试请求  总时间 t1＋t2</p><p>​                    右侧 t3 tct99（这个值 在这个时间内应该可以返回值）如果在时间内没返回 就发送2请求 总时间就是 t4</p><h4 id="1-注册中间件"><a href="#1-注册中间件" class="headerlink" title="1.注册中间件"></a>1.注册中间件</h4><p><img src="/study_photo/18.png" alt="image-20241107114931005"></p><h4 id="2-易用性："><a href="#2-易用性：" class="headerlink" title="2.易用性："></a>2.易用性：</h4><p><img src="/study_photo/19.png" alt="image-20241107115019715"></p><p>自动生成代码工具 ： 减少重复性工作</p><h4 id="3-扩展性"><a href="#3-扩展性" class="headerlink" title="3.扩展性"></a>3.扩展性</h4><p><img src="/study_photo/20.png" alt="image-20241107115236618"></p><p>用户请求 经过中间件处理-》和远端交互 -》 也通过中间件处理-》服务器</p><h4 id="4-观测性："><a href="#4-观测性：" class="headerlink" title="4.观测性："></a>4.观测性：</h4><p><img src="/study_photo/21.png" alt="image-20241107115409542"></p><p>日志观察 监控面板qbs 链路跟踪（服务通过请求为什么超时了 耗费的时间是多少）</p><p>linux的top工具类似原理</p><h4 id="5-高性能："><a href="#5-高性能：" class="headerlink" title="5.高性能："></a>5.高性能：</h4><p><img src="/study_photo/22.png" alt="image-20241107115628087"></p><p>高吞吐：在单位时间内尽可能多的处理更多请求</p><p>低延迟： 一次请求发出去延迟尽可能地低（重要）</p><p>​</p><h4 id="6-本章总结："><a href="#6-本章总结：" class="headerlink" title="6.  本章总结："></a>6.  本章总结：</h4><p><img src="/study_photo/23.png" alt="image-20241107115938337"></p><p>字节实践：</p><p><img src="/study_photo/24.png" alt="image-20241107120230033"></p><p>组件 结构 远端交互层 网络库  代码生成工具 （最左侧）</p><p>为什么自研网络库？</p><p>gonet</p><p><img src="/study_photo/25.png" alt="image-20241107120515080"></p><p>Netpoll</p><p><img src="/study_photo/26.png" alt="image-20241107120603540"></p><p><img src="/study_photo/27.png" alt="image-20241107120656906"></p><p>交互方式pingpang（一发一回） 编解码 应用层协议</p><p>优化：</p><p><img src="/study_photo/28.png" alt="image-20241107120826363"></p><p><img src="/study_photo/29.png" alt="image-20241107120948515"></p><p>你应该想这些是怎么实现的？</p><p><img src="/study_photo/30.png" alt="image-20241107121448901"></p><p><img src="/study_photo/31.png" alt="image-20241107121741751"></p><h3 id="三-走进HTTP协议"><a href="#三-走进HTTP协议" class="headerlink" title="三.走进HTTP协议"></a>三.走进HTTP协议</h3><h4 id="1-再谈http协议"><a href="#1-再谈http协议" class="headerlink" title="1.再谈http协议"></a>1.再谈http协议</h4><p>HTTP 超文本传输协议</p><p><img src="/study_photo/32.png" alt="image-20241108133154991"></p><p>http协议将人话以计算机语言传输过去</p><p><img src="/study_photo/33.png" alt="image-20241108133257828"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">请求行</span><br><span class="line">：分隔 原数据</span><br><span class="line"></span><br><span class="line">包的字节数</span><br><span class="line">大空行</span><br><span class="line"></span><br><span class="line">我们想说的话</span><br><span class="line"></span><br><span class="line">下面是回复</span><br></pre></td></tr></table></figure><p><img src="/study_photo/34.png" alt="image-20241108133725032"></p><p><img src="/study_photo/35.png" alt="image-20241108133847415"></p><p>上述功能代码：</p><p><img src="/study_photo/36.png" alt="image-20241108134149368"></p><p>处理流程:</p><p><img src="/study_photo/37.png" alt="image-20241108134229285"></p><p>H1的不足 H2也没完全解决    UDP解决对头阻塞</p><p><img src="/study_photo/38.png" alt="image-20241108134628306"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>美化博客</title>
      <link href="/2024/11/08/lasting_beauty/"/>
      <url>/2024/11/08/lasting_beauty/</url>
      
        <content type="html"><![CDATA[<p>使博客看起来更加美观，持续更新中！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>发布博客出现的问题</title>
      <link href="/2024/11/06/github_actions/"/>
      <url>/2024/11/06/github_actions/</url>
      
        <content type="html"><![CDATA[<p>每一次用push推送到githubpage都会出现构建部署错误 我问了一下ai原因 这才有点明白到底是为什么</p><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>为什么会有这种差异？<br>GitHub Pages 和 本地环境的差异：</p><p>在本地执行 hexo d 时，你的本地环境会根据 package.json 中的依赖来安装所有的主题和插件，确保所有必要的资源都存在。<br>但是 GitHub Pages 仅仅依赖仓库中已经推送的文件（通常是 public&#x2F; 文件夹和 ._config.yml），它不会自动运行 npm、yarn 或 pnpm 来安装依赖。换句话说，GitHub Pages 并不会在部署过程中安装缺少的主题或插件。<br>依赖没有正确推送：</p><p>你在本地运行 hexo d 时，可能已经正确地安装了 butterfly 主题，并且该主题存在于本地的 _config.yml 中和 node_modules 文件夹中。<br>然而，在推送到 GitHub 上时，你没有将 node_modules 中的 butterfly 主题或相关配置文件推送到 GitHub 仓库。GitHub Pages 需要能够访问这些主题文件，而它不会在部署过程中下载和安装这些依赖。<br>GitHub Pages 配置问题：</p><p>如果你直接使用 GitHub Pages 作为部署平台，GitHub 并不会自动安装你的 Hexo 依赖，因此它不能像本地环境一样找到 butterfly 主题。<br>GitHub Pages 需要使用一个可以通过静态文件夹来部署的版本，而 Hexo 本地运行时通常会将主题内容放在 node_modules 中，这些内容并不会自动推送到 GitHub，除非你特别将它们包含在仓库中。</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>使用github-actions<br>并且在google查找到的方法添加 .nojekyll文件 让github站点不适用jekyll</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">name: Hexo Deploy</span><br><span class="line"></span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches:</span><br><span class="line">      - main  # 监听主分支的推送</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  deploy:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    steps:</span><br><span class="line">      - name: Checkout repository</span><br><span class="line">        uses: actions/checkout@v2</span><br><span class="line"></span><br><span class="line">      - name: Setup Node.js</span><br><span class="line">        uses: actions/setup-node@v2</span><br><span class="line">        with:</span><br><span class="line">          node-version: &#x27;16&#x27;</span><br><span class="line"></span><br><span class="line">      - name: Install dependencies</span><br><span class="line">        run: |</span><br><span class="line">          npm install</span><br><span class="line"></span><br><span class="line">      - name: Generate and Deploy</span><br><span class="line">        run: |</span><br><span class="line">          hexo generate</span><br><span class="line">          hexo deploy</span><br><span class="line">        env:</span><br><span class="line">          HEXO_DEPLOY_PATH: $&#123;&#123; secrets.HEXO_DEPLOY_PATH &#125;&#125;  # 设置部署路径</span><br></pre></td></tr></table></figure><p>多看源码 基础真的很重要 多看官方文档能解决很多问题</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>github参与开源应该做什么</title>
      <link href="/2024/11/05/github/"/>
      <url>/2024/11/05/github/</url>
      
        <content type="html"><![CDATA[<h1 id="第一次参与开源项目应该做些什么"><a href="#第一次参与开源项目应该做些什么" class="headerlink" title="第一次参与开源项目应该做些什么"></a>第一次参与开源项目应该做些什么</h1><p>借鉴Moment老哥文档</p><p><a href="https://juejin.cn/post/7354233858063925267">https://juejin.cn/post/7354233858063925267</a></p><h4 id="第一步fork"><a href="#第一步fork" class="headerlink" title="第一步fork"></a>第一步fork</h4><p>fork到自己的仓库下 且选择fork所有分支 这样就可以有修改项目的权限<br>通过Pull Request方式 commits合到上游项目</p><h4 id="第二步克隆项目"><a href="#第二步克隆项目" class="headerlink" title="第二步克隆项目"></a>第二步克隆项目</h4><p>git clone …</p><h4 id="第三步更新本地分支代码"><a href="#第三步更新本地分支代码" class="headerlink" title="第三步更新本地分支代码"></a>第三步更新本地分支代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git remote add upstream &lt;原始仓库的URL&gt;</span><br><span class="line">git fetch upstream</span><br><span class="line">git checkout main</span><br><span class="line">git rebase upstream/main</span><br></pre></td></tr></table></figure><h5 id="根据ai理解-上述git指令"><a href="#根据ai理解-上述git指令" class="headerlink" title="根据ai理解 上述git指令"></a>根据ai理解 上述git指令</h5><p>git remote add upstream &lt;原始仓库的URL&gt;<br>这条命令是将原始仓库添加为远程仓库，通常在你 fork 了一个 GitHub 仓库后，会创建一个 origin 指向你自己的远程仓库，但原始仓库（即你 fork 的那个仓库）并没有设置</p><hr><p>命令解释：</p><p>git remote add：</p><h2 id="用于添加一个新的远程仓库。upstream：这是你为原始仓库起的别名。通常我们使用-upstream-来表示原始仓库，而-origin-则表示你-fork-后的仓库。：你需要替换成原始仓库的-URL，通常是类似-https-github-com-owner-repository-git-这样的形式。举个例子：-假设你从-GitHub-上-fork-了一个叫做-awesome-project-的仓库，原始仓库的-URL-是-https-github-com-original-owner-awesome-project-git，-你可以运行以下命令：git-remote-add-upstream-https-github-com-original-owner-awesome-project-git"><a href="#用于添加一个新的远程仓库。upstream：这是你为原始仓库起的别名。通常我们使用-upstream-来表示原始仓库，而-origin-则表示你-fork-后的仓库。：你需要替换成原始仓库的-URL，通常是类似-https-github-com-owner-repository-git-这样的形式。举个例子：-假设你从-GitHub-上-fork-了一个叫做-awesome-project-的仓库，原始仓库的-URL-是-https-github-com-original-owner-awesome-project-git，-你可以运行以下命令：git-remote-add-upstream-https-github-com-original-owner-awesome-project-git" class="headerlink" title="用于添加一个新的远程仓库。upstream：这是你为原始仓库起的别名。通常我们使用 upstream 来表示原始仓库，而 origin 则表示你 fork 后的仓库。&lt;原始仓库的URL&gt;：你需要替换成原始仓库的 URL，通常是类似 https://github.com/owner/repository.git 这样的形式。举个例子： 假设你从 GitHub 上 fork 了一个叫做 awesome-project 的仓库，原始仓库的 URL 是 https://github.com/original-owner/awesome-project.git， 你可以运行以下命令：git remote add upstream https://github.com/original-owner/awesome-project.git"></a>用于添加一个新的远程仓库。<br>upstream：这是你为原始仓库起的别名。通常我们使用 upstream 来表示原始仓库，而 origin 则表示你 fork 后的仓库。<br>&lt;原始仓库的URL&gt;：你需要替换成原始仓库的 URL，通常是类似 <del><a href="https://github.com/owner/repository.git">https://github.com/owner/repository.git</a></del> 这样的形式。<br>举个例子： 假设你从 GitHub 上 fork 了一个叫做 awesome-project 的仓库，原始仓库的 URL 是 <del><a href="https://github.com/original-owner/awesome-project.git%EF%BC%8C">https://github.com/original-owner/awesome-project.git，</a></del> 你可以运行以下命令：<br>git remote add upstream <del><a href="https://github.com/original-owner/awesome-project.git">https://github.com/original-owner/awesome-project.git</a></del></h2><p>git fetch upstream</p><h2 id="、这条命令是从原始仓库拉取最新的变化，但它并不会改变你当前的工作分支。它会将原始仓库的更新下载到你本地，但不自动合并到你的分支中。举个例子：-继续使用上面的例子，如果原始仓库-awesome-project-有了新的提交，你可以通过以下命令来获取这些更新：git-fetch-upstream这条命令会从-upstream（原始仓库）拉取最新的提交，但是你的当前分支的代码还不会发生变化。"><a href="#、这条命令是从原始仓库拉取最新的变化，但它并不会改变你当前的工作分支。它会将原始仓库的更新下载到你本地，但不自动合并到你的分支中。举个例子：-继续使用上面的例子，如果原始仓库-awesome-project-有了新的提交，你可以通过以下命令来获取这些更新：git-fetch-upstream这条命令会从-upstream（原始仓库）拉取最新的提交，但是你的当前分支的代码还不会发生变化。" class="headerlink" title="、这条命令是从原始仓库拉取最新的变化，但它并不会改变你当前的工作分支。它会将原始仓库的更新下载到你本地，但不自动合并到你的分支中。举个例子： 继续使用上面的例子，如果原始仓库 awesome-project 有了新的提交，你可以通过以下命令来获取这些更新：git fetch upstream这条命令会从 upstream（原始仓库）拉取最新的提交，但是你的当前分支的代码还不会发生变化。"></a>、这条命令是从原始仓库拉取最新的变化，但它并不会改变你当前的工作分支。它会将原始仓库的更新下载到你本地，但不自动合并到你的分支中。<br>举个例子： 继续使用上面的例子，如果原始仓库 awesome-project 有了新的提交，你可以通过以下命令来获取这些更新：<br>git fetch upstream<br>这条命令会从 upstream（原始仓库）拉取最新的提交，但是你的当前分支的代码还不会发生变化。</h2><p>git rebase upstream&#x2F;main</p><p>这条命令是将原始仓库（upstream）的 main 分支的最新提交应用到你本地的 main 分支上。<br>通过 rebase，你可以把你本地的提交历史 “重新基于” 原始仓库的更新，保持你的提交历史更加整洁。</p><p> <strong>总结：</strong> 这样，本地 main 分支就会包含原始仓库的最新更改，并且历史记录会保持整洁。如果有冲突，Git 会提示你解决冲突并继续 rebase。</p><p><strong>注意：</strong><br>—-在项目中不应该轻易的在main分支上做更改而是创建的分支 最好保证每个功能一个分支</p><p>创建分支在分支中编写代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b feat-xxx</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="feat前缀"><a href="#feat前缀" class="headerlink" title="feat前缀"></a>feat前缀</h4><p>feat 前缀用于标记新增功能（feature）的提交。它表示该提交引入了一个新的特性或扩展了项目的功能。使用 feat 可以快速识别出项目功能的增长点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">feat: add user login functionality</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="fix前缀"><a href="#fix前缀" class="headerlink" title="fix前缀"></a>fix前缀</h4><p>fix 前缀用于标记修复 bug 的提交。它说明该提交解决了项目中的一个或多个已知问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fix: correct minor typos in code</span><br></pre></td></tr></table></figure><p>等等指令在此省略 详细的等到具体运用中再做增加</p><h4 id="写入你想更改的地方"><a href="#写入你想更改的地方" class="headerlink" title="写入你想更改的地方"></a>写入你想更改的地方</h4><p>提交你的更改 </p><h4 id="开一个PR"><a href="#开一个PR" class="headerlink" title="开一个PR"></a>开一个PR</h4><p>在完成 push 操作后，我们打开 GitHub，可以看到一个黄色的提示框，告诉我们可以开一个 Pull Request 了</p><p>参考：</p><p><a href="https://link.juejin.cn/?target=https://github.com/xun082/create-neat/pull/83">https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fxun082%2Fcreate-neat%2Fpull%2F83</a><br>一定要参与一次实践，才懂得如何去做。只有错过了，才能保证下一次的完美运行。</p><hr><p>—最后希望自己早入加入开源大家庭中，加油！ </p><ul><li><pre><code>                     2024 11.5日</code></pre></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git使用总结</title>
      <link href="/2024/11/04/git/"/>
      <url>/2024/11/04/git/</url>
      
        <content type="html"><![CDATA[<h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><h2 id="1-git-clone-到本地2-git-checkout-b-xxx-切换至新分支xxx（相当于复制了remote的仓库到本地的xxx分支上3-修改或者添加本地代码（部署在硬盘的源文件上）4-git-diff-查看自己对代码做出的改变5-git-add-上传更新后的代码至暂存区6-git-commit-可以将暂存区里更新后的代码更新到本地git7-git-push-origin-xxx-将本地的xxxgit分支上传至github上的git"><a href="#1-git-clone-到本地2-git-checkout-b-xxx-切换至新分支xxx（相当于复制了remote的仓库到本地的xxx分支上3-修改或者添加本地代码（部署在硬盘的源文件上）4-git-diff-查看自己对代码做出的改变5-git-add-上传更新后的代码至暂存区6-git-commit-可以将暂存区里更新后的代码更新到本地git7-git-push-origin-xxx-将本地的xxxgit分支上传至github上的git" class="headerlink" title="1.git clone &#x2F;&#x2F; 到本地2.git checkout -b xxx 切换至新分支xxx（相当于复制了remote的仓库到本地的xxx分支上3.修改或者添加本地代码（部署在硬盘的源文件上）4.git diff 查看自己对代码做出的改变5.git add 上传更新后的代码至暂存区6.git commit 可以将暂存区里更新后的代码更新到本地git7.git push origin xxx 将本地的xxxgit分支上传至github上的git"></a>1.git clone &#x2F;&#x2F; 到本地<br>2.git checkout -b xxx 切换至新分支xxx<br>（相当于复制了remote的仓库到本地的xxx分支上<br>3.修改或者添加本地代码（部署在硬盘的源文件上）<br>4.git diff 查看自己对代码做出的改变<br>5.git add 上传更新后的代码至暂存区<br>6.git commit 可以将暂存区里更新后的代码更新到本地git<br>7.git push origin xxx 将本地的xxxgit分支上传至github上的git</h2><h2 id="（如果在写自己的代码过程中发现远端GitHub上代码出现改变）1-git-checkout-main-切换回main分支2-git-pull-origin-master-main-将远端修改过的代码再更新到本地3-git-checkout-xxx-回到xxx分支4-git-rebase-main-我在xxx分支上，先把main移过来，然后根据我的commit来修改成新的内容（中途可能会出现，rebase-conflict-—–》手动选择保留哪段代码）5-git-push-f-origin-xxx-把rebase后并且更新过的代码再push到远端github上（-f-—》强行）6-原项目主人采用pull-request-中的-squash-and-merge-合并所有不同的commit"><a href="#（如果在写自己的代码过程中发现远端GitHub上代码出现改变）1-git-checkout-main-切换回main分支2-git-pull-origin-master-main-将远端修改过的代码再更新到本地3-git-checkout-xxx-回到xxx分支4-git-rebase-main-我在xxx分支上，先把main移过来，然后根据我的commit来修改成新的内容（中途可能会出现，rebase-conflict-—–》手动选择保留哪段代码）5-git-push-f-origin-xxx-把rebase后并且更新过的代码再push到远端github上（-f-—》强行）6-原项目主人采用pull-request-中的-squash-and-merge-合并所有不同的commit" class="headerlink" title="（如果在写自己的代码过程中发现远端GitHub上代码出现改变）1.git checkout main 切换回main分支2.git pull origin master(main) 将远端修改过的代码再更新到本地3.git checkout xxx 回到xxx分支4.git rebase main 我在xxx分支上，先把main移过来，然后根据我的commit来修改成新的内容（中途可能会出现，rebase conflict —–》手动选择保留哪段代码）5.git push -f origin xxx 把rebase后并且更新过的代码再push到远端github上（-f —》强行）6.原项目主人采用pull request 中的 squash and merge 合并所有不同的commit"></a>（如果在写自己的代码过程中发现远端GitHub上代码出现改变）<br>1.git checkout main 切换回main分支<br>2.git pull origin master(main) 将远端修改过的代码再更新到本地<br>3.git checkout xxx 回到xxx分支<br>4.git rebase main 我在xxx分支上，先把main移过来，然后根据我的commit来修改成新的内容<br>（中途可能会出现，rebase conflict —–》手动选择保留哪段代码）<br>5.git push -f origin xxx 把rebase后并且更新过的代码再push到远端github上<br>（-f —》强行）<br>6.原项目主人采用pull request 中的 squash and merge 合并所有不同的commit</h2><p>远端完成更新后<br>1.git branch -d xxx 删除本地的git分支<br>2.git pull origin master 再把远端的最新代码拉至本地</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>北京之旅</title>
      <link href="/2024/11/04/hello-world/"/>
      <url>/2024/11/04/hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="开源社"><a href="#开源社" class="headerlink" title="开源社"></a>开源社</h2><p>在偶然一次发现中 开源社举办了第九届中国开源年会，我很是激动，心中迅速萌发了去北京参加的冲动并和小伙伴赵冰<br>决定这周五来一次说走就走的旅行~~~</p><h2 id="到达北京"><a href="#到达北京" class="headerlink" title="到达北京"></a>到达北京</h2><p>在周六的早上到达会场 扫了入场的码 领到了活动给的一些礼品 7点多我俩就到达了会场，刚开始觉得平平无奇，后来直到大会开始，陆陆续续的大家都来到了会场，开源社的<br>老哥，老姐们开始了自己的演讲，我发现这真的不是一个普通大会，很多人报着开源的理念 一直维持着开源社，让开源社越来越大<br>虽然是第一次参加，但是我对于这种氛围是非常的喜欢，各位有着自己想法的人都在开源社散发光辉，有为抗癌人士专门发布app的<br>小胰宝等其他的产品，这令我深受触动，把科技真真正正的融合到了生活当中，使人们都能享受科技带来的便捷！大会中的每一个人的演讲都令我感到激动！但是对我印象的最深刻的就是<strong>yihong0618</strong>这个id，伊洪老师的演讲令我眼前一亮心里一跳哈哈哈哈<br>简直太爽啦！！！</p><h2 id="yihong0618"><a href="#yihong0618" class="headerlink" title="yihong0618"></a>yihong0618</h2><p>请大家自己去看伊洪老师的github，你真的能从中学到很多，在火车上我一直再看伊洪老师的github<br>每一件事是写的那么的真诚，有很多我也感同身受，生活的迷茫原来真的不是自己才有，面临各种压力，各种抉择！做好自己。<br>老师的仓库里也有非常多的实用的产品大家可以自己去看！！</p><p>[github] <a href="https://github.com/yihong0618">https://github.com/yihong0618</a></p><p>在伊洪老师的演讲中，令我觉得钦佩的是，每一天的记录自己，我太喜欢这种感觉了，发布到github上，我也便想向这么做<br>在4日赶回来我便从网上学习搭建博客，坚持记录每一天</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这次旅程，说走就走，哈哈哈，这才是大学生嘛，遇见了开源社的大家，我希望从今的每一天，慢慢的融入到开源社这个大家庭</p><p>-感谢冰哥陪我这次旅行</p><pre><code>                                                                    2024年11.4日</code></pre>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>音乐</title>
      <link href="/Music/index.html"/>
      <url>/Music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>图库</title>
      <link href="/Gallery/index.html"/>
      <url>/Gallery/index.html</url>
      
        <content type="html"><![CDATA[<div class="gallery-group-main"><figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='/Gallery/beijing.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">北京</div>  <p>中关村</p>  <a href='/Gallery/beijing.jpg'></a>  </figcaption>  </figure>  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='/Gallery/beijing2.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">北京</div>  <p>风景</p>  <a href='/Gallery/beijing2.jpg'></a>  </figcaption>  </figure>  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='/Gallery/beijing3.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">北京</div>  <p>风景</p>  <a href='/Gallery/beijing3.jpg'></a>  </figcaption>  </figure>  </div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友情链接</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
