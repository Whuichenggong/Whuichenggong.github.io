<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构的实现</title>
      <link href="/2024/11/09/data_structure/"/>
      <url>/2024/11/09/data_structure/</url>
      
        <content type="html"><![CDATA[<h2 id="双链表的实现"><a href="#双链表的实现" class="headerlink" title="双链表的实现"></a>双链表的实现</h2><h3 id="基于go语言实现"><a href="#基于go语言实现" class="headerlink" title="基于go语言实现"></a>基于go语言实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">// Node 定义双链表节点</span><br><span class="line">type Node struct &#123;</span><br><span class="line">    data  interface&#123;&#125;</span><br><span class="line">    prev  *Node</span><br><span class="line">    next  *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// DoublyLinkedList 定义双链表</span><br><span class="line">type DoublyLinkedList struct &#123;</span><br><span class="line">    head *Node</span><br><span class="line">    tail *Node</span><br><span class="line">    size int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// InsertTail 向链表尾部插入节点</span><br><span class="line">func (dll *DoublyLinkedList) InsertTail(data interface&#123;&#125;) &#123;</span><br><span class="line">    newNode := &amp;Node&#123;data: data&#125;</span><br><span class="line">    if dll.size == 0 &#123;</span><br><span class="line">        dll.head = newNode</span><br><span class="line">        dll.tail = newNode</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        dll.tail.next = newNode</span><br><span class="line">        newNode.prev = dll.tail</span><br><span class="line">        dll.tail = newNode</span><br><span class="line">    &#125;</span><br><span class="line">    dll.size++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// InsertHead 向链表头部插入节点</span><br><span class="line">func (dll *DoublyLinkedList) InsertHead(data interface&#123;&#125;) &#123;</span><br><span class="line">    newNode := &amp;Node&#123;data: data&#125;</span><br><span class="line">    if dll.size == 0 &#123;</span><br><span class="line">        dll.head = newNode</span><br><span class="line">        dll.tail = newNode</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        newNode.next = dll.head</span><br><span class="line">        dll.head.prev = newNode</span><br><span class="line">        dll.head = newNode</span><br><span class="line">    &#125;</span><br><span class="line">    dll.size++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Remove 删除节点</span><br><span class="line">func (dll *DoublyLinkedList) Remove(node *Node) &#123;</span><br><span class="line">    if node.prev != nil &#123;</span><br><span class="line">        node.prev.next = node.next</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        dll.head = node.next</span><br><span class="line">    &#125;</span><br><span class="line">    if node.next != nil &#123;</span><br><span class="line">        node.next.prev = node.prev</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        dll.tail = node.prev</span><br><span class="line">    &#125;</span><br><span class="line">    node.prev = nil</span><br><span class="line">    node.next = nil</span><br><span class="line">    dll.size--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Display 打印双链表</span><br><span class="line">func (dll *DoublyLinkedList) Display() &#123;</span><br><span class="line">    curr := dll.head</span><br><span class="line">    for curr != nil &#123;</span><br><span class="line">        fmt.Print(curr.data, &quot; &quot;)</span><br><span class="line">        curr = curr.next</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    dll := DoublyLinkedList&#123;&#125;</span><br><span class="line">    dll.InsertTail(1)</span><br><span class="line">    dll.InsertTail(2)</span><br><span class="line">    dll.InsertHead(0)</span><br><span class="line">    dll.Display() // 应该输出：0 1 2</span><br><span class="line"></span><br><span class="line">    // 删除节点</span><br><span class="line">    headNode := dll.head</span><br><span class="line">    dll.Remove(headNode)</span><br><span class="line">    dll.Display() // 应该输出：1 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基于c语言实现双链表"><a href="#基于c语言实现双链表" class="headerlink" title="基于c语言实现双链表"></a>基于c语言实现双链表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">// 定义双链表节点结构</span><br><span class="line">typedef struct Node &#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct Node* prev;</span><br><span class="line">    struct Node* next;</span><br><span class="line">&#125; Node;</span><br><span class="line">// 创建一个新节点</span><br><span class="line">Node* createNode(int data) &#123;</span><br><span class="line">    Node* newNode = (Node*)malloc(sizeof(Node));</span><br><span class="line">    if (newNode == NULL) &#123;</span><br><span class="line">        printf(&quot;内存分配失败&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;prev = NULL;</span><br><span class="line">    newNode-&gt;next = NULL;</span><br><span class="line">    return newNode;</span><br><span class="line">&#125;</span><br><span class="line">// 在双链表前插入节点</span><br><span class="line">void insertFront(Node** head, int data) &#123;</span><br><span class="line">    Node* newNode = createNode(data);</span><br><span class="line">    newNode-&gt;next = *head;</span><br><span class="line">    if (*head != NULL) &#123;</span><br><span class="line">        (*head)-&gt;prev = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    *head = newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在双链表后插入节点</span><br><span class="line">void insertRear(Node** head, int data) &#123;</span><br><span class="line">    Node* newNode = createNode(data);</span><br><span class="line">    if (*head == NULL) &#123;</span><br><span class="line">        *head = newNode;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* last = *head;</span><br><span class="line">    while (last-&gt;next != NULL) &#123;</span><br><span class="line">        last = last-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    last-&gt;next = newNode;</span><br><span class="line">    newNode-&gt;prev = last;</span><br><span class="line">&#125;</span><br><span class="line">// 删除双链表前的节点</span><br><span class="line">void deleteFront(Node** head) &#123;</span><br><span class="line">    if (*head == NULL) &#123;</span><br><span class="line">        printf(&quot;链表为空，无法删除&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* temp = *head;</span><br><span class="line">    *head = (*head)-&gt;next;</span><br><span class="line">    if (*head != NULL) &#123;</span><br><span class="line">        (*head)-&gt;prev = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    free(temp);</span><br><span class="line">&#125;</span><br><span class="line">// 删除双链表后的节点</span><br><span class="line">void deleteRear(Node** head) &#123;</span><br><span class="line">    if (*head == NULL) &#123;</span><br><span class="line">        printf(&quot;链表为空，无法删除&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* secondLast = *head;</span><br><span class="line">    while (secondLast-&gt;next-&gt;next != NULL) &#123;</span><br><span class="line">        secondLast = secondLast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* temp = secondLast-&gt;next;</span><br><span class="line">    secondLast-&gt;next = NULL;</span><br><span class="line">    free(temp);</span><br><span class="line">&#125;</span><br><span class="line">// 打印双链表</span><br><span class="line">void printList(Node* node) &#123;</span><br><span class="line">    while (node != NULL) &#123;</span><br><span class="line">        printf(&quot;%d &quot;, node-&gt;data);</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    Node* head = NULL;</span><br><span class="line"></span><br><span class="line">    insertFront(&amp;head, 10);</span><br><span class="line">    insertFront(&amp;head, 20);</span><br><span class="line">    insertRear(&amp;head, 30);</span><br><span class="line">    insertRear(&amp;head, 40);</span><br><span class="line"></span><br><span class="line">    printList(head);  // 输出：20 10 30 40</span><br><span class="line"></span><br><span class="line">    deleteFront(&amp;head);</span><br><span class="line">    deleteRear(&amp;head);</span><br><span class="line"></span><br><span class="line">    printList(head);  // 输出：10 30</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>区别：</p><p>c语言的双链表 我们要清楚 改变了头节点 所以要传入二级指针 才能正确的记录到头指针的变化</p><p>而Go语言，因为 Go 中的切片、映射和通道等是引用类型，它们在函数参数传递时本身就是按引用传递的，不需要通过指针的指针（二级指针）来实现修改。这实际上是 Go 语言的一个特性：切片、映射和通道在函数间传递时，共享底层数据结构，因此不需要额外的二级指针。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>leet-code之旅</title>
      <link href="/2024/11/09/leet-code/"/>
      <url>/2024/11/09/leet-code/</url>
      
        <content type="html"><![CDATA[<h1 id="正式开启刷leet-code"><a href="#正式开启刷leet-code" class="headerlink" title="正式开启刷leet-code"></a>正式开启刷leet-code</h1><h3 id="第225-用两个队列实现栈"><a href="#第225-用两个队列实现栈" class="headerlink" title="第225.用两个队列实现栈"></a>第225.用两个队列实现栈</h3><p>问题：</p><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。</p><p>实现 MyStack 类：</p><p>void push(int x) 将元素 x 压入栈顶。<br>int pop() 移除并返回栈顶元素。<br>int top() 返回栈顶元素。<br>boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。</p><h4 id="我的代码："><a href="#我的代码：" class="headerlink" title="我的代码："></a>我的代码：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">type MyStack struct &#123;</span><br><span class="line">    list1 := list.New()</span><br><span class="line">    list2 := list.New()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func Constructor() MyStack &#123;</span><br><span class="line">    MyStack.Push(x)</span><br><span class="line">    MyStack.Push(x)</span><br><span class="line">    MyStack.Push(x)</span><br><span class="line">    MyStack.Pop()</span><br><span class="line">    MyStack.Top()</span><br><span class="line">    MyStack.empty()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (this *MyStack) Push(x int)  &#123;</span><br><span class="line">    this.list1.PushBack(x)</span><br><span class="line">    temp := x</span><br><span class="line">    this.list2.PushFront(temp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (this *MyStack) Pop() int &#123;</span><br><span class="line">   temp = this.list2.Value</span><br><span class="line">   e = e.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (this *MyStack) Top() int &#123;</span><br><span class="line">    temp = this.list2.Value</span><br><span class="line">    return temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (this *MyStack) Empty() bool &#123;</span><br><span class="line">    if this.list2.Value == nil</span><br><span class="line">    return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your MyStack object will be instantiated and called as such:</span><br><span class="line"> * obj := Constructor();</span><br><span class="line"> * obj.Push(x);</span><br><span class="line"> * param_2 := obj.Pop();</span><br><span class="line"> * param_3 := obj.Top();</span><br><span class="line"> * param_4 := obj.Empty();</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h4 id="虚伪的正确的代码："><a href="#虚伪的正确的代码：" class="headerlink" title="虚伪的正确的代码："></a>虚伪的正确的代码：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;container/list&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type MyStack struct &#123;</span><br><span class="line">list1 *list.List</span><br><span class="line">list2 *list.List</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func Constructor() MyStack &#123;</span><br><span class="line">return MyStack &#123;</span><br><span class="line">list1: list.New(),</span><br><span class="line">list2: list.New(),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (this *MyStack) Push(x int)  &#123;</span><br><span class="line">this.list1.PushBack(x)</span><br><span class="line">temp := x</span><br><span class="line">this.list2.PushFront(temp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (this *MyStack) Pop() int &#123;</span><br><span class="line">if this.list2.Len() == 0 &#123;</span><br><span class="line">return -1 // 如果stack为空返回-1或者其他适当的值</span><br><span class="line">&#125;</span><br><span class="line">temp := this.list2.Front()</span><br><span class="line">this.list2.Remove(temp)</span><br><span class="line">return temp.Value.(int)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (this *MyStack) Top() int &#123;</span><br><span class="line">if this.list2.Len() == 0 &#123;</span><br><span class="line">return -1 // 如果栈为空则返回-1或者其他适当的值</span><br><span class="line">&#125;</span><br><span class="line">temp := this.list2.Front().Value(int)</span><br><span class="line">return temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (this *MyStack) Empty() bool &#123;</span><br><span class="line">return this.list2.Len() == 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* Your MyStack object will be instantiated and called as such:</span><br><span class="line">* obj := Constructor();</span><br><span class="line">* obj.Push(x);</span><br><span class="line">* param_2 := obj.Pop();</span><br><span class="line">* param_3 := obj.Top();</span><br><span class="line">* param_4 := obj.Empty();</span><br><span class="line">  */</span><br></pre></td></tr></table></figure><p>使用go语言内置的list包 也就是双向链表的操作<br>运用到了go语言的断言 <code>this.list2.Front().Value.(int)</code></p><p>但是 虽然通过了 但是思路应该是错了哈哈哈哈 ！ 这段代码并没有用到队列的性质而是双链表。。。。并没有遵守题目的规则<br>代码问题：</p><p>而只是使用了两个链表，其中 list2 实际上扮演了“栈”的角色。这样的话，list2 单独一个链表就能实现后进先出，不需要 list1 的辅助。</p><h4 id="真正的正确代码"><a href="#真正的正确代码" class="headerlink" title="真正的正确代码"></a>真正的正确代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;container/list&quot;</span><br><span class="line"></span><br><span class="line">type MyStack struct &#123;</span><br><span class="line">queue1 *list.List</span><br><span class="line">queue2 *list.List</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Constructor() MyStack &#123;</span><br><span class="line">return MyStack&#123;</span><br><span class="line">queue1: list.New(),</span><br><span class="line">queue2: list.New(),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (this *MyStack) Push(x int) &#123;</span><br><span class="line">this.queue1.PushBack(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (this *MyStack) Pop() int &#123;</span><br><span class="line">if this.queue1.Len() == 0 &#123;</span><br><span class="line">return -1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for this.queue1.Len() &gt; 1 &#123;</span><br><span class="line">front := this.queue1.Front()</span><br><span class="line">this.queue1.Remove(front)</span><br><span class="line">this.queue2.PushBack(front.Value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">top := this.queue1.Front()</span><br><span class="line">this.queue1.Remove(top)</span><br><span class="line"></span><br><span class="line">this.queue1, this.queue2 = this.queue2, this.queue1</span><br><span class="line">return top.Value.(int)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (this *MyStack) Top() int &#123;</span><br><span class="line">if this.queue1.Len() == 0 &#123;</span><br><span class="line">return -1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for this.queue1.Len() &gt; 1 &#123;</span><br><span class="line">front := this.queue1.Front()</span><br><span class="line">this.queue1.Remove(front)</span><br><span class="line">this.queue2.PushBack(front.Value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">top := this.queue1.Front()</span><br><span class="line">this.queue2.PushBack(top.Value)</span><br><span class="line"></span><br><span class="line">this.queue1, this.queue2 = this.queue2, this.queue1</span><br><span class="line">return top.Value.(int)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (this *MyStack) Empty() bool &#123;</span><br><span class="line">return this.queue1.Len() == 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>字节课程学习总结</title>
      <link href="/2024/11/08/Dance_Byte/"/>
      <url>/2024/11/08/Dance_Byte/</url>
      
        <content type="html"><![CDATA[<h1 id="字节内部课程学习"><a href="#字节内部课程学习" class="headerlink" title="字节内部课程学习"></a>字节内部课程学习</h1><h3 id="一-走进RPC框架"><a href="#一-走进RPC框架" class="headerlink" title="一.走进RPC框架"></a>一.走进RPC框架</h3><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h4><p>本地函数调用 压栈弹出</p><p>RPC调用  网上购物 {（付款操作）</p><p>远程调用 中间隔着网路  不能用函数指针了 是两个进程 机器id找到函数运行</p><p>解决问题 1. 函数映射</p><ol start="2"><li>数据转换成字节流 （客户端转换成字节流 传送给 服务端）</li><li>网络传输（高效稳定传输数据）</li></ol><p>}</p><p><img src="/study_photo/1.png" alt="示例图片"></p><p><strong>过程</strong>：User本地调用 打包参数 -》 RPC -》 对端-》解压-》调用真正业务逻辑 然后在返回 整个流程</p><p>IDL文件（接口描述文件）</p><p><img src="/study_photo/2.png" alt="image-20241107104049573"></p><p>Caller（调用段）和 生成代码 -》 encoder编码 -》字节流 -》打包传送给对端</p><p><strong>好处</strong></p><p><img src="/study_photo/3.png" alt="image-20241107104333574"></p><p><img src="/study_photo/4.png" alt="image-20241107111602308"></p><p><img src="/study_photo/5.png" alt="image-20241107111758336"></p><h4 id="2-编解码层："><a href="#2-编解码层：" class="headerlink" title="2.编解码层："></a>2.编解码层：</h4><p><img src="/study_photo/6.png" alt="image-20241107111909320"></p><p>编解码层：</p><p><img src="/study_photo/7.png" alt="image-20241107111950413"></p><p>二进制编码</p><p><img src="/study_photo/8.png" alt="image-20241107112146078"></p><p>左侧是IDL中写的统一的 -》字节流 有额外的内存开销</p><p><img src="/study_photo/10.png" alt="image-20241107112827203"></p><p><img src="/study_photo/11.png" alt="image-20241107112953295"></p><p><strong>多路复用</strong>：同一个链接内 可以有多个请求流通过</p><p>协议解析：</p><p><img src="/study_photo/12.png" alt="image-20241107113245207"></p><h4 id="4-网络通信层："><a href="#4-网络通信层：" class="headerlink" title="4.网络通信层："></a>4.网络通信层：</h4><p><img src="/study_photo/13.png" alt="image-20241107113347859"></p><p>SCOEKT API   （ip+端口）</p><p>一端关闭套接字    如果另一端如果尝试去读 可能就会返回（End Of File）也就是 EOF 在项目中我好像遇到过这个问题 用postman测试的时候返回了EOF错误和nil</p><p>网络库</p><p><img src="/study_photo/14.png" alt="image-20241107113810046"></p><h3 id="二-RPC关键指标分析与企业实践"><a href="#二-RPC关键指标分析与企业实践" class="headerlink" title="二.RPC关键指标分析与企业实践"></a>二.RPC关键指标分析与企业实践</h3><p>稳定性 易用性 扩展性 观测性 高性能</p><p>稳定性：</p><p><img src="/study_photo/15.png" alt="image-20241107114134948"></p><p><strong>过程：</strong>a调用b b调用c c如果响应慢 b就会一直等待 a也就超时了 a就会频繁调用b b堆积大量请求就会宕机</p><p>熔断起保护作用</p><p>稳定性：请求成功了率</p><p><img src="/study_photo/16.png" alt="image-20241107114404973"></p><p>1.均匀调用服务的每个节点</p><ol start="2"><li>重试几次</li></ol><p><img src="/study_photo/17.png" alt="image-20241107114611581"></p><p>备份请求： 左侧正常 1失败  2是重试请求  总时间 t1＋t2</p><p>​                    右侧 t3 tct99（这个值 在这个时间内应该可以返回值）如果在时间内没返回 就发送2请求 总时间就是 t4</p><h4 id="1-注册中间件"><a href="#1-注册中间件" class="headerlink" title="1.注册中间件"></a>1.注册中间件</h4><p><img src="/study_photo/18.png" alt="image-20241107114931005"></p><h4 id="2-易用性："><a href="#2-易用性：" class="headerlink" title="2.易用性："></a>2.易用性：</h4><p><img src="/study_photo/19.png" alt="image-20241107115019715"></p><p>自动生成代码工具 ： 减少重复性工作</p><h4 id="3-扩展性"><a href="#3-扩展性" class="headerlink" title="3.扩展性"></a>3.扩展性</h4><p><img src="/study_photo/20.png" alt="image-20241107115236618"></p><p>用户请求 经过中间件处理-》和远端交互 -》 也通过中间件处理-》服务器</p><h4 id="4-观测性："><a href="#4-观测性：" class="headerlink" title="4.观测性："></a>4.观测性：</h4><p><img src="/study_photo/21.png" alt="image-20241107115409542"></p><p>日志观察 监控面板qbs 链路跟踪（服务通过请求为什么超时了 耗费的时间是多少）</p><p>linux的top工具类似原理</p><h4 id="5-高性能："><a href="#5-高性能：" class="headerlink" title="5.高性能："></a>5.高性能：</h4><p><img src="/study_photo/22.png" alt="image-20241107115628087"></p><p>高吞吐：在单位时间内尽可能多的处理更多请求</p><p>低延迟： 一次请求发出去延迟尽可能地低（重要）</p><p>​</p><h4 id="6-本章总结："><a href="#6-本章总结：" class="headerlink" title="6.  本章总结："></a>6.  本章总结：</h4><p><img src="/study_photo/23.png" alt="image-20241107115938337"></p><p>字节实践：</p><p><img src="/study_photo/24.png" alt="image-20241107120230033"></p><p>组件 结构 远端交互层 网络库  代码生成工具 （最左侧）</p><p>为什么自研网络库？</p><p>gonet</p><p><img src="/study_photo/25.png" alt="image-20241107120515080"></p><p>Netpoll</p><p><img src="/study_photo/26.png" alt="image-20241107120603540"></p><p><img src="/study_photo/27.png" alt="image-20241107120656906"></p><p>交互方式pingpang（一发一回） 编解码 应用层协议</p><p>优化：</p><p><img src="/study_photo/28.png" alt="image-20241107120826363"></p><p><img src="/study_photo/29.png" alt="image-20241107120948515"></p><p>你应该想这些是怎么实现的？</p><p><img src="/study_photo/30.png" alt="image-20241107121448901"></p><p><img src="/study_photo/31.png" alt="image-20241107121741751"></p><h3 id="三-走进HTTP协议"><a href="#三-走进HTTP协议" class="headerlink" title="三.走进HTTP协议"></a>三.走进HTTP协议</h3><h4 id="1-再谈http协议"><a href="#1-再谈http协议" class="headerlink" title="1.再谈http协议"></a>1.再谈http协议</h4><p>HTTP 超文本传输协议</p><p><img src="/study_photo/32.png" alt="image-20241108133154991"></p><p>http协议将人话以计算机语言传输过去</p><p><img src="/study_photo/33.png" alt="image-20241108133257828"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">请求行</span><br><span class="line">：分隔 原数据</span><br><span class="line"></span><br><span class="line">包的字节数</span><br><span class="line">大空行</span><br><span class="line"></span><br><span class="line">我们想说的话</span><br><span class="line"></span><br><span class="line">下面是回复</span><br></pre></td></tr></table></figure><p><img src="/study_photo/34.png" alt="image-20241108133725032"></p><p><img src="/study_photo/35.png" alt="image-20241108133847415"></p><p>上述功能代码：</p><p><img src="/study_photo/36.png" alt="image-20241108134149368"></p><p>处理流程:</p><p><img src="/study_photo/37.png" alt="image-20241108134229285"></p><p>H1的不足 H2也没完全解决    UDP解决对头阻塞</p><p><img src="/study_photo/38.png" alt="image-20241108134628306"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>美化博客</title>
      <link href="/2024/11/08/lasting_beauty/"/>
      <url>/2024/11/08/lasting_beauty/</url>
      
        <content type="html"><![CDATA[<p>使博客看起来更加美观，持续更新中！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>发布博客出现的问题</title>
      <link href="/2024/11/06/github_actions/"/>
      <url>/2024/11/06/github_actions/</url>
      
        <content type="html"><![CDATA[<p>每一次用push推送到githubpage都会出现构建部署错误 我问了一下ai原因 这才有点明白到底是为什么</p><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>为什么会有这种差异？<br>GitHub Pages 和 本地环境的差异：</p><p>在本地执行 hexo d 时，你的本地环境会根据 package.json 中的依赖来安装所有的主题和插件，确保所有必要的资源都存在。<br>但是 GitHub Pages 仅仅依赖仓库中已经推送的文件（通常是 public&#x2F; 文件夹和 ._config.yml），它不会自动运行 npm、yarn 或 pnpm 来安装依赖。换句话说，GitHub Pages 并不会在部署过程中安装缺少的主题或插件。<br>依赖没有正确推送：</p><p>你在本地运行 hexo d 时，可能已经正确地安装了 butterfly 主题，并且该主题存在于本地的 _config.yml 中和 node_modules 文件夹中。<br>然而，在推送到 GitHub 上时，你没有将 node_modules 中的 butterfly 主题或相关配置文件推送到 GitHub 仓库。GitHub Pages 需要能够访问这些主题文件，而它不会在部署过程中下载和安装这些依赖。<br>GitHub Pages 配置问题：</p><p>如果你直接使用 GitHub Pages 作为部署平台，GitHub 并不会自动安装你的 Hexo 依赖，因此它不能像本地环境一样找到 butterfly 主题。<br>GitHub Pages 需要使用一个可以通过静态文件夹来部署的版本，而 Hexo 本地运行时通常会将主题内容放在 node_modules 中，这些内容并不会自动推送到 GitHub，除非你特别将它们包含在仓库中。</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>使用github-actions<br>并且在google查找到的方法添加 .nojekyll文件 让github站点不适用jekyll</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">name: Hexo Deploy</span><br><span class="line"></span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches:</span><br><span class="line">      - main  # 监听主分支的推送</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  deploy:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    steps:</span><br><span class="line">      - name: Checkout repository</span><br><span class="line">        uses: actions/checkout@v2</span><br><span class="line"></span><br><span class="line">      - name: Setup Node.js</span><br><span class="line">        uses: actions/setup-node@v2</span><br><span class="line">        with:</span><br><span class="line">          node-version: &#x27;16&#x27;</span><br><span class="line"></span><br><span class="line">      - name: Install dependencies</span><br><span class="line">        run: |</span><br><span class="line">          npm install</span><br><span class="line"></span><br><span class="line">      - name: Generate and Deploy</span><br><span class="line">        run: |</span><br><span class="line">          hexo generate</span><br><span class="line">          hexo deploy</span><br><span class="line">        env:</span><br><span class="line">          HEXO_DEPLOY_PATH: $&#123;&#123; secrets.HEXO_DEPLOY_PATH &#125;&#125;  # 设置部署路径</span><br></pre></td></tr></table></figure><p>多看源码 基础真的很重要 多看官方文档能解决很多问题</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>github参与开源应该做什么</title>
      <link href="/2024/11/05/github/"/>
      <url>/2024/11/05/github/</url>
      
        <content type="html"><![CDATA[<h1 id="第一次参与开源项目应该做些什么"><a href="#第一次参与开源项目应该做些什么" class="headerlink" title="第一次参与开源项目应该做些什么"></a>第一次参与开源项目应该做些什么</h1><p>借鉴Moment老哥文档</p><p><a href="https://juejin.cn/post/7354233858063925267">https://juejin.cn/post/7354233858063925267</a></p><h4 id="第一步fork"><a href="#第一步fork" class="headerlink" title="第一步fork"></a>第一步fork</h4><p>fork到自己的仓库下 且选择fork所有分支 这样就可以有修改项目的权限<br>通过Pull Request方式 commits合到上游项目</p><h4 id="第二步克隆项目"><a href="#第二步克隆项目" class="headerlink" title="第二步克隆项目"></a>第二步克隆项目</h4><p>git clone …</p><h4 id="第三步更新本地分支代码"><a href="#第三步更新本地分支代码" class="headerlink" title="第三步更新本地分支代码"></a>第三步更新本地分支代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git remote add upstream &lt;原始仓库的URL&gt;</span><br><span class="line">git fetch upstream</span><br><span class="line">git checkout main</span><br><span class="line">git rebase upstream/main</span><br></pre></td></tr></table></figure><p>等等指令在此省略 详细的等到具体运用中再做增加</p><p>创建新的分支并在新的分支上作出修改 回到fork的仓库中找到pullRequest<br>NewRequest并把自己更改的分支上传到作者的仓库也就完成了一次Request</p><h4 id="写入你想更改的地方"><a href="#写入你想更改的地方" class="headerlink" title="写入你想更改的地方"></a>写入你想更改的地方</h4><p>提交你的更改 </p><h4 id="开一个PR"><a href="#开一个PR" class="headerlink" title="开一个PR"></a>开一个PR</h4><p>在完成 push 操作后，我们打开 GitHub，可以看到一个黄色的提示框，告诉我们可以开一个 Pull Request 了</p><p>参考：</p><p><a href="https://link.juejin.cn/?target=https://github.com/xun082/create-neat/pull/83">https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fxun082%2Fcreate-neat%2Fpull%2F83</a><br>一定要参与一次实践，才懂得如何去做。只有错过了，才能保证下一次的完美运行。</p><hr><p>最后希望自己早入加入开源大家庭中，加油！ </p><ul><li><pre><code>                     2024 11.5日</code></pre></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git使用总结</title>
      <link href="/2024/11/04/git/"/>
      <url>/2024/11/04/git/</url>
      
        <content type="html"><![CDATA[<h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><p>1.git clone &#x2F;&#x2F; 到本地<br>2.git checkout -b xxx 切换至新分支xxx<br>（相当于复制了remote的仓库到本地的xxx分支上<br>3.修改或者添加本地代码（部署在硬盘的源文件上）<br>4.git diff 查看自己对代码做出的改变<br>5.git add 上传更新后的代码至暂存区<br>6.git commit 可以将暂存区里更新后的代码更新到本地git<br>7.git push origin xxx 将本地的xxxgit分支上传至github上的git</p><hr><p>（如果在写自己的代码过程中发现远端GitHub上代码出现改变）<br>1.git checkout main 切换回main分支<br>2.git pull origin master(main) 将远端修改过的代码再更新到本地<br>3.git checkout xxx 回到xxx分支<br>4.git rebase main 我在xxx分支上，先把main移过来，然后根据我的commit来修改成新的内容<br>（中途可能会出现，rebase conflict —–》手动选择保留哪段代码）<br>5.git push -f origin xxx 把rebase后并且更新过的代码再push到远端github上<br>（-f —》强行）<br>6.原项目主人采用pull request 中的 squash and merge 合并所有不同的commit</p><hr><p>远端完成更新后<br>1.git branch -d xxx 删除本地的git分支<br>2.git pull origin master 再把远端的最新代码拉至本地</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>北京之旅</title>
      <link href="/2024/11/04/hello-world/"/>
      <url>/2024/11/04/hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="开源社"><a href="#开源社" class="headerlink" title="开源社"></a>开源社</h2><p>在偶然一次发现中 开源社举办了第九届中国开源年会，我很是激动，心中迅速萌发了去北京参加的冲动并和小伙伴赵冰<br>决定这周五来一次说走就走的旅行~~~</p><h2 id="到达北京"><a href="#到达北京" class="headerlink" title="到达北京"></a>到达北京</h2><p>在周六的早上到达会场 扫了入场的码 领到了活动给的一些礼品 7点多我俩就到达了会场，刚开始觉得平平无奇，后来直到大会开始，陆陆续续的大家都来到了会场，开源社的<br>老哥，老姐们开始了自己的演讲，我发现这真的不是一个普通大会，很多人报着开源的理念 一直维持着开源社，让开源社越来越大<br>虽然是第一次参加，但是我对于这种氛围是非常的喜欢，各位有着自己想法的人都在开源社散发光辉，有为抗癌人士专门发布app的<br>小胰宝等其他的产品，这令我深受触动，把科技真真正正的融合到了生活当中，使人们都能享受科技带来的便捷！大会中的每一个人的演讲都令我感到激动！但是对我印象的最深刻的就是<strong>yihong0618</strong>这个id，伊洪老师的演讲令我眼前一亮心里一跳哈哈哈哈<br>简直太爽啦！！！</p><h2 id="yihong0618"><a href="#yihong0618" class="headerlink" title="yihong0618"></a>yihong0618</h2><p>请大家自己去看伊洪老师的github，你真的能从中学到很多，在火车上我一直再看伊洪老师的github<br>每一件事是写的那么的真诚，有很多我也感同身受，生活的迷茫原来真的不是自己才有，面临各种压力，各种抉择！做好自己。<br>老师的仓库里也有非常多的实用的产品大家可以自己去看！！</p><p>[github] <a href="https://github.com/yihong0618">https://github.com/yihong0618</a></p><p>在伊洪老师的演讲中，令我觉得钦佩的是，每一天的记录自己，我太喜欢这种感觉了，发布到github上，我也便想向这么做<br>在4日赶回来我便从网上学习搭建博客，坚持记录每一天</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这次旅程，说走就走，哈哈哈，这才是大学生嘛，遇见了开源社的大家，我希望从今的每一天，慢慢的融入到开源社这个大家庭</p><p>-感谢冰哥陪我这次旅行</p><pre><code>                                                                    2024年11.4日</code></pre>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>音乐</title>
      <link href="/Music/index.html"/>
      <url>/Music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>图库</title>
      <link href="/Gallery/index.html"/>
      <url>/Gallery/index.html</url>
      
        <content type="html"><![CDATA[<div class="gallery-group-main"><figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='/Gallery/beijing.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">北京</div>  <p>车站</p>  <a href='/Gallery/beijing.jpg'></a>  </figcaption>  </figure>  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='/Gallery/beijing2.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">北京</div>  <p>风景</p>  <a href='/Gallery/beijing2.jpg'></a>  </figcaption>  </figure>  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='/Gallery/beijing3.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">北京</div>  <p>中关村</p>  <a href='/Gallery/beijing3.jpg'></a>  </figcaption>  </figure>  </div><div class="gallery-container" data-type="data" data-button="">      <div class="gallery-items">[{"url":"/bizhi/11.png","alt":""},{"url":"/bizhi/11.png","alt":""},{"url":"/bizhi/11.png","alt":""},{"url":"/bizhi/11.png","alt":""},{"url":"/bizhi/11.png","alt":""},{"url":"/bizhi/11.png","alt":""},{"url":"/bizhi/11.png","alt":""},{"url":"/bizhi/11.png","alt":""}]</div>    </div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友情链接</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
